<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    
    <title>
        HashMap解析 | 4Details
    </title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
        <link rel="shortcut icon" href="/images/favicon01.png">
    
    
<link rel="stylesheet" href="/css/style.css">

    <script id="hexo-configurations">
    let CONFIG = {"hostname":"yoursite.com","root":"/","localsearch":{"enable":true,"trigger":"auto","unescape":false,"preload":false},"themeInfo":{"name":"ILS","version":"1.2.0","author":"XPoet","repository":"https://github.com/XPoet/hexo-theme-ils"},"path":"search.json"};
  </script>
<meta name="generator" content="Hexo 5.1.1"><link rel="alternate" href="/atom.xml" title="4Details" type="application/atom+xml">
</head>


<body>
<div class="page-template">
    <div class="page-top">
        <header class="header-wrapper">

    <div class="header-progress"></div>

    <div class="header-content">

        <a class="logo-title" href="/">
            4Details
        </a>

        <ul class="menu-list">
            
                <li class="menu-item">
                    <a class=""
                       href="/"
                    >
                        主页
                    </a>
                </li>
            
                <li class="menu-item">
                    <a class=""
                       href="/archives"
                    >
                        归档
                    </a>
                </li>
            
                <li class="menu-item">
                    <a class=""
                       href="/links"
                    >
                        链接
                    </a>
                </li>
            
                <li class="menu-item">
                    <a class=""
                       href="/about"
                    >
                        关于
                    </a>
                </li>
            
        </ul>

        <div class="menu-bar">
            <div class="menu-bar-middle"></div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item">
                    <a class=""
                       href="/">主页</a>
                </li>
            
                <li class="drawer-menu-item">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item">
                    <a class=""
                       href="/links">链接</a>
                </li>
            
                <li class="drawer-menu-item">
                    <a class=""
                       href="/about">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


    </div>

    <div class="page-middle ">

        <main class="main-content normal-code-theme">

            <div class="main-content-left">
                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <h3><a class="title-hover-animation">HashMap解析</a></h3>
        </div>

        <div class="meta-info">
            <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa fa-calendar-o"></i> 2020-08-22 23:25:32
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fa fa-folder"></i>
            <ul>
                
                    <li>
                        <a href="/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/">算法笔记</a>
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa fa-tags"></i>
            <ul>
                
                    <li>
                        <a href="/tags/HashMap/">HashMap</a>
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa fa-eye"></i> <span id="busuanzi_value_page_pv"></span>
        </span>
    
    
        <span class="article-wordcount article-meta-item">
        <i class="fa fa-book"></i> <span>5.3k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
        <i class="fa fa-clock-o"></i> <span>22 分钟</span>
        </span>
    
</div>

        </div>

        <div class="article-content markdown-body">
            <h1 id="HashMap继承体系"><a href="#HashMap继承体系" class="headerlink" title="HashMap继承体系"></a>HashMap继承体系</h1><p><img src="https://s1.ax1x.com/2020/09/08/wQ8ldI.png" alt="HashMap继承体系"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/09/08/wQ1ek6.png" alt="结构"></p>
<p>外层Node长度为16，当链表长度大于达到8且hash中所有元素达到64个，链表会升级为红黑树。</p>
<p><strong>HashMap底层结构其实就是 数组+链表+红黑树</strong></p>
<p>Hash碰撞指的是不同的key被映射到相同的位置，hashMap使用链表连接这些碰撞值，当碰撞非常严重时，查询效率由O(1) 退化为 O(n)</p>
<p>jdk1.8 之后引入红黑树（自平衡的二叉查找树） 的目的就是解决链化严重的问题。</p>
<p>hashMap加入红黑树优化不是一开始的选择，所以没有向TreeMap那样，要求实现Comparable接口或者提供相应的比较器。但由于树化过程需要比较两个键对象的大小，在键类没有实现Comparable接口的情况下，hashMap做出以下处理以保证可以比较出两个键的大小：</p>
<ol>
<li>比较键与键之间hash的大小，如果hash相同，则继续</li>
<li>检测键类是否实现了Comparable接口，如果实现了则调用<code>compareTo()</code>方法进行比较</li>
<li>如果仍未比较出大小，就需要进行仲裁，方法为 <code>tieBreakOrder</code></li>
</ol>
<h2 id="核心元素"><a href="#核心元素" class="headerlink" title="核心元素"></a>核心元素</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缺省table大小  16，必须是2的次幂</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="comment">// table最大长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// 负载因子大小，默认 0.75f，计算得到扩容阈值  16 * 0.75 = 12。大于1数组不会扩容，牺牲性能换内存</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 树化阈值 8，链表长度超过8，链表会被升级成树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 树降级成链表的阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// hash表中元素超过64且某个链上元素超过8，才会树化。</span></span><br><span class="line"><span class="comment">// 树化阈值的第二条件，不满足链表不会转换成红黑树，而是优先扩容数组。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Node数组构建的 Hash表</span></span><br><span class="line"><span class="comment">// 什么时候初始化？put第一个元素的时候</span></span><br><span class="line"><span class="keyword">transient</span> HashMap.Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">// 当前hash中元素个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">// 当前哈希表中结构修改次数，导致结构变化的修改</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"><span class="comment">// 扩容阈值， 当哈希表中的元素超过阈值时，会触发扩容</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">// 负载因子</span></span><br><span class="line"><span class="comment">// 计算threshold  = capacity * loadFactor</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// table 内部数组是节点类型</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">int</span> hash; </span><br><span class="line">     <span class="keyword">final</span> K key;</span><br><span class="line">     V value;</span><br><span class="line">     Node&lt;K,V&gt; next; <span class="comment">//下一个节点</span></span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hashMap内部数组是节点类型的，hash冲突解决方案是<strong>拉链法</strong>。hash值是经过<code>hash()</code>方法处理过的hashCode，也就是数组索引<code>bucket</code>，为了使hashCode分布更加随机。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.util.HashMap&lt;K, V&gt;.Node&lt;K, V&gt;</span><br><span class="line">    java.util.LinkedMap&lt;K, V&gt;.Entry&lt;K, V&gt;</span><br><span class="line">        java.util.HashMap&lt;K, V&gt;.TreeNOde&lt;K, V&gt;</span><br></pre></td></tr></table></figure>

<p>TreeNode 是 Node的子类，继承关系如下：</p>
<p>Node是单向链表节点，Entry是双向链表节点，TreeNode是红黑树节点。</p>
<h2 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h2><p>HashMap是一个基于拉链法实现的一个散列表，内部由数组、链表和红黑树实现。</p>
<ol>
<li>数组的初始大小为16，而且是以2的次幂扩容，一是为了提高性能能使用足够大的数组；二是为了能使用位运算代替取模运算（据说提升了5-8倍）</li>
<li>数组是否需要扩容是根据负载因子来判断的，如果当前数组中元素个数大于<code>数组长度 * 负载因子</code>大小时会触发扩容。默认负载因子为0.75，可由构造函数传入。当然也可以设置负载因子大于1，这样数组不会发生扩容，牺牲性能，节省内存。</li>
<li>为了解决hash碰撞，数组中的元素是单向链表型。当链表长度超过一个阈值（默认是8）时，会将链表转化为红黑树以提高性能；而当链表长度缩小到一个阈值（默认是6）时，红黑树又会退化成链表来提高性能。</li>
<li>补充说明，在链表树化之前还会检查数组中元素总数有没有超过一个阈值（默认64），如果没有达到阈值，则会放弃树化，优先选择扩容数组提高性能；如果超过了阈值，则会发生链表树化。</li>
</ol>
<blockquote>
<p><strong>第二条件？</strong> </p>
<p>当bucket数目较小时，hash散列产生冲突的概率较高，导致链表长度过长，此时应该扩容，而不是立即树化（保证查找性能）。产生碰撞的主要原因是bucket的数目过少，优先扩容可以避免一些不必要的树化过程。同时，当bucket容量较少时，扩容会比较频繁，扩容时需要差分红黑树并重新映射。<strong>所以在bucket容量较小情况下，将长链表树化不是最优选择。</strong></p>
<p><strong>以6和8来作为平衡点的原因：</strong></p>
<p>红黑树的平均查找长度为O(log n)，长度为8查找长度为3，链表的平均查找长度为4 （n/2），这才有转化为树的必要；链表长度如果是≤6，虽然速度也很快，但是转化为树结构和生成树花费的时间不会太短。</p>
<p>6和8之间有个插值7，可以防止链表和树之间频繁切换。假设转换阈值只有8，那么链表长度超过8就会树化，小于8就会转化为链表，如果一个HashMap不断地插入、删除元素，链表长度在8左右徘徊，就会频繁发生树化、链表转树，效率会很低。</p>
<ul>
<li>链表：如果元素个数小于8，查询成本高，退化为O(n)，新增成本低；</li>
<li>红黑树：如果元素个数大于8，查询成本低，新增成本高</li>
</ul>
</blockquote>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p><code>put</code>、<code>resize</code>、<code>get</code>、<code>remove</code>、<code>replace</code></p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造方法一：默认数组初始容量为16，负载因子为0.75f</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造方法二：指定数组的初始容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造方法三</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 校验：0 &lt; initialCapacity &lt;  MAXIMUM_CAPACITY; </span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                    initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">// 校验：loadFactor &gt; 0</span></span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                    loadFactor);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">// tableSizeFor() 返回一个大于等于initialCapacity的2的次幂数</span></span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* tableSizeFor() 返回一个大于等于initialCapacity的2的次幂数</span></span><br><span class="line"><span class="comment">* 任何一个十进制数，转换为二进制，</span></span><br><span class="line"><span class="comment">* 函数返回结果是 从最高位1开始，所有位全部变为 1，最后再 +1 （即进位变为2的次方数）输出</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 用实际例子可以测试，如 10 可以得到 16</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>; <span class="comment">// 若跳过，得到结果会 *2 </span></span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组的索引bucket"><a href="#数组的索引bucket" class="headerlink" title="数组的索引bucket"></a>数组的索引bucket</h2><p>HashMap使用hash算法来决定集合中元素的存储位置， 每当系统初始化HashMap时，会创建一个 <strong>capacity</strong> 的数组，这个数组中可以存储元素的位置被称为bucket，每个bucket都有其索引，可以根据索引快速访问存储的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 传入的key经过了 hash(key) 方法</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  作用： 在table长度不大得时候 让key的hash值得高16位也参与路由运算</span></span><br><span class="line"><span class="comment">*  h = 0b 0010 0101 1010 1100 0011 1111 0010 1110</span></span><br><span class="line"><span class="comment">*  0b 0010 0101 1010 1100 0011 1111 0010 1110</span></span><br><span class="line"><span class="comment">*  ^</span></span><br><span class="line"><span class="comment">*  0b 0000 0000 0000 0000 0010 0101 1010 1100</span></span><br><span class="line"><span class="comment">*  =&gt; 0010 0101 1010 1100 0001 1010 1000 0010</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java中每个对象都有一个<code>hashCode()</code>方法，这个就是散列函数，可以返回一个32位整数（为了尽可能避免发生碰撞）</p>
<h2 id="HashMap-put-流程"><a href="#HashMap-put-流程" class="headerlink" title="HashMap.put()  流程"></a>HashMap.put()  流程</h2><ol>
<li>map.put(key,value)  map.put(“tkey”, “tv”) </li>
<li>获取key的hash值    </li>
<li>经过hash值扰动函数，使此hash值更散列</li>
<li>构造Node对象  Hash-&gt; 1122, Key-&gt; “tkey”, Value-&gt;”tv”, Next-&gt; null</li>
<li>路由算法，找出node应存放的数组的位置</li>
</ol>
<blockquote>
<p>路由寻址公式   (table.length - 1) &amp; node.hash   // table.length一定是2的次幂</p>
<p>(16 - 1) &amp; 1122 =&gt; 0000 0000 1111 &amp; 0100 0110 0010 =&gt; 0010 =&gt; 2  将此次的值放在index为2的位置</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// onlyIfAbsent：当存入键值对时，如果该key已存在，是否覆盖它的value。false为覆盖，true为不覆盖 参考putIfAbsent()方法。</span></span><br><span class="line"><span class="comment">// evict：用于子类LinkedHashMap。</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    HashMap.Node&lt;K,V&gt;[] tab; <span class="comment">// tab：内部数组</span></span><br><span class="line">    HashMap.Node&lt;K,V&gt; p;   <span class="comment">// p：hash对应的索引位中的首节点</span></span><br><span class="line">    <span class="keyword">int</span> n, i;  <span class="comment">// n：内部数组的长度    i：hash对应的索引位</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 首次put时，内部数组为空，扩充数组。</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 计算数组索引，获取该索引位置的首节点，如果为null，添加一个新的节点</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;   </span><br><span class="line">        HashMap.Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 如果首节点的key和要存入的key相同，那么直接覆盖value的值。</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 如果首节点是红黑树的，将键值对插添加到红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> HashMap.TreeNode)</span><br><span class="line">            e = ((HashMap.TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 此时首节点为链表，如果链表中存在该键值对，直接覆盖value。</span></span><br><span class="line">        <span class="comment">// 如果不存在，则在末端插入键值对。然后判断链表是否大于等于7，尝试转换成红黑树。</span></span><br><span class="line">        <span class="comment">// 注意此处使用“尝试”，因为在treeifyBin方法中还会判断当前数组容量是否到达64，</span></span><br><span class="line">        <span class="comment">// 否则会放弃次此转换，优先扩充数组容量。</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 走到这里，hash碰撞了。检查链表中是否包含key，或将键值对添加到链表末尾</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// p.next == null，到达链表末尾，添加新节点，如果长度足够，转换成树结构。</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 检查链表中是否已经包含key</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 覆盖value的方法。</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount; <span class="comment">// fail-fast机制</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果元素个数大于阈值，扩充数组。</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <strong><code>put()</code>步骤小结</strong> </p>
<ol>
<li>检查数组是否为空，执行<code>resize()</code>方法扩容；</li>
<li>通过hash值计算索引，获得该索引位的首节点</li>
<li>如果首节点为null，没有发生碰撞，直接添加节点到该索引位（bucket）</li>
<li>如果首节点不为null，分三种情况：<ul>
<li>key和首节点的key相同，覆盖old value（保证key的唯一性）；</li>
<li>如果首节点是红黑树节点（TreeNode），将键值对添加到红黑树</li>
<li>如果首节点是链表，将键值对添加到链表，添加之后会判断是否达到树化阈值</li>
</ul>
</li>
<li>判断数组是否达到扩容阈值</li>
</ol>
<h2 id="HashMap扩容原理"><a href="#HashMap扩容原理" class="headerlink" title="HashMap扩容原理"></a>HashMap扩容原理</h2><p>hash数组太小，链化严重，查询效率退化为O(n)，为了解决哈希冲突导致的上述问题，扩容会缓解，以空间换时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> HashMap.Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    HashMap.Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果数组已经是最大长度，不进行扩充。</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则数组容量扩充一倍。（2的N次方）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果数组还没创建，但是已经指定了threshold（这种情况是带参构造创建的对象），threshold的值为数组长度</span></span><br><span class="line">    <span class="comment">// 在 &quot;构造函数&quot; 那块内容进行过说明。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">// 这种情况是通过无参构造创建的对象</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 可能是上面newThr = oldThr &lt;&lt; 1时，最高位被移除了，变为0。</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 到了这里，新的数组长度已经被计算出来，创建一个新的数组。</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    HashMap.Node&lt;K,V&gt;[] newTab = (HashMap.Node&lt;K,V&gt;[])<span class="keyword">new</span> HashMap.Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下面代码是将原来数组的元素转移到新数组中。问题在于，数组长度发生变化。 </span></span><br><span class="line">    <span class="comment">// 那么通过hash%数组长度计算的索引也将和原来的不同。</span></span><br><span class="line">    <span class="comment">// jdk 1.7中是通过重新计算每个元素的索引，重新存入新的数组，称为rehash操作。</span></span><br><span class="line">    <span class="comment">// 这也是hashMap无序性的原因之一。而现在jdk 1.8对此做了优化，非常的巧妙。</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历原数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            <span class="comment">// 取出首节点</span></span><br><span class="line">            HashMap.Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 如果链表只有一个节点，那么直接重新计算索引存入新数组。</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 如果该节点是红黑树，执行split方法，和链表类似的处理。</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> HashMap.TreeNode)</span><br><span class="line">                    ((HashMap.TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 此时节点是链表</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// loHead，loTail为原链表的节点，索引不变。</span></span><br><span class="line">                    HashMap.Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// hiHeadm, hiTail为新链表节点，原索引 + 原数组长度。</span></span><br><span class="line">                    HashMap.Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    HashMap.Node&lt;K,V&gt; next;</span><br><span class="line">                    </span><br><span class="line">                   <span class="comment">// 遍历链表</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 新增bit为0的节点，存入原链表。</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 新增bit为1的节点，存入新链表。</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 原链表存回原索引位</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 新链表存到：原索引位 + 原数组长度</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在jdk 1.7中，通过rehash操作，遍历每一个元素、每一个节点，重新计算索引值，存入新的数组中。</p>
<p>jdk1.8 之后对rehash进行了优化，数组以2的次幂数扩容，有以下规律：</p>
<p>元素的位置要么在原位置，要么是在原位置再移动2的次幂的位置。因此，在扩容HashMap时无需重新计算hash值，只需要找出原hash值新增的那个bit位是1还是0即可，是0则索引不变，是1索引变成<code>原索引+oldCap</code>，以上操作可以简单通过比特位的变化判断索引位，效率显著提高。</p>
<h2 id="HashMap-get-方法"><a href="#HashMap-get-方法" class="headerlink" title="HashMap.get()  方法"></a>HashMap.get()  方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 也会获取节点时也调用了hash()方法</span></span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tab：内部数组  </span></span><br><span class="line">    <span class="comment">// first: 索引位首节点 </span></span><br><span class="line">    <span class="comment">// n: 数组长度 </span></span><br><span class="line">    <span class="comment">// k: 索引位首节点的key</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">// 数组不为null 数组长度大于0 索引位首节点不为null</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果索引位首节点的hash==key的hash 或者 key和索引位首节点的k相同</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">// 返回索引位首节点(值对象)</span></span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果是红黑树节点 则到红黑树中查找</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// 发送碰撞 key.equals(k)</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>get方法小结</strong></p>
<ol>
<li>检查数组是否为null，索引位节点是否为null</li>
<li>如果索引节点的hash==key的hash 或者key和索引节点的k相同则直接返回索引首节点（bucket的第一个节点）</li>
<li>如果是红黑树，则到红黑树中查找</li>
<li>如果有冲突，则通过key.equals(k)查找</li>
<li>以上都没找到则返回null</li>
</ol>
<h1 id="面试相关"><a href="#面试相关" class="headerlink" title="面试相关"></a>面试相关</h1><ol>
<li><p>是否使用过HashMap？什么是HashMap？为何会使用？</p>
</li>
<li><p>能否让HashMap同步？</p>
<p><code>Map map = Collections.synchronizeMap(hashMap)</code></p>
</li>
<li><p>HashMap的工作原理？</p>
<p>初始化数组16，以2的次幂数扩容；扩容阈值由负载因子判断；拉链法解决hash冲突；冲突节点数大于8且数组中节点总数大于64发生树化，链表节点数小于6，红黑树转化成链表。</p>
</li>
<li><p>HashMap的put()和get()方法的原理？</p>
<p>put方法</p>
<ul>
<li>首次进入，数组为空，需要resize扩容；</li>
<li>计算数组索引，获取该位置首节点，为空则直接插入；</li>
<li>若不为空，分三种情况：<ul>
<li>如果首节点的key和要插入节点的key相同（冲突），直接覆盖old value</li>
<li>如果首节点是红黑树节点，则将键值对插入红黑树</li>
<li>如果首节点是链表节点，存在该键值对，则直接覆盖old value，如果不存在该键值对，判断是否应该树化。判断满足什么条件，做出相应的相应（见前文）。</li>
</ul>
</li>
</ul>
<p>get方法</p>
<ul>
<li>检查数组是否为null，索引位是否为null；</li>
<li>如果索引位节点hash与查询节点key的hash相同， 或者key与索引节点的k相同直接返回索引首节点；</li>
<li>如果是红黑树，则到红黑树中查找；</li>
<li>如果有冲突，则通过key.equals(k)查找；</li>
<li>以上均无返回值，则get结果为null。</li>
</ul>
</li>
<li><p>当两个对象的hashcode相同会发生什么？</p>
<p>两个对象的hashcode相同说明两者在数组中的索引bucket相同，会发生哈希冲突。HashMap使用链表存储对象，这个Entry会存储在链表中，存储时会检查链表中是否包含key（key != null &amp;&amp; key.equals(k) ， 或者将键值对添加到链表尾部。如果链表长度≥8，链表树化….）。</p>
</li>
<li><p>如果两个键的hashcode相同，如何获取值对象？</p>
<p>两个对象的hashcode相同说明在数组中的索引位置相同，找到索引位bucket之后，会调用keys.equals()方法去找到链表中的正确节点（key != null &amp;&amp; key.equals(k) )</p>
</li>
<li><p>怎么减少碰撞 ？</p>
<p>使用final修饰的对象、不可变的对象作为键，例如Integer、String（不可变，final，而且已经重写了equals和hashCode方法）作为键比较好。</p>
<p>可以使用自定义的对象作为键，只要遵守了equals和hashCode方法定义规则，并且当对象插入到hashMap中之后将不会再改变。</p>
</li>
<li><p>如果HashMap的大小超过了负载因子的定义容量，怎么办？</p>
<p>会调用<code>resize()</code>方法进行数组扩容</p>
</li>
<li><p>了解重新调整HashMap大小存在什么问题麽？</p>
<p>在多线程的情况下，可能产生条件竞争。</p>
<p>因为如果两个线程都发现HashMap需要重新调整大小，二者会同时试着调整数组大小。在调整过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表尾部而是放在头部（头插法），这是为了避免尾部遍历（Tail Traversing）。如果竞争条件发生了，那么就会造成死循环。</p>
</li>
<li><p>HashMap是非线程安全的，那么原因是什么？（HashMap的死锁）</p>
<p>由于HashMap的容量是有限的，如果HashMap中的数组的容量很小，存储大量元素时，冲突就会很频繁，此时O(1)的查找效率就会退变成O(n)，这是hash表的缺陷。</p>
<p>为了解决上述问题，为HashMap设计了一个阈值，即负载因子 * 数组长度，超过阈值则会触发自动扩容。</p>
</li>
<li><p>影响HashMap性能的因素？</p>
<p>负载因子；</p>
<p>哈希值，理想情况是均匀分布散列到各个bucket。一般HashMap使用String类型作为key，而String类重写了hashCode函数。</p>
</li>
</ol>

        </div>

        <div class="article-nav">
            
                <div class="article-prev">
                    <a class="prev btn"
                       rel="prev"
                       href="/2020/08/27/FATE-1-2-%E5%AE%9E%E8%B7%B501%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/"
                    >
                        <i class="fa fa-chevron-left"></i> <span class="post-nav-title-item">FATE 1.2 实践01-虚拟机安装</span><span class="post-nav-item">上一篇</span>
                    </a>
                </div>
            
            
                <div class="article-next">
                    <a class="next btn"
                       rel="next"
                       href="/2019/09/06/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA50%20-%20%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"
                    >
                        <span class="post-nav-title-item">讨论社区50  -  常见面试题</span><span class="post-nav-item">下一篇</span> <i class="fa fa-chevron-right"></i>
                    </a>
                </div>
            
        </div>

        <div class="comment-container">
            <div class="comments-container">
    
        
    <div class="valine-container">
        <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
        <div id="vcomments"></div>
        <script>
            new Valine({
                el: '#vcomments',
                appId: '7pPhwqK3blQJSznIgu7jRJWI-gzGzoHsz',
                appKey: 'Oz9ktEWXHxxXWg6h7Va0zX57',
                meta: 'nick,mail,link'.split(','),
                avatar: 'wavatar',
                enableQQ: true,
                placeholder: '请提出您的宝贵建议~',
                lang: 'zh-CN'.toLowerCase()
            });


            // Valine 评论列表增加"作者"标识
            const getValineDomTimer = setInterval(() => {
                const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                if (vcards.length > 0) {
                    for (let vcard of vcards) {
                        const vnick = vcard.querySelector('.vhead .vnick');
                        if (vnick.innerHTML.toLocaleLowerCase() === 'wangxu'.toLocaleLowerCase()) {
                            vcard.classList.add('author');
                        }
                    }
                    clearInterval(getValineDomTimer);
                } else {
                    clearInterval(getValineDomTimer);
                }
            }, 2000);
        </script>
    </div>


    
</div>
        </div>
    </div>
</div>


                

            </div>

            
                <div class="main-content-right">
                    
    <div class="sidebar sidebar-post fade-in-down-animation">
        <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#HashMap%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB"><span class="nav-number">1.</span> <span class="nav-text">HashMap继承体系</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E5%85%83%E7%B4%A0"><span class="nav-number">1.1.</span> <span class="nav-text">核心元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="nav-number">1.2.</span> <span class="nav-text">继承关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93"><span class="nav-number">1.3.</span> <span class="nav-text">简单总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">2.</span> <span class="nav-text">源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">2.1.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E7%B4%A2%E5%BC%95bucket"><span class="nav-number">2.2.</span> <span class="nav-text">数组的索引bucket</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap-put-%E6%B5%81%E7%A8%8B"><span class="nav-number">2.3.</span> <span class="nav-text">HashMap.put()  流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap%E6%89%A9%E5%AE%B9%E5%8E%9F%E7%90%86"><span class="nav-number">2.4.</span> <span class="nav-text">HashMap扩容原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap-get-%E6%96%B9%E6%B3%95"><span class="nav-number">2.5.</span> <span class="nav-text">HashMap.get()  方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3"><span class="nav-number">3.</span> <span class="nav-text">面试相关</span></a></li></ol>
    </div>
</div>
    </div>

                </div>
            

        </main>

        <div class="sidebar-tools">
            <div class="tools-container">
    <ul class="tools-list">
        
            <li class="search popup-trigger">
                <i class="fa fa-search"></i>
            </li>
            
<script src="/js/local-search.js"></script>

        
        <li class="mode-toggle">
            <i class="fa fa-moon-o"></i>
        </li>
        
            <li class="rss">
                <a href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a>
            </li>
        
    </ul>
</div>

        </div>

        
            <div class="scroll-to-top">
                <ul>
                    <li>
                        <!--<i class="fa fa-caret-up"></i>-->
                        <span class="scroll-percent"></span>
                    </li>
                </ul>
            </div>
        
    </div>

    <div class="page-bottom">
        <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy; 2020 <i class="fa fa-heart-o"></i> <a href="/">wangxu</a>
        </div>
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动 | 主题 <a
                    href="https://github.com/XPoet/hexo-theme-ils" target="_blank">ILS v1.2.0</a>
        </div>
        
            <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                
                    <span id="busuanzi_container_site_pv" style="display: none">
                        总访问量 <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
</div>

    <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-icon">
            <i class="fa fa-search"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fa fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>



<script src="/js/main.js"></script>
<script src="/js/header-shrink.js"></script>
<script src="/js/toggle-mode.js"></script>



    
<script src="/js/scroll-to-top.js"></script>





    
        
<script src="/js/code-copy.js"></script>

    

    
        
<script src="/lib/anime.min.js"></script>
<script src="/js/toc.js"></script>

    




</body>
</html>