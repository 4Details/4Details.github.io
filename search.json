[{"title":"FATE 1.2 实践02-FATE集群部署","url":"/2020/08/27/FATE-1-2-%E5%AE%9E%E8%B7%B502%EF%BC%9AFATE%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/","content":"配置FATE环境第1步中虚拟机创建完成后的信息如下\n\n\n\n主机名\nhost155\nguest156\nguest157\n\n\n\nIP\n192.168.119.155\n192.168.119.156\n192.168.119.157\n\n\n\n\n\n\n\n\n下面的步骤均是依据官方文档操作 \n基础环境配置注意：不特殊说明，下面配置需要在所有机器上操作！！\n由于在创建虚拟机过程中已经更改过每台主机名、创建用户app，所以文档中hostname配置可跳过。\nroot权限下创建文件夹  /data/projects 归属 app用户\n&#x2F;&#x2F;切换root用户，-p创建文件夹，给app用户赋予权限su rootmkdir -p &#x2F;data&#x2F;projectschown -R app &#x2F;data&#x2F;projects\n\n\n\n关闭selinux确认是否已安装selinux\ncentos系统执行：rpm -qa | grep selinux\nubuntu系统执行：apt list –installed | grep selinux\n如果已安装了selinux就执行：setenforce 0\n\n修改Linux最大打开文件数切换root用户，在limits.conf文件最后添加5、6行代码，保存退出\nsu rootvim &#x2F;etc&#x2F;security&#x2F;limits.conf* soft nofile 65536* hard nofile 65536\n\n\n\n\n添加主机映射vim &#x2F;etc&#x2F;hosts\n\n\n\n\n关闭虚拟机防火墙在实际生产环境中需要配置防火墙端口规则！虚拟机环境下采用关闭防火墙的方式。\n如果是Centos系统：\nsystemctl disable firewalld.servicesystemctl stop firewalld.servicesystemctl status firewalld.service\n\n本例的环境是Centos系统\n\n如果是Ubuntu系统：\nufw disableufw status\n\n给用户赋予sudo权限root用户下对app用户赋予sudo权限\nvim &#x2F;etc&#x2F;sudoers.d&#x2F;appapp ALL&#x3D;(ALL) ALLapp ALL&#x3D;(ALL) NOPASSWD: ALLDefaults !env_reset\n\n\n\n配置ssh远程登录a. 切换app用户，生成rsa_id，具体根据下面代码\n\nb.合并id_rsa_pub文件\n步骤如下：三台机器分别将id_rsa.pub 写入authorized_keys文件中并且赋予权限chomd 600\n\n155通过scp将authorized_keys文件发送到156上，并将156的id_rsa.pub文件写入，然后将生成的新文件发送至157上，并且写入157生成的id_rsa.pub文件，将最终生成的authorized_keys文件发送给155和156，此时通过ssh即可登录（在发送文件过程中建立连接需要输入密码）\n155-&gt;156\n\n156写入， -&gt;157\n\n157写入，-&gt;155  -&gt;156\n\n上述完成之后即可通过  ssh usernane@ip访问某台虚拟机\n需要注意的是，访问自身需要重新建立一个连接。\n建议配置以上步骤之后拍摄虚拟机快照，便于后期恢复重新部署。\nFATE部署完成基础环境配置之后，接下来就需要部署FATE的运行环境，本例使用的是Installation文档。\n下面的操作只需在其中一台机器操作即可，本例选用的是host 155。\n下载压缩包可以使用wget下载，也可以直接通过链接下载。\ncd &#x2F;data&#x2F;projectswget https:&#x2F;&#x2F;webank-ai-1251170195.cos.ap-guangzhou.myqcloud.com&#x2F;FATE_install_v1.2.0.tar.gztar -xf FATE_install_v1.2.0.tar.gz\n\n\n\n\n修改configuration文件可以使用vim，也可以直接使用编辑器打开并修改。\ncd &#x2F;data&#x2F;projects&#x2F;FATE&#x2F;cluster-deploy&#x2F;scriptvi multinode_cluster_configuration.sh\n\n\n\n\n\n建议在部署之前拍摄快照，为防止在部署过程中因某些配置出错造成部署失败。\n部署本例中选择在各机器上部署所有组件。\ncd FATE&#x2F;cluster-deploy&#x2F;scripts# 部署所有组件bash deploy_cluster_multinode.sh binary all # 只部署部分组件(可选：jdk python mysql redis fate_flow federatedml fateboard proxy federation roll meta-service egg)：bash deploy_cluster_multinode.sh binary fate_flow\n\n\n\n-———————————————————————————————————————-\n———————————————–漫长地等待过程——————————————————–\n-———————————————————————————————————————-\n（部署时间暂未统计，时间需要2-4个小时，记录下了部署过程中终端产生的日志）\n此处为语雀文档，点击链接查看：https://www.yuque.com/u190689/qoiq3w/seeq38\n配置检查请务必详细对照检查！！！\n到各个目标服务器上进行检查对应模块的配置是否准确，每个模块的对应配置文件所在路径可在此配置文件下查看，参考：https://github.com/FederatedAI/FATE/blob/master/cluster-deploy/doc/configuration.md\n至此，FATE v1.2的安装部署全部结束，接下来测试环境。\n建议部署成功之后拍摄快照，便于将来找到还原点。\n","categories":["联邦学习"],"tags":["FATE","FL"]},{"title":"回文串引发的“血案”","url":"/2020/08/28/%E5%9B%9E%E6%96%87%E4%B8%B2%E5%BC%95%E5%8F%91%E7%9A%84%E2%80%9C%E8%A1%80%E6%A1%88%E2%80%9D/","content":"简单枚举# 基于中心线枚举Class Solution:\tdef longestPalindrome(self,s):        if not s:            return &quot;&quot;                self.start, self.longest = 0, 0        for middle in range(len(s)):            self.find_longest_palidrome_from(s, middle, middle)            self.find_longest_palidrome_from(s, middle, middle+1)        return s[self.start:self.start + self.longest]        def find_longest_palidrome_from(self, s, left, right):        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:            left -= 1            right += 1        if self.longest &lt; right -left -1:            self.longest = right - left -1            self.start = left +1\n\n\n动态规划# 基于动态规划（区间型：从小到大枚举区间）class Solution:\tdef longestPalindrome(self, s):        if not s:            return &quot;&quot;                n = len(s)        is_palindrome = [[False] * n for _ in range(n)]        for i in range(n):            is_palindrome[i][i] = True        for i in range(1, n):            is_palindrome[i][i-1] = True                start, longest = 0, 1        for length in range(2, n-1):            for i in range(n - length + 1):                j = i + length -1                is_palindrome[i][j] = is_palindrome[i+1][j-1] and s[i] == s[j]                if is_palindrome[i][j] and length &gt; longest:                    longest = length                    start = i         return s[start:start + longest]\n\n","categories":["算法笔记"],"tags":["回文串","动态规划"]},{"title":"FATE 1.2 实践01-虚拟机安装","url":"/2020/08/27/FATE-1-2-%E5%AE%9E%E8%B7%B501%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/","content":"创建虚拟机新建虚拟机使用VMWare WorkStation创建虚拟机（单机版只需要一台机器，集群版可以使用多台机器，下面示例中创建了3台虚拟机，配置均为 300G，16GB，4核处理器，系统镜像为 CentOS-7-x86_64-DVD-1810版本）\n\n\n\n                         \n\n\n                                       \n配置操作系统启动虚拟机，加载并配置操作系统\n     \n  \n此处选择默认语言为【简体中文】，可以直接在编辑框输入快速查找。下一步则需要配置系统的软件、磁盘分区、网络等信息。\n\n这里需要注意的是详细配置图中标注的1，2，3。本例中详细的配置如下：\n\n本例中选择的是GNOME桌面版的软件，已选环境附加选项可根据实际需要选择，选择桌面版的可视化环境有利于后续工作的进行。下一步选择安装目标位置中提前配置分区信息尤为重要！！！\n\n\n\n官方文档中建议全部磁盘挂载到新建的用户app下，但是本例中将大部分磁盘挂载到root下，经实践是有效的，在如上配置之后点击【完成】即可完成磁盘及分区的配置。\n下一步需要提前完成系统网络信息的配置，如主机名、ip、子网掩码、DNS、路由信息等。\n\n点击【配置】可进入ip、DNS等信息的配置。\n\n在上图的配置中需要注意的是，选择手动配置IPv4的信息，地址、子网掩码和网关需要配置正确，本例中DNS服务器默认为网关信息。网络信息配置完成之后可以【开启】以太网的连接，详细的信息可以参考下图\n\n1，2，3的所有信息完成配置之后点击【开始安装】则进入安装界面，此时可以配置系统root用户的密码以及新建用户。本例中遵循官方文档创建用户 app，在“高级用户配置”中，编辑app分属apps组，用户id为6000。\n\n\n等待安装完成，【重启】即可进入桌面版的centos7 操作系统。\n\n初始设置需要接受许可证协议，【完成配置】即可登录输入密码，进入系统。\n\n提示：在实际操作中无需一步步按照上述步骤创建三台或多台虚拟机，在创建完成一台虚拟机之后可以通过“克隆”操作得到已安装完成的虚拟机镜像，这样可以在一定程度上节约创建虚拟机的时间，需要注意的是，在克隆完成启动之前需要重新生成机器的mac地址，否则会造成mac冲突。因为原始虚拟机使用的是静态地址，所以在开启之后需要重新对副本虚拟机分配静态IP。\n克隆方法主要是： 点击 虚拟机-管理-克隆  使用克隆虚拟机向导\n\n\n\n重命名和选择虚拟机所在路径之后点击【完成】即可。\n\n\n\n打开虚拟机之后可以使用  ifconfig查看网络配置信息\n\n需要更改的信息有 主机名、ip\n\n配置IP信息主要路径在 /etc/sysconfig/network-script，修改 sysconf-ens33 （ens33指的是网卡名称）\n文件中可以修改的有是否静态ip，PROTO一项改为 static  配置ip地址，子网掩码，网关，dns\n\n进入编辑页面\n\n半角状态输入’i’可修改内容，修改完成如下，Esc退出编辑，”:wq”可以保存修改并退出vim编辑页面\n\n重启之后使用ifconfig查看，ip已经改变。\n克隆得到另外两台虚拟机，按上述步骤修改IP信息之后即完成了本例中的创建虚拟机步骤。\n\n","categories":["联邦学习"],"tags":["FATE","FL"]},{"title":"HashMap解析","url":"/2020/08/22/HashMap%E8%A7%A3%E6%9E%90/","content":"HashMap继承体系\n","tags":["HashMap"]},{"title":"讨论社区32  -  发送、显示系统通知","url":"/2019/08/05/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA32%20-%20%E5%8F%91%E9%80%81%E3%80%81%E6%98%BE%E7%A4%BA%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%9F%A5/","content":"发送系统通知\n触发事件\n评论后，发布通知\n点赞后，发布通知\n关注后，发布通知\n\n\n处理事件\n封装事件对象\n开发事件的生产者\n开发事件的消费者\n\n\n\n显示系统通知\n通知列表\n\n显示评论、点赞、关注三种类型的通知\n\n统一处理三种类型的通知\n\n通知详情\n\n分页显示某一类主题所包含的通知\n\n\n未读消息\n\n在页面头部显示所有的未读消息数量\n\n用拦截器处理，要注册拦截器\n@Componentpublic class MessageInterceptor implements HandlerInterceptor &#123;    @Autowired    private HostHolder hostHolder;    @Autowired    private MessageService messageService;    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;        User user = hostHolder.getUser();        if (user != null &amp;&amp; modelAndView != null) &#123;            int letterUnreadCount = messageService.findLetterUnreadCount(user.getId(), null);            int noticeUnreadCount = messageService.findNoticeUnreadCount(user.getId(), null);            modelAndView.addObject(&quot;allUnreadCount&quot;, letterUnreadCount + noticeUnreadCount);        &#125;    &#125;&#125;\n\n\n\n\n","categories":["讨论社区项目"],"tags":["Kafka"]},{"title":"讨论社区31  -  Spring整合Kafka","url":"/2019/08/04/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA31%20-%20Spring%E6%95%B4%E5%90%88Kafka/","content":"\n引入依赖\nspring-kafka\n\n\n\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;    &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n配置Kafka\n配置server、consumer\n\n\n\n# KafkaPropertiesspring.kafka.bootstrap-servers=localhost:9092# kafka/config下consumer.properties，默认group-id是test-consumer-groupspring.kafka.consumer.group-id=talking-consumer-groupspring.kafka.consumer.enable-auto-commit=truespring.kafka.consumer.auto-commit-interval=3000\n\n\n\n\n访问Kafka\n生产者kafkaTemplate.send(topic, data);\n消费者@KafkaListener(topics = &#123;&quot;test&quot;&#125;)public void handleMessage(ConsumerRecord record) &#123;&#125;\n\n\n\nimport org.apache.kafka.clients.consumer.ConsumerRecord;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.kafka.annotation.KafkaListener;import org.springframework.kafka.core.KafkaTemplate;import org.springframework.stereotype.Component;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTest@ContextConfiguration(classes = TalkingApplication.class)public class KafkaTests &#123;    @Autowired    private KafkaProducer kafkaProducer;    @Test    public void testKafka() &#123;        kafkaProducer.sendMessage(&quot;test&quot;, &quot;你好&quot;);        kafkaProducer.sendMessage(&quot;test&quot;, &quot;在吗&quot;);        try &#123;            Thread.sleep(1000 * 10);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;@Componentclass KafkaProducer &#123;    @Autowired    private KafkaTemplate kafkaTemplate;    public void sendMessage(String topic, String content) &#123;        kafkaTemplate.send(topic, content);    &#125;&#125;@Componentclass KafkaConsumer &#123;    @KafkaListener(topics = &#123;&quot;test&quot;&#125;)    public void handleMessage(ConsumerRecord record) &#123;        System.out.println(record.value());    &#125;&#125;\n\n","categories":["讨论社区项目"],"tags":["Spring","Kafka"]},{"title":"讨论社区30  -  Kafka入门","url":"/2019/08/03/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA30%20-%20Kafka%E5%85%A5%E9%97%A8/","content":"本项目中仅使用Kafka的消息系统\n\nKafka简介\nKafka是一个分布式的流媒体平台。\n应用：消息系统、日志收集、用户行为追踪、流式处理。\n\n\nKafka特点\n高吞吐量、消息持久化、高可靠性、高扩展性。\n\n\nKafka术语\nBroker、Zookeeper\nTopic、Partition、Offset\nLeader Replica 、Follower Replica\n\n\n\n下载地址：http://kafka.apache.org/downloads\n解压缩之后需要更改一些配置\nwindows 启动zookeeper和kafka（windows下启动报错，可以尝试直接删除日志文件夹重新启动）\nzookeeper-server-start.bat d:\\software\\kafka_2.12-2.3.0\\config\\zookeeper.propertieskafka-server-start.bat d:\\software\\kafka_2.12-2.3.0\\config\\server.properties\n\n\n\n创建一个test主题 分区\n\n查询是否创建成功\nD:\\software\\kafka_2.12-2.3.0\\bin\\windows&gt;kafka-topics.bat --list --bootstrap-server localhost:9092test\n\n生产者生产消息（重新开生产者终端）\nD:\\software\\kafka_2.12-2.3.0\\bin\\windows&gt;kafka-console-producer.bat --broker-list localhost:9092 --topic test&gt;hi&gt;hello world&gt;\n\n消费者消费消息（重新开消费者终端）\n# 从头开始消费D:\\software\\kafka_2.12-2.3.0\\bin\\windows&gt;kafka-console-consumer.bat --bootstrap-server localhost:9092 --topic test --from-beginninghihello world\n\n","categories":["讨论社区项目"],"tags":["Kafka"]},{"title":"讨论社区29  -  阻塞队列","url":"/2019/08/01/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA29%20-%20%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/","content":"BlockingQueue\n\n解决线程通信的问题。\n\n\n传统解决线程通信问题也可以使用Object中的 wait(),notify()方法等\n\n\n阻塞方法：put、take。\n\n\n\n生产者消费者模式\n没有缓存区域（阻塞队列），生产者和消费者速率不一致，会浪费CPU资源（生产&gt;消费？ 生产&lt;消费？）\n\n阻塞队列满了，生产者线程阻塞暂停生产，等待消费；阻塞队列空了，消费者线程阻塞暂停消费，等待生产。\n\n\n\n\n生产者：产生数据的线程。\n消费者：使用数据的线程。\n\n\n实现类\n\nArrayBlockingQueue\nLinkedBlockingQueue\nPriorityBlockingQueue、SynchronousQueue、DelayQueue等。\n\n\n\n/***  ArrayBlockingQueue 实现类 demo**/import java.util.Random;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.BlockingQueue;public class BlockingQueueTests &#123;    public static void main(String[] args) &#123;        BlockingQueue queue = new ArrayBlockingQueue(10);        new Thread(new Producer(queue)).start();        new Thread(new Consumer(queue)).start();        new Thread(new Consumer(queue)).start();        new Thread(new Consumer(queue)).start();    &#125;&#125;// 定义生产者的类，继承线程 Runnable接口，实现 run() 方法class Producer implements Runnable &#123;    private BlockingQueue&lt;Integer&gt; queue;    public Producer(BlockingQueue&lt;Integer&gt; queue) &#123;        this.queue = queue;    &#125;    @Override    public void run() &#123;        try &#123;            for (int i = 0; i &lt; 100; i++) &#123;                Thread.sleep(20);                queue.put(i);                System.out.println(Thread.currentThread().getName() + &quot;生产:&quot; + queue.size());            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;// 定义消费者的类，继承线程 Runnable接口，实现 run() 方法class Consumer implements Runnable &#123;    private BlockingQueue&lt;Integer&gt; queue;    public Consumer(BlockingQueue&lt;Integer&gt; queue) &#123;        this.queue = queue;    &#125;    @Override    public void run() &#123;        try &#123;            while (true) &#123;                Thread.sleep(new Random().nextInt(1000)); //消费者消费较慢                queue.take();                System.out.println(Thread.currentThread().getName() + &quot;消费:&quot; + queue.size());            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n","categories":["讨论社区项目"],"tags":["Redis"]},{"title":"讨论社区28  -  优化登录模块","url":"/2019/07/31/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA28%20-%20%E4%BC%98%E5%8C%96%E7%99%BB%E5%BD%95%E6%A8%A1%E5%9D%97/","content":"前面临时方案将验证码存储进Session，分布式部署场景会存在Session同步和共享的问题。\n\n使用Redis存储验证码\n验证码需要频繁的访问与刷新，对性能要求较高。\n验证码不需永久保存，通常在很短的时间后就会失效。\n分布式部署时，绕过Session共享的问题。\n\n\n\n\n使用Redis存储登录凭证\n处理每次请求时，都要查询用户的登录凭证，访问的频率非常高。\n\n\n\n\n登录凭证使用频率高，关系型数据库存储登录凭证，每一次都要重新查询，影响性能。\n\n重构 UserService   登录成功保存凭证，退出时需删除凭证，查询凭证\n\n退出删除并不是真的删除，而是将登录凭证的状态值改为1，为将来扩展预留。如第一次登录？\n\n\n使用Redis缓存用户信息\n处理每次请求时，都要根据凭证查询用户信息，访问的频率非常高。\n\n\n\n重构 UserService\n查询过程：尝试从缓存中取值，若取不到说明没有初始化进Redis中，需要初始化。\n​        改变用户数据之后，需要更新缓存：1.更新缓存，更新操作麻烦且可能存在用户数据并发的问题；2.删除缓存，下一次请求重新初始化\n// 1.优先从缓存中取值private User getCache(int userId) &#123;    String redisKey = RedisKeyUtil.getUserKey(userId);    return (User) redisTemplate.opsForValue().get(redisKey);&#125;// 2.取不到时初始化缓存数据private User initCache(int userId) &#123;    User user = userMapper.selectById(userId);    String redisKey = RedisKeyUtil.getUserKey(userId);    redisTemplate.opsForValue().set(redisKey, user, 3600, TimeUnit.SECONDS);    return user;&#125;// 3.数据变更时清除缓存数据private void clearCache(int userId) &#123;    String redisKey = RedisKeyUtil.getUserKey(userId);    redisTemplate.delete(redisKey);&#125;\n\n","categories":["讨论社区项目"],"tags":["Redis"]},{"title":"讨论社区27  -  关注相关功能实现","url":"/2019/07/29/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA27%20-%20%E5%85%B3%E6%B3%A8%E5%92%8C%E5%8F%96%E6%B6%88%E5%85%B3%E6%B3%A8%E5%AE%9E%E7%8E%B0/","content":"开发时应考虑性能问题：用户关注另一用户、帖子等，如何做到实时响应，实时获取？\n——数据存到Redis中，提升性能。\n为什么使用Redis实现这个功能？\n关注、取消关注\n需求\n开发关注、取消关注功能。\n统计用户的关注数、粉丝数。\n\n\n关注\n若A关注了B，则A是B的Follower（粉丝），B是A的Followee（目标）。\n关注的目标可以是用户、帖子、题目等，在实现时将这些目标抽象为实体。\n\n\n\n关注列表、粉丝列表\n业务层\n查询某个用户关注的人，支持分页。\n查询某个用户的粉丝，支持分页。\n\n\n表现层\n处理“查询关注的人”、“查询粉丝”请求。\n编写“查询关注的人”、“查询粉丝”模板。\n\n\n\n","categories":["讨论社区项目"],"tags":["Redis"]},{"title":"讨论社区26  -  点赞功能和收到赞实现","url":"/2019/07/28/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA26%20-%20%E7%82%B9%E8%B5%9E%E5%8A%9F%E8%83%BD%E5%92%8C%E6%94%B6%E5%88%B0%E8%B5%9E%E5%AE%9E%E7%8E%B0/","content":"开发时应考虑性能问题：很多用户对同一帖子或回复点赞。——数据存到Redis中，提升性能。\n为什么使用Redis实现这个功能？\n点赞\n点赞\n支持对帖子、评论点赞。\n第1次点赞，第2次取消点赞。\n\n\n首页点赞数量\n统计帖子的点赞数量。\n\n\n详情页点赞数量\n统计点赞数量。\n显示点赞状态。\n\n\n\n无需再写DAO层，直接在Service实现，然后通过RedisConfig文件操作。\n\n\n\n\n我收到的赞可以基于上面的点赞数据实现去统计，但是需要统计所有帖子，然后针对帖子去统计赞，业务繁杂。\n一般采用下面的方式：\n\n重构点赞功能\n以用户为key，记录点赞数量\nincrement(key)，decrement(key)\n\n\n\n\n开发个人主页\n以用户为key，查询点赞数量\n\n\n\n","categories":["讨论社区项目"],"tags":["Redis"]},{"title":"讨论社区25  -  Spring整合Redis","url":"/2019/07/27/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA25%20-%20Spring%E6%95%B4%E5%90%88Redis/","content":"\n引入依赖\n\nspring-boot-starter-data-redis\n\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;    &lt;!--包含在spring boot中可以不用写VersionId，已做好兼容--&gt;&lt;/dependency&gt;\n\n配置Redis\n\n配置数据库参数\n编写配置类，构造RedisTemplate\n\n# RedisPropertiesspring.redis.database=1spring.redis.host=localhostspring.redis.port=6379\n\nimport org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.RedisSerializer;@Configurationpublic class RedisConfig &#123;    @Bean    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory)&#123;        RedisTemplate&lt;String, Object&gt;  template = new RedisTemplate&lt;String, Object&gt;();        template.setConnectionFactory(factory);        // 设置key的序列化方式        template.setKeySerializer(RedisSerializer.string());        // 设置value的序列化方式        template.setValueSerializer(RedisSerializer.json());        // 设置hash的key的序列化方式        template.setHashKeySerializer(RedisSerializer.string());        // 设置hash的value的序列化方式        template.setHashValueSerializer(RedisSerializer.json());        template.afterPropertiesSet();        return template;    &#125;&#125;\n\n访问Redis\n\nredisTemplate.opsForValue()\nredisTemplate.opsForHash()\nredisTemplate.opsForList()\nredisTemplate.opsForSet()\nredisTemplate.opsForZSet()\n\n\n\n多次访问一个redisKey可以做绑定操作\n// 多次访问同一个key@Testpublic void testBoundOperations() &#123;    String redisKey = &quot;test:count&quot;;    BoundValueOperations operations = redisTemplate.boundValueOps(redisKey);    operations.increment();    operations.increment();    operations.increment();    operations.increment();    operations.increment();    System.out.println(operations.get());&#125;\n\nRedis的事务处理\n// 编程式事务@Testpublic void testTransactional() &#123;    Object obj = redisTemplate.execute(new SessionCallback() &#123;    @Override    public Object execute(RedisOperations operations) throws DataAccessException &#123;        String redisKey = &quot;test:tx&quot;;        operations.multi();        operations.opsForSet().add(redisKey, &quot;zhangsan&quot;);        operations.opsForSet().add(redisKey, &quot;lisi&quot;);        operations.opsForSet().add(redisKey, &quot;wangwu&quot;);        \t\t//立即查询不会得出结果        System.out.println(operations.opsForSet().members(redisKey));        // 提交事务        return operations.exec();        &#125;    &#125;);        System.out.println(obj);&#125;\n\n","categories":["讨论社区项目","编程笔记"],"tags":["Spring","Redis"]},{"title":"找不到请求的.Net Framework Data Provider.可能没有安装.  错误","url":"/2019/07/27/%E6%89%BE%E4%B8%8D%E5%88%B0%E8%AF%B7%E6%B1%82%E7%9A%84-Net-Framework-Data-Provider-%E5%8F%AF%E8%83%BD%E6%B2%A1%E6%9C%89%E5%AE%89%E8%A3%85-%E9%94%99%E8%AF%AF/","content":"问题：这几天在装.NET 的开发环境，在装好VS2013和Oracle 11g之后，做了一个测试项目，运行调试没问题但是涉及到数据库相关操作，如新建数据集、连接数据库等在调试的时候则会出现如下错误：\n\n目前百度之后现存的解决方案：\noracle odp.net 32位/64位版本的问题解决方案链接；当然如果觉得这篇写的不怎么清楚，还可以点击 这里*（我碰到的就是这个问题，但是据博主提供的方法没有解决问题）*\n\nMicrosoft SQL Server Compact 4.0没有安装 这个问题是比较好解决的，只用安装Microsoft SQL Server Compact4.0即可，具体可以点击这里\n\n还有修改machine.config配置文件的方法，大家也可以尝试点击这里\n当然如果你的数据库使用的Oracle，节点配置的时候需要根据实际情况做出调整。具体文件配置路径：C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\Config下面的machine.config用记事本打开，查看下列节点是否存在oracle的相关配置\n&lt;system.data&gt;    &lt;DbProviderFactories&gt;      &lt;add name&#x3D;&quot;ODP.NET, Managed Driver&quot; invariant&#x3D;&quot;Oracle.ManagedDataAccess.Client&quot; description&#x3D;&quot;Oracle Data Provider for .NET, Managed Driver&quot; type&#x3D;&quot;Oracle.ManagedDataAccess.Client.OracleClientFactory, Oracle.ManagedDataAccess, Version&#x3D;4.121.2.0, Culture&#x3D;neutral, PublicKeyToken&#x3D;89b483f429c47342&quot; &#x2F;&gt;      &lt;add name&#x3D;&quot;Microsoft SQL Server Compact Data Provider 4.0&quot; invariant&#x3D;&quot;System.Data.SqlServerCe.4.0&quot; description&#x3D;&quot;.NET Framework Data Provider for Microsoft SQL Server Compact&quot; type&#x3D;&quot;System.Data.SqlServerCe.SqlCeProviderFactory, System.Data.SqlServerCe, Version&#x3D;4.0.0.0, Culture&#x3D;neutral, PublicKeyToken&#x3D;89845dcd8080cc91&quot; &#x2F;&gt;    &lt;&#x2F;DbProviderFactories&gt;  &lt;&#x2F;system.data&gt;\n\n新添加的应该是这一块：\n&lt;add name&#x3D;&quot;ODP.NET, Managed Driver&quot; invariant&#x3D;&quot;Oracle.ManagedDataAccess.Client&quot; description&#x3D;&quot;Oracle Data Provider for .NET, Managed Driver&quot; type&#x3D;&quot;Oracle.ManagedDataAccess.Client.OracleClientFactory, Oracle.ManagedDataAccess, Version&#x3D;4.121.2.0, Culture&#x3D;neutral, PublicKeyToken&#x3D;89b483f429c47342&quot; &#x2F;&gt;\n\n个人解决方案前面说过了，我尝试了上述的一些办法之后仍然没有解决问题，熬不住了我就去csdn的论坛发了帖，等了半个小时没人回复（可能是积分太少吧），无奈我就自己继续鼓捣了。想起来自己有一个 ODAC 12c的安装包，就直接点击安装了，安装完成之后重启VS，继续新建项目，配置数据库，调试之后竟然没有再继续报错，也就是说这个问题被我糊里糊涂解决了，哈哈哈~\n写一篇记录一下，给各位一个借鉴也给自己一个教训。下面提供ODAC 12c的下载地址\n官方下载地址：x64下载、x86下载\n如果没有oracle账号又或是账号无法登陆，可以通过这个链接下载， 密码：amvz\n\n\n","categories":["编程笔记"],"tags":[".Net"]},{"title":"讨论社区24  -  Redis入门","url":"/2019/07/25/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA24%20-%20Redis%E5%85%A5%E9%97%A8/","content":"\nRedis是一款基于键值对的NoSQL数据库，它的值支持多种数据结构：字符串(strings)、哈希(hashes)、列表(lists)、集合(sets)、有序集合(sorted sets)等。\n\nredis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。\n这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。\n\n\nRedis将所有的数据都存放在内存中，所以它的读写性能十分惊人。同时，Redis还可以将内存中的数据以快照或日志的形式保存到硬盘上，以保证数据的安全性。\n\n\n\nRDB  体积小。以快照形式存储到硬盘比较耗时，也会对进程造成阻塞，故可以隔一段时间执行\nAOF  可以实时存储。以日志形式存储Redis命令，是以追加日志的方式，占磁盘空间，恢复则是重复执行所有的记录命令，恢复速度较差。\n\n\nRedis典型的应用场景包括：缓存、排行榜、计数器、社交网络、消息队列等。\n\nLinux安装\n官网下载压缩包安装  http://download.redis.io/releases/redis-3.0.0.tar.gz\n通过wget命令下载安装\n\n# 下载之后解压到/usr/local路径，进入redis文件夹，make编译安装wget http://download.redis.io/releases/redis-3.0.0.tar.gztar -xvzf redis-3.0.0.tar.gz /usr/localcd redis-3.0.0make PREFIX=/usr/local/redis install\n\n启动redis服务端\n# 前台启动，终端关闭，服务端就关闭./redis-server# 推荐使用下面的后台启动，终端关闭，服务端不会关闭# 修改conf文件，将daemonize改为yesvim /usr/local/redis/bin/redis.conf# 启动redis服务端cd /usr/local/redis./bin/redis-server ./redis.conf\n\n启动redis客户端\n/usr/local/redis/bin/redis-cli \n\nWindows 安装https://github.com/microsoftarchive/redis/releases/download/win-3.2.100/Redis-x64-3.2.100.msi\n一路点击下一步即可安装，建议将安装路径添加到环境变量。\ncmd  $ redis-cli  启动redis客户端\n使用redis键值对的管理和操作1 DEL key该命令用于在 key 存在时删除 key。2 DUMP key序列化给定 key ，并返回被序列化的值。3 EXISTS key检查给定 key 是否存在。4 EXPIRE key seconds为给定 key 设置过期时间。5 EXPIREAT key timestampEXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。6 PEXPIRE key milliseconds设置 key 的过期时间以毫秒计。7 PEXPIREAT key milliseconds-timestamp设置 key 过期时间的时间戳(unix timestamp) 以毫秒计8 KEYS pattern查找所有符合给定模式( pattern)的 key 。9 MOVE key db将当前数据库的 key 移动到给定的数据库 db 当中。10 PERSIST key移除 key 的过期时间，key 将持久保持。11 PTTL key以毫秒为单位返回 key 的剩余的过期时间。12 TTL key以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。13 RANDOMKEY从当前数据库中随机返回一个 key 。14 RENAME key newkey修改 key 的名称15 RENAMENX key newkey仅当 newkey 不存在时，将 key 改名为 newkey 。16 TYPE key返回 key 所储存的值的类型。\n\nredis哈希的操作HDEL key field2 [field2] 删除一个或多个哈希表字段HEXISTS key field 查看哈希表 key 中，指定的字段是否存在。HGET key field 获取存储在哈希表中指定字段的值。HGETALL key 获取在哈希表中指定 key 的所有字段和值HINCRBY key field increment 为哈希表 key 中的指定字段的整数值加上增量 increment 。HINCRBYFLOAT key field increment 为哈希表 key 中的指定字段的浮点数值加上增量 increment 。HKEYS key 获取所有哈希表中的字段HLEN key 获取哈希表中字段的数量HMGET key field1 [field2] 获取所有给定字段的值HMSET key field1 value1 [field2 value2 ] 同时将多个 field-value (域-值)对设置到哈希表 key 中。HSET key field value 将哈希表 key 中的字段 field 的值设为 value 。HSETNX key field value 只有在字段 field 不存在时，设置哈希表字段的值。HVALS key 获取哈希表中所有值HSCAN key cursor [MATCH pattern] [COUNT count] 迭代哈希表中的键值对。\n\nredis列表操作BLPOP key1 [key2 ] timeout 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。BRPOP key1 [key2 ] timeout 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。BRPOPLPUSH source destination timeout 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。LINDEX key index 通过索引获取列表中的元素LINSERT key BEFORE|AFTER pivot value 在列表的元素前或者后插入元素LLEN key 获取列表长度LPOP key 移出并获取列表的第一个元素LPUSH key value1 [value2] 将一个或多个值插入到列表头部LPUSHX key value 将一个或多个值插入到已存在的列表头部LRANGE key start stop 获取列表指定范围内的元素LREM key count value 移除列表元素LSET key index value 通过索引设置列表元素的值LTRIM key start stop 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。RPOP key 移除并获取列表最后一个元素RPOPLPUSH source destination 移除列表的最后一个元素，并将该元素添加到另一个列表并返回RPUSH key value1 [value2] 在列表中添加一个或多个值RPUSHX key value 为已存在的列表添加值\n\nredis集合SADD key member1 [member2] 向集合添加一个或多个成员SCARD key 获取集合的成员数SDIFF key1 [key2] 返回给定所有集合的差集SDIFFSTORE destination key1 [key2] 返回给定所有集合的差集并存储在 destination 中SINTER key1 [key2] 返回给定所有集合的交集SINTERSTORE destination key1 [key2] 返回给定所有集合的交集并存储在 destination 中SISMEMBER key member 判断 member 元素是否是集合 key 的成员SMEMBERS key 返回集合中的所有成员SMOVE source destination member 将 member 元素从 source 集合移动到 destination 集合SPOP key 移除并返回集合中的一个随机元素SRANDMEMBER key [count] 返回集合中一个或多个随机数SREM key member1 [member2] 移除集合中一个或多个成员SUNION key1 [key2] 返回所有给定集合的并集SUNIONSTORE destination key1 [key2] 所有给定集合的并集存储在 destination 集合中SSCAN key cursor [MATCH pattern] [COUNT count] 迭代集合中的元素\n\n有序集合ZADD key score1 member1 [score2 member2] 向有序集合添加一个或多个成员，或者更新已存在成员的分数ZCARD key 获取有序集合的成员数ZCOUNT key min max 计算在有序集合中指定区间分数的成员数ZINCRBY key increment member 有序集合中对指定成员的分数加上增量 incrementZINTERSTORE destination numkeys key [key ...] 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中ZLEXCOUNT key min max 在有序集合中计算指定字典区间内成员数量ZRANGE key start stop [WITHSCORES] 通过索引区间返回有序集合成指定区间内的成员ZRANGEBYLEX key min max [LIMIT offset count] 通过字典区间返回有序集合的成员ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT] 通过分数返回有序集合指定区间内的成员ZRANK key member 返回有序集合中指定成员的索引ZREM key member [member ...] 移除有序集合中的一个或多个成员ZREMRANGEBYLEX key min max 移除有序集合中给定的字典区间的所有成员ZREMRANGEBYRANK key start stop 移除有序集合中给定的排名区间的所有成员ZREMRANGEBYSCORE key min max 移除有序集合中给定的分数区间的所有成员ZREVRANGE key start stop [WITHSCORES] 返回有序集中指定区间内的成员，通过索引，分数从高到底ZREVRANGEBYSCORE key max min [WITHSCORES] 返回有序集中指定分数区间内的成员，分数从高到低排序ZREVRANK key member 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序ZSCORE key member 返回有序集中，成员的分数值ZUNIONSTORE destination numkeys key [key ...] 计算给定的一个或多个有序集的并集，并存储在新的 key 中ZSCAN key cursor [MATCH pattern] [COUNT count] 迭代有序集合中的元素（包括元素成员和元素分值）\n\nredis事务的实现DISCARD 取消事务，放弃执行事务块内的所有命令。EXEC 执行所有事务块内的命令。MULTI 标记一个事务块的开始。UNWATCH 取消 WATCH 命令对所有 key 的监视。WATCH key [key ...] 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。\n\n\n\n\n\nhttps://redis.io\nhttps://github.com/microsoftarchive/redis\n","categories":["讨论社区项目","编程笔记"],"tags":["Redis","NoSQL"]},{"title":"讨论社区23  -  统一记录日志","url":"/2019/07/22/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA23%20-%20%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86%E6%97%A5%E5%BF%97/","content":"需求：\n\n帖子模块\n评论模块\n消息模块\n\nAOP的概念：\n\nAspect Oriented Programing，即面向方面（切面）编程。\nAOP是一种编程思想，是对OOP的补充，可以进一步提高编程的效率。\n\n\nAOP的术语：\n\n每一个Bean称为一个Target，目标对象上有多处可以织入代码，可织入的点称为Joinpoint，AOP解决统一处理需求的方式是将代码定义到切片组件Aspect中，Aspect要通过Pointcut知道哪些位置需要织入代码，最后需要Advice处理通知。\nAOP的实现\n\nAspectJ\n\nAspectJ是语言级的实现，它扩展了Java语言，定义了AOP语法。\nAspectJ在编译期织入代码，它有一个专门的编译器，用来生成遵守Java字节码规范的class文件。\n\n\nSpring AOP\n\nSpring AOP使用纯Java实现，它不需要专门的编译过程，也不需要特殊的类装载器。\nSpring AOP在运行时通过代理的方式织入代码，只支持方法类型的连接点。\nSpring支持对AspectJ的集成。\n\nSpring AOP 是一个高性价比的AOP实现技术。\n\n\nSpring AOP\n\nJDK动态代理\nJava提供的动态代理技术，可以在运行时创建接口的代理实例。\nSpring AOP默认采用此种方式，在接口的代理实例中织入代码。\n\n\nCGLib动态代理\n采用底层的字节码技术，在运行时创建子类代理实例。\n当目标对象不存在接口时，Spring AOP会采用此种方式，在子类实例中织入代码。\n\n\n\nimport org.aspectj.lang.ProceedingJoinPoint;import org.springframework.stereotype.Component;import org.aspectj.lang.annotation.*;@Component@Aspectpublic class AlphaAspect &#123;    // service 包下所有class的所有方法及所有返回值    @Pointcut(&quot;execution(* com.wx.talking.service.*.*(..))&quot;)    public void pointcut() &#123;    &#125;    @Before(&quot;pointcut()&quot;)    public void before() &#123;        System.out.println(&quot;before&quot;);    &#125;    @After(&quot;pointcut()&quot;)    public void after() &#123;        System.out.println(&quot;after&quot;);    &#125;    @AfterReturning(&quot;pointcut()&quot;)    public void afterReturning() &#123;        System.out.println(&quot;afterReturning&quot;);    &#125;    @AfterThrowing(&quot;pointcut()&quot;)    public void afterThrowing() &#123;        System.out.println(&quot;afterThrowing&quot;);    &#125;    @Around(&quot;pointcut()&quot;)    public Object around(ProceedingJoinPoint joinPoint) throws Throwable &#123;        System.out.println(&quot;around before&quot;);        Object obj = joinPoint.proceed(); //Target的方法        System.out.println(&quot;around after&quot;);        return obj;    &#125;&#125;\n\n","categories":["讨论社区项目","编程笔记"],"tags":["日志处理","Spring AOP"]},{"title":"讨论社区22  -  统一处理异常","url":"/2019/07/20/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA22%20-%20%E7%BB%9F%E4%B8%80%E8%AE%B0%E5%BD%95%E5%BC%82%E5%B8%B8/","content":"SpringBoot 的统一处理方法：\n在template文件夹下包含error文件夹，且内容为错误代码.html文件。 template/error/404.html\n\n@ControllerAdvice\n用于修饰类，表示该类是Controller的全局配置类。\n在此类中，可以对Controller进行如下三种全局配置：异常处理方案、绑定数据方案、绑定参数方案。\n\n\n@ExceptionHandler\n用于修饰方法，该方法会在Controller出现异常后被调用，用于处理捕获到的异常。\n\n\n@ModelAttribute\n用于修饰方法，该方法会在Controller方法执行前被调用，用于为Model对象绑定参数。\n\n\n@DataBinder\n用于修饰方法，该方法会在Controller方法执行前被调用，用于绑定参数的转换器。\n\n\n\n// 在Controller出现异常后被调用@ControllerAdvice(annotations = Controller.class)public class ExceptionAdvice &#123;    private static final Logger logger = LoggerFactory.getLogger(ExceptionAdvice.class);    @ExceptionHandler(&#123;Exception.class&#125;)    public void handleException(Exception e, HttpServletRequest request, HttpServletResponse response) throws IOException &#123;        logger.error(&quot;服务器发生异常: &quot; + e.getMessage());        for (StackTraceElement element : e.getStackTrace()) &#123;            logger.error(element.toString());        &#125;        //返回的是异步请求？普通请求        String xRequestedWith = request.getHeader(&quot;x-requested-with&quot;);         if (&quot;XMLHttpRequest&quot;.equals(xRequestedWith)) &#123;            response.setContentType(&quot;application/plain;charset=utf-8&quot;);            PrintWriter writer = response.getWriter();            //...转成JSON对象反馈给视图....            writer.write(getJSONString(1, &quot;服务器异常!&quot;));        &#125; else &#123;            response.sendRedirect(request.getContextPath() + &quot;/error&quot;);        &#125;    &#125;&#125;\n\n","categories":["讨论社区项目","编程笔记"],"tags":["注解","异常处理"]},{"title":"讨论社区21  -  私信列表和发送私信","url":"/2019/07/18/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA21%20-%20%E7%A7%81%E4%BF%A1%E5%88%97%E8%A1%A8%E5%92%8C%E5%8F%91%E9%80%81%E7%A7%81%E4%BF%A1/","content":"表结构\nCREATE TABLE &#96;message&#96; (  &#96;id&#96; int NOT NULL AUTO_INCREMENT,  &#96;from_id&#96; int DEFAULT NULL,  &#96;to_id&#96; int DEFAULT NULL,  &#96;conversation_id&#96; varchar(100) DEFAULT NULL,  &#96;content&#96; text,  &#96;status&#96; int DEFAULT NULL COMMENT &#39;&#39;&#39;0-未读;1-已读;2-删除;&#39;&#39;&#39;,  &#96;create_time&#96; timestamp NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,  PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;\n\nid 为表主键，from_id 、to_id 发送人、接收人；conversation_id 为冗余的会话id，便于查询，拼接规则是 from_id-to_id （但是小id在前，大id在后）；content为会话内容；status为会话状态。\n注：系统或超级管理员在表中user_id为1，所以在查询的时候，from_id为1的会话是系统下发的通知。\n发送私信\n发送私信\n采用异步的方式发送私信。\n发送成功后刷新私信列表。\n\n\n设置已读\n访问私信详情时，将显示的私信设置为已读状态。\n\n\n\n私信列表\n私信列表\n查询当前用户的会话列表\n每个会话只显示一条最新的私信。\n支持分页显示。\n\n\n私信详情\n查询某个会话所包含的私信。\n支持分页显示。\n\n\n\n","categories":["讨论社区项目"]},{"title":"讨论社区20  -  显示、添加评论","url":"/2019/07/16/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA20%20-%20%E6%98%BE%E7%A4%BA%E3%80%81%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA/","content":"显示评论\n数据层\n\n根据实体查询一页评论数据。\n根据实体查询评论的数量。\n\n\n业务层\n\n处理查询评论的业务。\n处理查询评论数量的业务。\n\n\n表现层\n\n显示帖子详情数据时，同时显示该帖子所有的评论数据。\n\n层层封装\n\n\n添加评论\n数据层\n\n增加评论数据。\n修改帖子的评论数量。\n\n\n业务层\n\n处理添加评论的业务：先增加评论、再更新帖子的评论数量。\n\n使用声明式事务\n\n表现层\n\n处理添加评论数据的请求。\n设置添加评论的表单。\n\n\n\n","categories":["讨论社区项目"]},{"title":"讨论社区19  -  事务管理","url":"/2019/07/14/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA19%20-%20%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/","content":"\n回顾\n\n什么是事务\n事务是由N步数据库操作序列组成的逻辑执行单元，这系列操作要么全执行，要么全放弃执行。\n\n\n事务的特性（ACID）\n原子性（Atomicity）：事务是应用中不可再分的最小执行体。\n一致性（Consistency）：事务执行的结果，须使数据从一个一致性状态，变为另一个一致性状态。\n隔离性（Isolation）：各个事务的执行互不干扰，任何事务的内部操作对其他的事务都是隔离的。\n持久性（Durability）：事务一旦提交，对数据所做的任何改变都要记录到永久存储器中。\n\n\n\n事务的隔离性\n\n常见的并发异常\n第一类丢失更新、第二类丢失更新。\n脏读、不可重复读、幻读。\n\n\n常见的隔离级别\nRead Uncommitted：读取未提交的数据。\nRead Committed：读取已提交的数据。\nRepeatable Read：可重复读。\nSerializable：串行化。\n\n\n\n第一类丢失更新：某一个事务的回滚，导致另外一个事务已更新的数据丢失了。\n第二类丢失更新：某一个事务的提交，导致另外一个事务已更新的数据丢失了。\n脏读：某一个事务，读取了另外一个事务未提交的数据。\n不可重复读：某一个事务，对同一个数据前后读取的结果不一致。\n幻读：某一个事务，对同一个表前后查询到的行数不一致。\n事务隔离级别：\n\n实现机制\n\n悲观锁（数据库）\n共享锁（S锁）事务A对某数据加了共享锁后，其他事务只能对该数据加共享锁，但不能加排他锁。\n排他锁（X锁）事务A对某数据加了排他锁后，其他事务对该数据既不能加共享锁，也不能加排他锁。\n\n\n乐观锁（自定义）\n版本号、时间戳等在更新数据前，检查版本号是否发生变化。若变化则取消本次更新，否则就更新数据（版本号+1）。\n\n\n\nSpring事务管理\n\n声明式事务\n\n通过XML配置，声明某方法的事务特征。\n通过注解，声明某方法的事务特征。\n\n\n编程式事务\n\n通过 TransactionTemplate 管理事务，并通过它执行数据库的操作。\n\n\n\n\n\ndemo：用户注册并发帖\n1 使用@Transactional 注入\n2 使用TransactionTemplate\n// REQUIRED: 支持当前事务(外部事务),如果不存在则创建新事务.// REQUIRES_NEW: 创建一个新事务,并且暂停当前事务(外部事务).// NESTED: 如果当前存在事务(外部事务),则嵌套在该事务中执行(独立的提交和回滚),否则就会REQUIRED一样.@Transactional(isolation = Isolation.READ_COMMITTED, propagation = Propagation.REQUIRED)public Object save1()&#123;    //新增用户    ....    //新增帖子    ....&#125;\n\n@Autowiredprivate TransactionTemplate transactionTemplate;public Object save2() &#123;    transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_READ_COMMITTED);    transactionTemplate.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);    return transactionTemplate.execute(new TransactionCallback&lt;Object&gt;() &#123;        @Override        public Object doInTransaction(TransactionStatus status) &#123;            //新增用户            ....            //新增帖子            ....        &#125;        &#125;);    &#125;\n\n","categories":["讨论社区项目"],"tags":["事务","Mysql","事务隔离","事务管理"]},{"title":"讨论社区18  -  帖子详情","url":"/2019/07/12/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA18%20-%20%E5%B8%96%E5%AD%90%E8%AF%A6%E6%83%85/","content":"\nDiscussPostMapper       定义DAO方法\n\nDiscussPostService         业务层\n\nDiscussPostController    控制层\n\nindex.html\n\n在帖子标题上增加访问详情页面的链接\n\n\ndiscuss-detail.html\n\n处理静态资源的访问路径\n复用index.html的header区域\n显示标题、作者、发布时间、帖子正文等内容\n\n\n\n","categories":["讨论社区项目"]},{"title":"讨论社区17  -  发布帖子功能实现","url":"/2019/07/11/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA17%20-%20%E5%8F%91%E5%B8%83%E5%B8%96%E5%AD%90%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/","content":"\nAJAX\nAsynchronous JavaScript and XML\n异步的JavaScript与XML，不是一门新技术，只是一个新的术语。\n使用AJAX，网页能够将增量更新呈现在页面上，而不需要刷新整个页面。\n虽然X代表XML，但目前JSON的使用比XML更加普遍。\nhttps://developer.mozilla.org/zh-CN/docs/Web/Guide/AJAX\n\n\n示例\n使用jQuery发送AJAX请求。\n\n\n实践\n采用AJAX请求，实现发布帖子的功能。\n\n\n\n","categories":["讨论社区项目"]},{"title":"讨论社区16  -  过滤敏感词","url":"/2019/07/09/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA16%20-%20%E8%BF%87%E6%BB%A4%E6%95%8F%E6%84%9F%E8%AF%8D/","content":"最直接：字符串替换 replace方法\n\n问题：敏感词数量多了怎么办？帖子字数很多怎么办？\n生产一般使用前缀树过滤敏感词\n\n\n前缀树\n\n\n名称：Trie、字典树、查找树\n特点：查找效率高，消耗内存大\n应用：字符串检索、词频统计、字符串排序等\n\n\n构建敏感词前缀树：根节点不存储任何信息，每一个敏感词从第一个字符开始，逐个加入树，前缀相同继续在其后添加字符，不相同则从根节点重新开启一颗子树，直至到叶子节点整个路径构成一个敏感词。\n敏感词过滤：\n定义三个指针p，begin，end（p 指向树的根节点，begin 和 end 开始均指向待检测字符串的第一个位置）。\n开始begin、end与 p 同时移动，遇到前缀树中第一层结点，begin停止不动，p 与end 继续移动，检查p 与end 能否匹配至叶子节点，如果是则替换begin 与end之间所有字符，然后begin 与 end 移到敏感词后一个位置，且p 指针归位到根节点；不是则p归位到根节点，begin 向前移动1位，end后退至begin 的位置，重新开始判断。\n注意，在其中不是敏感词的字符存储到新的变量区不改变，敏感词用 特殊符号代替之后append到非敏感词后面。\n\n\n\n\n敏感词过滤器\n\n定义前缀树\n根据敏感词，初始化前缀树\n编写过滤敏感词的方法\n\n// 前缀树private class TrieNode &#123;    // 关键词结束标识    private boolean isKeywordEnd = false;    // 子节点(key是下级字符,value是下级节点)    private Map&lt;Character, TrieNode&gt; subNodes = new HashMap&lt;&gt;();    public boolean isKeywordEnd() &#123;        return isKeywordEnd;    &#125;    public void setKeywordEnd(boolean keywordEnd) &#123;        isKeywordEnd = keywordEnd;    &#125;    // 添加子节点    public void addSubNode(Character c, TrieNode node) &#123;        subNodes.put(c, node);    &#125;    // 获取子节点    public TrieNode getSubNode(Character c) &#123;        return subNodes.get(c);    &#125;&#125;\n\n// 替换符private static final String REPLACEMENT = &quot;***&quot;;// 根节点private TrieNode rootNode = new TrieNode();@PostConstructpublic void init() &#123;    try (        InputStream is = this.getClass().getClassLoader().getResourceAsStream(&quot;sensitive-words.txt&quot;); //sensitive-words.txt存放在resource文件夹下，编译之后一定要在classes下能找到        BufferedReader reader = new BufferedReader(new InputStreamReader(is));    ) &#123;        String keyword;        while ((keyword = reader.readLine()) != null) &#123;            // 添加到前缀树            this.addKeyword(keyword);        &#125;    &#125; catch (IOException e) &#123;        logger.error(&quot;加载敏感词文件失败: &quot; + e.getMessage());    &#125;&#125;// 将一个敏感词添加到前缀树中private void addKeyword(String keyword) &#123;    TrieNode tempNode = rootNode;    for (int i = 0; i &lt; keyword.length(); i++) &#123;        char c = keyword.charAt(i);        TrieNode subNode = tempNode.getSubNode(c);        if (subNode == null) &#123;            // 初始化子节点            subNode = new TrieNode();            tempNode.addSubNode(c, subNode);        &#125;        // 指向子节点,进入下一轮循环        tempNode = subNode;        // 设置结束标识        if (i == keyword.length() - 1) &#123;            tempNode.setKeywordEnd(true);        &#125;    &#125;&#125;\n\n/**  * 过滤敏感词  *  * @param text 待过滤的文本  * @return 过滤后的文本*/public String filter(String text) &#123;    if (StringUtils.isBlank(text)) &#123;        return null;    &#125;    // 指针1    TrieNode tempNode = rootNode;    // 指针2    int begin = 0;    // 指针3    int position = 0;    // 结果    StringBuilder sb = new StringBuilder();    while (position &lt; text.length()) &#123;        char c = text.charAt(position);        // 跳过符号        if (isSymbol(c)) &#123;            // 若指针1处于根节点,将此符号计入结果,让指针2向下走一步            if (tempNode == rootNode) &#123;                sb.append(c);                begin++;            &#125;            // 无论符号在开头或中间,指针3都向下走一步            position++;            continue;        &#125;        // 检查下级节点        tempNode = tempNode.getSubNode(c);        if (tempNode == null) &#123;            // 以begin开头的字符串不是敏感词            sb.append(text.charAt(begin));            // 进入下一个位置            position = ++begin;            // 重新指向根节点            tempNode = rootNode;        &#125; else if (tempNode.isKeywordEnd()) &#123;            // 发现敏感词,将begin~position字符串替换掉            sb.append(REPLACEMENT);            // 进入下一个位置            begin = ++position;            // 重新指向根节点            tempNode = rootNode;        &#125; else &#123;            // 检查下一个字符            position++;        &#125;    &#125;    // 将最后一批字符计入结果 position提前到终点，但begin没有到终点    sb.append(text.substring(begin));    return sb.toString();&#125;// 判断是否为符号private boolean isSymbol(Character c) &#123;    // 0x2E80~0x9FFF 是东亚文字范围    return !CharUtils.isAsciiAlphanumeric(c) &amp;&amp; (c &lt; 0x2E80 || c &gt; 0x9FFF);&#125;\n\n\n","categories":["讨论社区项目"],"tags":["Tire"]},{"title":"讨论社区15  -  检查登录状态","url":"/2019/07/08/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA15%20-%20%E6%A3%80%E6%9F%A5%E7%99%BB%E5%BD%95%E7%8A%B6%E6%80%81/","content":"\n使用拦截器\n\n在方法前标注自定义注解\n拦截所有请求，只处理带有该注解的方法\n\n\n自定义注解\n\n常用的元注解：@Target、@Retention、@Document、@Inherited\n\n\n@Target声明自定义注解的位置（类？方法？属性？）\n@Retention  自定义注解的有效时间（编译时？运行时？）\n@Document  生成文档是否携带注解？\n@Inherited  子类继承父类是否继承注解？\n\n\n如何读取注解：Method.getDeclaredAnnotations ()  //获取方法上所有注解Method.getAnnotation (Class&lt;T&gt; annotationClass)\n\n\n项目中添加自定义注解：\n\n定义自定义注解的类，无需详细实现方法，只需声明为接口，且加上@Target、@Retention\n\nimport java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface LoginRequired &#123;&#125;\n\n\n在需要使用的方法（如上则是在必须登录之后才能访问的路径处）加上@LoginRequired\n拦截器的使用逻辑，拦截有自定义注解的方法，进一步判断，符合则继续，不符合则拒绝\n\nimport com.wx.talking.annotation.LoginRequired;import com.wx.talking.util.HostHolder;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import org.springframework.web.method.HandlerMethod;import org.springframework.web.servlet.HandlerInterceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.lang.reflect.Method;@Componentpublic class LoginRequiredInterceptor implements HandlerInterceptor &#123;    @Autowired    private HostHolder hostHolder;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        if (handler instanceof HandlerMethod) &#123;            HandlerMethod handlerMethod = (HandlerMethod) handler;            // 获取拦截的对象            Method method = handlerMethod.getMethod();            LoginRequired loginRequired = method.getAnnotation(LoginRequired.class);            // 需要登录但当前用户未登录，重定向到首页            if (loginRequired != null &amp;&amp; hostHolder.getUser() == null) &#123;                response.sendRedirect(request.getContextPath() + &quot;/login&quot;);                return false;            &#125;        &#125;        return true;    &#125;&#125;\n\n配置拦截器，不拦截静态文件等\n@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123; \tpublic void addInterceptors(InterceptorRegistry registry) &#123; \t\tregistry.addInterceptor(loginRequiredInterceptor)                .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;); &#125;&#125;\n\n","categories":["讨论社区项目"],"tags":["拦截器","注解"]},{"title":"讨论社区14  -  账号设置","url":"/2019/07/07/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA14%20-%20%E8%B4%A6%E5%8F%B7%E8%AE%BE%E7%BD%AE/","content":"\n上传文件\n\n请求：必须是POST请求\n表单：enctype=“multipart/form-data”\nSpring MVC：通过 MultipartFile 处理上传文件\n\n\n开发步骤\n\n访问账号设置页面\n\n\nService定义访问路径，模板页修改\n\n\n上传头像\n\n\n定义上传路径\n视图层更新\n\n\n获取头像\n\n\n\n","categories":["讨论社区项目"],"tags":["Spring MVC","MultipartFile"]},{"title":"讨论社区13  -  显示登录信息","url":"/2019/07/05/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA13%20-%20%E6%98%BE%E7%A4%BA%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF/","content":"\n拦截器示例\n\n定义拦截器，实现HandlerInterceptor\n配置拦截器，为它指定拦截、排除的路径\n\n@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123;    @Autowired    private AlphaInterceptor alphaInterceptor;    @Autowired    private LoginTicketInterceptor loginTicketInterceptor;    @Autowired    private LoginRequiredInterceptor loginRequiredInterceptor;    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        registry.addInterceptor(alphaInterceptor)                .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;)                .addPathPatterns(&quot;/register&quot;, &quot;/login&quot;);        registry.addInterceptor(loginTicketInterceptor)                .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;);        registry.addInterceptor(loginRequiredInterceptor)                .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;);    &#125;&#125;\n\n拦截器应用\n\n在请求开始时查询登录用户\n在本次请求中持有用户数据\n\n\n需要暂存用户数据，使用本地的类暂存？\nClient访问Server是多线程的，多对一。所以存储用户数据的时候需要考虑多线程，如果仅简单存储用户数据，在并发情况下可能会造成数据混乱。\n线程隔离 ThreadLocal\n\n\n在模板视图上显示用户数据\n在请求结束时清理用户数据\n\n\n\n","categories":["讨论社区项目"],"tags":["拦截器","ThreadLocal"]},{"title":"讨论社区12  -  登录、退出功能实现","url":"/2019/07/04/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA12%20-%20%E7%99%BB%E5%BD%95%E3%80%81%E9%80%80%E5%87%BA%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/","content":"\n访问登录页面\n点击顶部区域内的链接，打开登录页面。\n\n\n登录\n验证账号、密码、验证码。\n成功时，生成登录凭证，发放给客户端。\n失败时，跳转回登录页。\n\n\n退出\n将登录凭证修改为失效状态。\n跳转至网站首页。\n\n\n\n","categories":["讨论社区项目"],"tags":["Spring"]},{"title":"讨论社区11  -  图片验证码","url":"/2019/07/02/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA11%20-%20%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81/","content":"Kaptcha\n\n导入 jar 包\n编写 Kaptcha 配置类\n生成随机字符、生成图片\n\n","categories":["讨论社区项目"],"tags":["图片验证码"]},{"title":"讨论社区10  -  会话管理","url":"/2019/07/01/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA10%20-%20%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/","content":"\nHTTP的基本性质\n\nHTTP是简单的\nHTTP是可扩展的\nHTTP是无状态的，有会话的\n\n\nCookie\n\n是服务器发送到浏览器，并保存在浏览器端的一小块数据。\n浏览器下次访问该服务器时，会自动携带块该数据，将其发送给服务器。\n\n\nSession\n\n是JavaEE的标准，用于在服务端记录客户端信息。\n数据存放在服务端更加安全，但是也会增加服务端的内存压力。\n\n\nSession 依赖于Cookie，Server在Client请求时生成Session（包含Client的一些信息），然后将携带SessionId的Cookie发送给Client\nClient本地存储Cookie，下一次访问Server，服务器识别Client发送的Cookie中携带的SessionId，查找到属于特定Client的登录或其他信息。\n以上可以综合Server和Client，不仅在一定程度上可以缓解双方压力，也能保证安全。\n有必要就存，尽量使用Cookie，减小服务的压力。\n分布式部署使用Session？\n粘性Session——负载均衡不友好\n同步Session——服务端需要同步Session，服务器之间有耦合\n共享Session——单体Session服务器，服务器宕机会所有的都出现问题\n以上可得出目前的处理方式：尽量存在Client端，否则存在服务端数据库。对于传统关系型数据可能仍然出现瓶颈，查询性能（内存中快，硬盘中慢）；但现在出现的NoSQL数据库（如Redis）可以很好的解决上述问题。\n\n\n\n","categories":["讨论社区项目"],"tags":["HTTP","Session","Cookie"]},{"title":"讨论社区09  -  注册功能实现","url":"/2019/06/30/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA09%20-%20%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/","content":"\n访问注册页面\n\n点击顶部区域内的链接，打开注册页面。\n\n\n复用Thymeleaf的标签，复用头部区域\n\n&lt;header class=&quot;bg-dark sticky-top&quot; th:fragment=&quot;header&quot;&gt;\n\n在需要复用的地方\n&lt;header class=&quot;bg-dark sticky-top&quot; th:replace=&quot;index::header&quot;&gt;\n\n提交注册数据\n\n通过表单提交数据。\n服务端验证账号是否已存在、邮箱是否已注册。\n服务端发送激活邮件。\n\n\n激活注册账号\n\n点击邮件中的链接，访问服务端的激活服务。\n\n\n在Service处理，三种结果：激活成功、激活失败、重复激活\npublic int activation(int userId, String code) &#123;        User user = userMapper.selectById(userId);        if (user.getStatus() == 1) &#123;            return ACTIVATION_REPEAT;        &#125; else if (user.getActivationCode().equals(code)) &#123;            userMapper.updateStatus(userId, 1);            clearCache(userId);            return ACTIVATION_SUCCESS;        &#125; else &#123;            return ACTIVATION_FAILURE;        &#125;    &#125;\n\nLoginController处理请求\n@RequestMapping(path = &quot;/activation/&#123;userId&#125;/&#123;code&#125;&quot;, method = RequestMethod.GET)public String activation(Model model, @PathVariable(&quot;userId&quot;) int userId, @PathVariable(&quot;code&quot;) String code) &#123;    int result = userService.activation(userId, code);    if (result == ACTIVATION_SUCCESS) &#123;        model.addAttribute(&quot;msg&quot;, &quot;激活成功,您的账号已经可以正常使用了!&quot;);        model.addAttribute(&quot;target&quot;, &quot;/login&quot;);    &#125; else if (result == ACTIVATION_REPEAT) &#123;        model.addAttribute(&quot;msg&quot;, &quot;无效操作,该账号已经激活过了!&quot;);        model.addAttribute(&quot;target&quot;, &quot;/index&quot;);    &#125; else &#123;        model.addAttribute(&quot;msg&quot;, &quot;激活失败,您提供的激活码不正确!&quot;);        model.addAttribute(&quot;target&quot;, &quot;/index&quot;);    &#125;    return &quot;/site/operate-result&quot;;//返回信息到激活页面&#125;\n\n\n\n\n","categories":["讨论社区项目"],"tags":["JavaMailSender","Thymeleaf"]},{"title":"hexo快速开始","url":"/2019/06/30/hexo%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":["随笔"],"tags":["随笔"]},{"title":"讨论社区08  -  发送邮件","url":"/2019/06/28/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA08%20-%20%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/","content":"\n邮箱设置\n启用客户端SMTP服务\n\n\nSpring Email\n导入 jar 包\n邮箱参数配置\n使用 JavaMailSender 发送邮件\n\n\n模板引擎\n使用 Thymeleaf 发送 HTML 邮件\n\n\n\n","categories":["讨论社区项目"],"tags":["SMTP","JavaMailSender"]},{"title":"JavaSpring项目使用Mail包发送邮件报错无法连接服务器Could not connect to SMTP host","url":"/2019/06/28/JavaSpring%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8Mail%E5%8C%85%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E6%8A%A5%E9%94%99%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8Could-not-connect-to-SMTP-host/","content":"问题在使用SpringBoot的mail依赖库连接sina邮箱发送邮件时遇到如下问题：\norg.springframework.mail.MailSendException: Mail server connection failed; nested exception is javax.mail.MessagingException: Could not connect to SMTP host: smtp.sina.com, port: 465;  nested exception is:\tjavax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target. Failed messages: javax.mail.MessagingException: Could not connect to SMTP host: smtp.sina.com, port: 465;  nested exception is:\tjavax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target; message exception details (1) are:Failed message 1:javax.mail.MessagingException: Could not connect to SMTP host: smtp.sina.com, port: 465;  nested exception is:\tjavax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target\tat com.sun.mail.smtp.SMTPTransport.openServer(SMTPTransport.java:2211)\tat com.sun.mail.smtp.SMTPTransport.protocolConnect(SMTPTransport.java:722)\tat javax.mail.Service.connect(Service.java:342)\tat org.springframework.mail.javamail.JavaMailSenderImpl.connectTransport(JavaMailSenderImpl.java:518)\tat org.springframework.mail.javamail.JavaMailSenderImpl.doSend(JavaMailSenderImpl.java:437)\tat org.springframework.mail.javamail.JavaMailSenderImpl.send(JavaMailSenderImpl.java:361)\tat org.springframework.mail.javamail.JavaMailSenderImpl.send(JavaMailSenderImpl.java:356)\tat com.wx.talking.util.MailClient.sendMail(MailClient.java:36)\tat com.wx.talking.MailTests.testTextMail(MailTests.java:24)\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\tat java.lang.reflect.Method.invoke(Method.java:497)\tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\tat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\tat org.springframework.test.context.junit4.statements.RunBeforeTestExecutionCallbacks.evaluate(RunBeforeTestExecutionCallbacks.java:74)\tat org.springframework.test.context.junit4.statements.RunAfterTestExecutionCallbacks.evaluate(RunAfterTestExecutionCallbacks.java:84)\tat org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:75)\tat org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:86)\tat org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:84)\tat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)\tat org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:251)\tat org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:97)\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\tat org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61)\tat org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70)\tat org.junit.runners.ParentRunner.run(ParentRunner.java:363)\tat org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:190)\tat org.junit.runner.JUnitCore.run(JUnitCore.java:137)\tat com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)\tat com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:33)\tat com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:230)\tat com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:58)Caused by: javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target\tat sun.security.ssl.Alerts.getSSLException(Alerts.java:192)\tat sun.security.ssl.SSLSocketImpl.fatal(SSLSocketImpl.java:1949)\tat sun.security.ssl.Handshaker.fatalSE(Handshaker.java:302)\tat sun.security.ssl.Handshaker.fatalSE(Handshaker.java:296)\tat sun.security.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:1509)\tat sun.security.ssl.ClientHandshaker.processMessage(ClientHandshaker.java:216)\tat sun.security.ssl.Handshaker.processLoop(Handshaker.java:979)\tat sun.security.ssl.Handshaker.process_record(Handshaker.java:914)\tat sun.security.ssl.SSLSocketImpl.readRecord(SSLSocketImpl.java:1062)\tat sun.security.ssl.SSLSocketImpl.performInitialHandshake(SSLSocketImpl.java:1375)\tat sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1403)\tat sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1387)\tat com.sun.mail.util.SocketFetcher.configureSSLSocket(SocketFetcher.java:602)\tat com.sun.mail.util.SocketFetcher.createSocket(SocketFetcher.java:376)\tat com.sun.mail.util.SocketFetcher.getSocket(SocketFetcher.java:214)\tat com.sun.mail.smtp.SMTPTransport.openServer(SMTPTransport.java:2160)\t... 38 moreCaused by: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target\tat sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:387)\tat sun.security.validator.PKIXValidator.engineValidate(PKIXValidator.java:292)\tat sun.security.validator.Validator.validate(Validator.java:260)\tat sun.security.ssl.X509TrustManagerImpl.validate(X509TrustManagerImpl.java:324)\tat sun.security.ssl.X509TrustManagerImpl.checkTrusted(X509TrustManagerImpl.java:229)\tat sun.security.ssl.X509TrustManagerImpl.checkServerTrusted(X509TrustManagerImpl.java:124)\tat sun.security.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:1491)\t... 49 moreCaused by: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target\tat sun.security.provider.certpath.SunCertPathBuilder.build(SunCertPathBuilder.java:146)\tat sun.security.provider.certpath.SunCertPathBuilder.engineBuild(SunCertPathBuilder.java:131)\tat java.security.cert.CertPathBuilder.build(CertPathBuilder.java:280)\tat sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:382)\t... 55 more\n\n分析从日志可以定位原因——没有连接到服务器（smtp.sina.com），原因有很多：\n\n账号密码配置错误？\n开启SSL登录，端口是否正确？\n证书问题？\n\n本文遇到的就是第三个问题。\n先放一张图，便于理解\n\n解决方法当然，StackOverflow上也能找到对应解决方法。\n代码在最后，先给出使用方法\nUsage:Need to compile, first:javac InstallCert.javaNote: since java 11, you can run it directly without compiling it first:java --source 11 InstallCert.java &lt;args&gt;# Access server, and retrieve certificate (accept default certificate 1)java InstallCert [--proxy&#x3D;proxyHost:proxyPort] &lt;host&gt;[:port] [passphrase]# Extract certificate from created jssecacerts keystorekeytool -exportcert -alias [host]-1 -keystore jssecacerts -storepass changeit -file [host].cer# Import certificate into system keystorekeytool -importcert -alias [host] -keystore [path to system keystore] -storepass changeit -file [host].cer# Example:java InstallCert woot.com:443    Loading KeyStore &#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-6-sun-1.6.0.26&#x2F;jre&#x2F;lib&#x2F;security&#x2F;cacerts...    Opening connection to woot.com:443...    Starting SSL handshake...    javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target    &lt;...&gt;    Server sent 1 certificate(s):     1 Subject O&#x3D;Woot Inc, C&#x3D;US, ST&#x3D;Texas, L&#x3D;Carrollton, CN&#x3D;*.woot.com       Issuer  CN&#x3D;SecureTrust CA, O&#x3D;SecureTrust Corporation, C&#x3D;US       sha1    4b 46 ca 6b 83 05 b3 51 ff c6 e7 9c fd b3 9b e3 3f 2e c4 53        md5     e8 a5 88 1b d5 67 bb fc 88 cc b1 c5 2b ac c4 7d     Enter certificate to add to trusted keystore or &#39;q&#39; to quit: [1][enter]    [    [      Version: V3      Subject: O&#x3D;Woot Inc, C&#x3D;US, ST&#x3D;Texas, L&#x3D;Carrollton, CN&#x3D;*.woot.com      Signature Algorithm: SHA1withRSA, OID &#x3D; 1.2.840.113549.1.1.5    &lt;...&gt;    Added certificate to keystore &#39;jssecacerts&#39; using alias &#39;woot.com-1&#39;keytool -exportcert -alias woot.com-1 -keystore jssecacerts -storepass changeit -file woot.com.cer    Certificate stored in file &lt;woot.com.cer&gt;  (sudo) keytool -importcert -alias woot.com -keystore &#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-6-sun-1.6.0.26&#x2F;jre&#x2F;lib&#x2F;security&#x2F;cacerts -storepass changeit -file woot.com.cer    Owner: O&#x3D;Woot Inc, C&#x3D;US, ST&#x3D;Texas, L&#x3D;Carrollton, CN&#x3D;*.woot.com    Issuer: CN&#x3D;SecureTrust CA, O&#x3D;SecureTrust Corporation, C&#x3D;US      &lt;...&gt;      Trust this certificate? [no]:  yes    Certificate was added to keystore\n\n//利用java生成证书文件，复制到jre的security文件夹\n&#x2F;* * Copyright 2006 Sun Microsystems, Inc.  All Rights Reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * *   - Redistributions of source code must retain the above copyright *     notice, this list of conditions and the following disclaimer. * *   - Redistributions in binary form must reproduce the above copyright *     notice, this list of conditions and the following disclaimer in the *     documentation and&#x2F;or other materials provided with the distribution. * *   - Neither the name of Sun Microsystems nor the names of its *     contributors may be used to endorse or promote products derived *     from this software without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS * IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. *&#x2F;&#x2F;** * Originally from: * http:&#x2F;&#x2F;blogs.sun.com&#x2F;andreas&#x2F;resource&#x2F;InstallCert.java * Use: * java InstallCert hostname * Example: *% java InstallCert ecc.fedora.redhat.com *&#x2F;import javax.net.ssl.*;import java.io.*;import java.security.KeyStore;import java.security.MessageDigest;import java.security.cert.CertificateException;import java.security.cert.X509Certificate;&#x2F;** * Class used to add the server&#39;s certificate to the KeyStore * with your trusted certificates. *&#x2F;public class InstallCert &#123;    public static void main(String[] args) throws Exception &#123;        String host;        int port;        char[] passphrase;        if ((args.length &#x3D;&#x3D; 1) || (args.length &#x3D;&#x3D; 2)) &#123;            String[] c &#x3D; args[0].split(&quot;:&quot;);            host &#x3D; c[0];            port &#x3D; (c.length &#x3D;&#x3D; 1) ? 443 : Integer.parseInt(c[1]);            String p &#x3D; (args.length &#x3D;&#x3D; 1) ? &quot;changeit&quot; : args[1];            passphrase &#x3D; p.toCharArray();        &#125; else &#123;            System.out.println(&quot;Usage: java InstallCert &lt;host&gt;[:port] [passphrase]&quot;);            return;        &#125;        File file &#x3D; new File(&quot;jssecacerts&quot;);        if (file.isFile() &#x3D;&#x3D; false) &#123;            char SEP &#x3D; File.separatorChar;            File dir &#x3D; new File(System.getProperty(&quot;java.home&quot;) + SEP                    + &quot;lib&quot; + SEP + &quot;security&quot;);            file &#x3D; new File(dir, &quot;jssecacerts&quot;);            if (file.isFile() &#x3D;&#x3D; false) &#123;                file &#x3D; new File(dir, &quot;cacerts&quot;);            &#125;        &#125;        System.out.println(&quot;Loading KeyStore &quot; + file + &quot;...&quot;);        InputStream in &#x3D; new FileInputStream(file);        KeyStore ks &#x3D; KeyStore.getInstance(KeyStore.getDefaultType());        ks.load(in, passphrase);        in.close();        SSLContext context &#x3D; SSLContext.getInstance(&quot;TLS&quot;);        TrustManagerFactory tmf &#x3D;                TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());        tmf.init(ks);        X509TrustManager defaultTrustManager &#x3D; (X509TrustManager) tmf.getTrustManagers()[0];        SavingTrustManager tm &#x3D; new SavingTrustManager(defaultTrustManager);        context.init(null, new TrustManager[]&#123;tm&#125;, null);        SSLSocketFactory factory &#x3D; context.getSocketFactory();        System.out.println(&quot;Opening connection to &quot; + host + &quot;:&quot; + port + &quot;...&quot;);        SSLSocket socket &#x3D; (SSLSocket) factory.createSocket(host, port);        socket.setSoTimeout(10000);        try &#123;            System.out.println(&quot;Starting SSL handshake...&quot;);            socket.startHandshake();            socket.close();            System.out.println();            System.out.println(&quot;No errors, certificate is already trusted&quot;);        &#125; catch (SSLException e) &#123;            System.out.println();            e.printStackTrace(System.out);        &#125;        X509Certificate[] chain &#x3D; tm.chain;        if (chain &#x3D;&#x3D; null) &#123;            System.out.println(&quot;Could not obtain server certificate chain&quot;);            return;        &#125;        BufferedReader reader &#x3D;                new BufferedReader(new InputStreamReader(System.in));        System.out.println();        System.out.println(&quot;Server sent &quot; + chain.length + &quot; certificate(s):&quot;);        System.out.println();        MessageDigest sha1 &#x3D; MessageDigest.getInstance(&quot;SHA1&quot;);        MessageDigest md5 &#x3D; MessageDigest.getInstance(&quot;MD5&quot;);        for (int i &#x3D; 0; i &lt; chain.length; i++) &#123;            X509Certificate cert &#x3D; chain[i];            System.out.println                    (&quot; &quot; + (i + 1) + &quot; Subject &quot; + cert.getSubjectDN());            System.out.println(&quot;   Issuer  &quot; + cert.getIssuerDN());            sha1.update(cert.getEncoded());            System.out.println(&quot;   sha1    &quot; + toHexString(sha1.digest()));            md5.update(cert.getEncoded());            System.out.println(&quot;   md5     &quot; + toHexString(md5.digest()));            System.out.println();        &#125;        System.out.println(&quot;Enter certificate to add to trusted keystore or &#39;q&#39; to quit: [1]&quot;);        String line &#x3D; reader.readLine().trim();        int k;        try &#123;            k &#x3D; (line.length() &#x3D;&#x3D; 0) ? 0 : Integer.parseInt(line) - 1;        &#125; catch (NumberFormatException e) &#123;            System.out.println(&quot;KeyStore not changed&quot;);            return;        &#125;        X509Certificate cert &#x3D; chain[k];        String alias &#x3D; host + &quot;-&quot; + (k + 1);        ks.setCertificateEntry(alias, cert);        OutputStream out &#x3D; new FileOutputStream(&quot;jssecacerts&quot;);        ks.store(out, passphrase);        out.close();        System.out.println();        System.out.println(cert);        System.out.println();        System.out.println                (&quot;Added certificate to keystore &#39;jssecacerts&#39; using alias &#39;&quot;                        + alias + &quot;&#39;&quot;);    &#125;    private static final char[] HEXDIGITS &#x3D; &quot;0123456789abcdef&quot;.toCharArray();    private static String toHexString(byte[] bytes) &#123;        StringBuilder sb &#x3D; new StringBuilder(bytes.length * 3);        for (int b : bytes) &#123;            b &amp;&#x3D; 0xff;            sb.append(HEXDIGITS[b &gt;&gt; 4]);            sb.append(HEXDIGITS[b &amp; 15]);            sb.append(&#39; &#39;);        &#125;        return sb.toString();    &#125;    private static class SavingTrustManager implements X509TrustManager &#123;        private final X509TrustManager tm;        private X509Certificate[] chain;        SavingTrustManager(X509TrustManager tm) &#123;            this.tm &#x3D; tm;        &#125;        public X509Certificate[] getAcceptedIssuers() &#123;\t   \t    &#x2F;** \t     * This change has been done due to the following resolution advised for Java 1.7+\t\thttp:&#x2F;&#x2F;infposs.blogspot.kr&#x2F;2013&#x2F;06&#x2F;installcert-and-java-7.html       \t     **&#x2F; \t    \t    return new X509Certificate[0];\t            &#x2F;&#x2F;throw new UnsupportedOperationException();        &#125;        public void checkClientTrusted(X509Certificate[] chain, String authType)                throws CertificateException &#123;            throw new UnsupportedOperationException();        &#125;        public void checkServerTrusted(X509Certificate[] chain, String authType)                throws CertificateException &#123;            this.chain &#x3D; chain;            tm.checkServerTrusted(chain, authType);        &#125;    &#125;&#125;\n\n","categories":["编程笔记"],"tags":["SpringBoot"]},{"title":"讨论社区07  -  版本控制","url":"/2019/06/26/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA07%20-%20%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/","content":"\n认识Git\nGit简介\nGit的安装与配置\n\n\nGit常用命令\n将代码提交至本地仓库\n将代码上传至远程仓库\n\n\nIDEA集成Git\n在IDEA中配置并使用Git\n\n\n\n# 账号配置git config --listgit config --global user.name &quot;wangxu&quot;git config --global user.email &quot;xxx@gmail.com&quot;# 本地仓库git initgit status -sgit add *git commit -m &#x27;...&#x27;# 生成秘钥ssh-keygen -t rsa -C &quot;xxx@gmail.com&quot;# 推送已有项目git remote add originhttps://github.com/4Details/Test.gitgit push -u origin master# 克隆已有仓库git clone https://github.com/4Details/Test.git\n\n","categories":["讨论社区项目"],"tags":["Spring","Git"]},{"title":"讨论社区06  -  项目调试技巧","url":"/2019/06/23/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA06%20-%20%E9%A1%B9%E7%9B%AE%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/","content":"\n响应状态码的含义\n服务端断点调试技巧\n客户端断点调试技巧\n设置日志级别，并将日志输出到不同的终端\n\n","categories":["讨论社区项目","编程笔记"],"tags":["Bug调试"]},{"title":"讨论社区05  -  讨论社区首页实现","url":"/2019/06/21/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA05%20-%20%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA%E9%A6%96%E9%A1%B5%E5%AE%9E%E7%8E%B0/","content":"\n开发流程\n1次请求的执行过程\n\n\n分步实现\n开发社区首页，显示前10个帖子\n开发分页组件，分页显示所有的帖子\n\n\n","categories":["讨论社区项目"],"tags":["Spring"]},{"title":"讨论社区04  -  Mybatis  入门","url":"/2019/06/18/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA04%20-%20MyBatis-%E5%85%A5%E9%97%A8/","content":"安装数据库\n安装MySQL Server\n安装MySQL Workbench\n\nMyBatis\n核心组件\nSqlSessionFactory：用于创建SqlSession的工厂类。\nSqlSession：MyBatis的核心组件，用于向数据库执行SQL。\n主配置文件：XML配置文件，可以对MyBatis的底层行为做出详细的配置。\nMapper接口：就是DAO接口，在MyBatis中习惯性的称之为Mapper。\nMapper映射器：用于编写SQL，并将SQL和实体类映射的组件，采用XML、注解均可实现。\n\n\n示例\n使用MyBatis对用户表进行CRUD操作。\n\n\n在application.properties中配置数据库、Mybatis相关。\n\n","categories":["讨论社区项目"],"tags":["Spring","Mybatis"]},{"title":"讨论社区03  -  Spring MVC 入门","url":"/2019/06/16/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA03%20-%20Spring-MVC-%E5%85%A5%E9%97%A8/","content":"HTTP\nHyperText Transfer Protocol\n用于传输HTML等内容的应用层协议\n规定了浏览器和服务器之间如何通信，以及通信时的数据格式。\n学习网站：https://developer.mozilla.org/zh-CN\n\n浏览器服务器通信步骤：\n\n打开一个TCP连接\n发生一个HTTP报文 \n读取服务器返回的报文信息\n关闭连接或为后续请求重用连接\n\n\n按下F12进入调试，在Network下看请求响应（Header和Response）\n\nSpring MVC\n三层架构\n表现层(mvc)、业务层、数据访问层\n\n\nMVC(设计模式)\nModel：模型层\nView：视图层\nController：控制层\n核心组件\n前端控制器：DispatcherServlet\n\n\n\n浏览器访问服务器，首先访问的时Controller控制层，Controller调用业务层处理，处理完后将得到的数据封装到Model,传给视图层。\n \nThymeleaf\n模板引擎\n\n生成动态的HTML。\n\n\nThymeleaf\n\n倡导自然模板，即以HTML文件为模板。\n\n\n常用语法\n\n标准表达式、判断与循环、模板的布局。\n\n&lt;!--声明thymeleaf模板--&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot; xmlns:sec=&quot;http://www.thymeleaf.org/extras/spring-security&quot;&gt;    &lt;!--静态资源也需要做路径处理，带url的不需要处理--&gt;&lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;/css/global.css&#125;&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;/css/discuss-detail.css&#125;&quot; /&gt;\n\n&lt;!--标签是否显示demo--&gt;&lt;!--usernameMsg为Controller的model传过来的值--&gt;&lt;div class=&quot;col-sm-10&quot;&gt;\t\t&lt;input type=&quot;text&quot;\t\t\tth:class=&quot;|form-control $&#123;usernameMsg!=null?&#x27;is-invalid&#x27;:&#x27;&#x27;&#125;|&quot;\t\t\tth:value=&quot;$&#123;user!=null?user.username:&#x27;&#x27;&#125;&quot;\t\t\tid=&quot;username&quot; name=&quot;username&quot; placeholder=&quot;请输入您的账号!&quot; required&gt;\t\t\t&lt;div class=&quot;invalid-feedback&quot; th:text=&quot;$&#123;usernameMsg&#125;&quot;&gt;\t\t\t\t该账号已存在!\t\t\t&lt;/div&gt;&lt;/div&gt;\n\n\n\n变量用  $&#123;变量名&#125;， href 中使用 @&#123;url地址&#125;，常量与变量拼接 |常量+&#123;变量名&#125;|\n&lt;span th:utext=&quot;$&#123;post.title&#125;&quot;&gt;test title&lt;/span&gt;&lt;a class=&quot;nav-link&quot; th:href=&quot;@&#123;/index&#125;&quot;&gt;首页&lt;/a&gt;&lt;form method=&quot;post&quot; th:action=&quot;@&#123;|/comment/add/$&#123;post.id&#125;|&#125;&quot;&gt;\n\n\n\n代码部分底层：\n@RequestMapping(&quot;/http&quot;)public void http(HttpServletRequest request, HttpServletResponse response) &#123;    // 获取请求数据    System.out.println(request.getMethod());    System.out.println(request.getServletPath());    Enumeration&lt;String&gt; enumeration = request.getHeaderNames();    while (enumeration.hasMoreElements()) &#123;        String name = enumeration.nextElement();        String value = request.getHeader(name);        System.out.println(name + &quot;: &quot; + value);    &#125;    System.out.println(request.getParameter(&quot;code&quot;));    // 返回响应数据    response.setContentType(&quot;text/html;charset=utf-8&quot;);    try (        PrintWriter writer = response.getWriter();    ) &#123;        writer.write(&quot;&lt;h1&gt;xx网&lt;/h1&gt;&quot;);    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125;&#125;\n\n从路径中得到变量GET（两种方法）：\n@RequestMapping(path = &quot;/students&quot;, method = RequestMethod.GET)@ResponseBodypublic String getStudents(    @RequestParam(name = &quot;current&quot;, required = false, defaultValue = &quot;1&quot;) int current,    @RequestParam(name = &quot;limit&quot;, required = false, defaultValue = &quot;10&quot;) int limit) &#123;    System.out.println(current);    System.out.println(limit);    return &quot;some students&quot;;&#125;@RequestMapping(path = &quot;/student/&#123;id&#125;&quot;, method = RequestMethod.GET)@ResponseBodypublic String getStudent(@PathVariable(&quot;id&quot;) int id) &#123;    System.out.println(id);    return &quot;a student&quot;;&#125;\n\nPOST请求:\n@RequestMapping(path = &quot;/student&quot;, method = RequestMethod.POST)@ResponseBodypublic String saveStudent(String name, int age) &#123;    System.out.println(name);    System.out.println(age);    return &quot;success&quot;;&#125;\n\n响应HTML数据(使用ModelAndView或Model):\n@RequestMapping(path = &quot;/teacher&quot;, method = RequestMethod.GET)public ModelAndView getTeacher() &#123;    ModelAndView mav = new ModelAndView();    mav.addObject(&quot;name&quot;, &quot;张三&quot;);    mav.addObject(&quot;age&quot;, 30);    mav.setViewName(&quot;/demo/view&quot;);    return mav;&#125;@RequestMapping(path = &quot;/school&quot;, method = RequestMethod.GET)public String getSchool(Model model) &#123;    model.addAttribute(&quot;name&quot;, &quot;北京大学&quot;);    model.addAttribute(&quot;age&quot;, 80);    return &quot;/demo/view&quot;;&#125;\n\n 响应JSON数据(异步请求)：Java对象 -&gt; JSON字符串 -&gt; JS对象,使用@ResponseBody 注解\n@RequestMapping(path = &quot;/emp&quot;, method = RequestMethod.GET)@ResponseBodypublic Map&lt;String, Object&gt; getEmp() &#123;    Map&lt;String, Object&gt; emp = new HashMap&lt;&gt;();    emp.put(&quot;name&quot;, &quot;张三&quot;);    emp.put(&quot;age&quot;, 23);    return emp;&#125;//转换为json字符串  &#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:&quot;23&quot;&#125;//也可以返回List&lt;Map&lt;String, Object&gt;&gt;，list集合。\n\n","categories":["讨论社区项目"],"tags":["SpringMVC"]},{"title":"讨论社区02 - Spring 入门","url":"/2019/06/14/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA02%20-%20Spring-%E5%85%A5%E9%97%A8/","content":"Spring全家桶\nSpring Framework \nSpring Boot\nSpring Cloud (微服务,大项目拆分成若干子项目)\nSpring Cloud Data Flow(数据集成)\n官网: https://spring.io\n\nSpring Framework\nSpring Core\nIoC、AOP  (管理对象的思想,spring管理的对象叫做Bean.)\nSpring Data Access\nTransactions(事务)、Spring MyBatis\n\n\nWeb Servlet\nSpring MVC\n\n\nIntegration(集成)\nEmail、Scheduling(定时任务)、AMQP(消息队列)、Security(安全控制)\n\n\n\nSpring IoC\nInversion of Control\n控制反转，是一种面向对象编程的设计思想。\n\n\nDependency Injection\n依赖注入，是IoC思想的实现方式。\nIoC Container\nIoC容器，是实现依赖注入的关键，本质上是一个工厂。\n容器管理Bean的前提:提供Bean的类型,通过配置文件配置Bean之间的关系.\n降低Bean之间的耦合度\n\n代码部分\n主动获取:\n\n@SpringBootApplicationpublic class TalkingApplication &#123;\tpublic static void main(String[] args) &#123;\t\tSpringApplication.run(CommunityApplication.class, args);\t&#125;&#125;配置类,启动时自动扫描,扫描配置类所在的包以及子包下的Bean.@Component @Repository @Service @Controller\n\n测试代码要以其为配置类,需加上注解:\n@ContextConfiguration(classes = TalkingApplication.class)\n\n想要使用spring容器需要实现接口,ApplicationContextAware,实现接口中set方法.传入参数applicationContext(spring容器),他是一个接口,继承自BeanFactory.\n获取Bean:applicationContext.getBean(test.class);\npublic class TalkingApplicationTests implements ApplicationContextAware &#123;\tprivate ApplicationContext applicationContext;\t@Override\tpublic void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;\t\tthis.applicationContext = applicationContext;\t&#125;&#125;\n\n给Bean自定义名字:@Component(“名字”)\n初始化方法@PostConstruct,在构造器之后调用.销毁对象之前调用,@PreDestroy.\n@Scope()指定单例多例\n@Configuration配置类,用以装载使用第三方类.\n\n自动注入:\n@Autowired\n\n\n\n","categories":["讨论社区项目"],"tags":["Spring"]},{"title":"讨论社区01 - 搭建开发环境","url":"/2019/06/12/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA01%20-%20%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","content":"Apache Maven\n可以帮助我们构建项目、管理项目中的jar包\nMaven仓库：存放构件的位置\n构件:创建项目时依赖的资源jar包.\n本地仓库：默认是 ~/.m2/repository\n远程仓库：中央仓库(官网)、镜像仓库(第三方网站)、私服仓库(公司自己搭建)\n\n\n示例：安装、配置、常用命令\n下载 : http://maven.apache.org\n解压,配置conf文件夹下,settings.xml.修改为阿里云镜像仓库.标签下修改网址.\n\n\n\n&lt;mirror&gt;    &lt;id&gt;alimaven&lt;/id&gt;    &lt;name&gt;aliyun maven&lt;/name&gt;    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;        &lt;/mirror&gt;\n\n\n将bin文件路径配置到环境变量（添加到环境变量之后可以在 cmd 使用 mvn 命令）\n常用命令: 创建,编译(生成target文件夹),清除,测试.\n\nmvn cleanmvn buildmvn install\n\n在实际开发过程中可以将maven配置到其他路径。\n\nIntelliJ IDEA\n目前最流行的Java集成开发工具\n示例：安装、配置、创建项目\n下载: http://www.jetbrains.com/idea\nEclipse创建的项目需要导入(import),IDEA的直接open就可以.\nSettings的Editor下设置maven及其配置文件.\n创建maven模板项目.\n重新编译 Ctrl+F9\n\n\n\nSpring Initialize\n把包进行整合按功能划分归类.\n\n创建 Spring Boot 项目的引导工具\n\nhttps://start.spring.io\n\n\n\n\n\n示例：创建“讨论社区”项目\n\nspringboot内嵌了Tomcat.\n\n\n\nSpring Boot 入门示例\nSpring Boot 核心作用\n起步依赖、自动配置、端点监控\n\n起步依赖 ：创建项目之后直接通过配置pom.xml ，在其中添加 starter 需要的 jar 包则可以启动一个hello demo。\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\txsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\t&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\t&lt;parent&gt;\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\t\t&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\t\t&lt;version&gt;2.2.0.RELEASE&lt;/version&gt;\t\t&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;\t&lt;/parent&gt;\t&lt;groupId&gt;com.wx&lt;/groupId&gt;\t&lt;artifactId&gt;talking&lt;/artifactId&gt;\t&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\t&lt;name&gt;talking&lt;/name&gt;\t&lt;description&gt;a community demo&lt;/description&gt;\t&lt;properties&gt;\t\t&lt;java.version&gt;1.8&lt;/java.version&gt;\t&lt;/properties&gt;\t&lt;dependencies&gt;        &lt;!--springboot Thymeleaf模板支持--&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\t\t&lt;/dependency&gt;        &lt;!--springboot web模块支持--&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\t\t&lt;/dependency&gt;\t\t&lt;!--mysql 数据库连接--&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;mysql&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\t\t\t&lt;version&gt;8.0.18&lt;/version&gt;\t\t&lt;/dependency&gt;\t\t&lt;!--mybatis jar--&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;\t\t\t&lt;version&gt;2.1.0&lt;/version&gt;\t\t&lt;/dependency&gt;\t&lt;/dependencies&gt;\t&lt;build&gt;\t\t&lt;plugins&gt;\t\t\t&lt;plugin&gt;\t\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\t\t\t\t&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\t\t\t&lt;/plugin&gt;\t\t&lt;/plugins&gt;\t&lt;/build&gt;&lt;/project&gt;\n\nspring-boot-starter-web包自动帮我们引入了web模块开发需要的相关jar包，\nmybatis-spring-boot-starter帮我们引入了dao开发相关的jar包。\nspring-boot-starter-xxx是官方提供的starter，xxx-spring-boot-starter是第三方提供的starter。\n自动配置：利用 @Configuration 等注解的方式改造传统的基于 xml 的 bean 的配置\n&lt;!--传统基于 xml 方式配置 bean--&gt;&lt;beans&gt;      &lt;bean id = &quot;car&quot; class=&quot;com.wx.talking.entity.Car&quot;&gt;          &lt;property name=&quot;wheel&quot; ref = &quot;wheel&quot;&gt;&lt;/property&gt;      &lt;/bean&gt;      &lt;bean id = &quot;wheel&quot; class=&quot;com.itpsc.Wheel&quot;&gt;&lt;/bean&gt;  &lt;/beans&gt;\n\n// 使用注解的方式在java中配置@Configuration  public class Conf &#123;      @Bean      public Car car() &#123;          Car car = new Car();          car.setWheel(wheel());          return car;      &#125;      @Bean       public Wheel wheel() &#123;          return new Wheel();      &#125;  &#125;\n\n上面的代码中，MybatisAutoConfiguration这个类，自动帮我们生成了SqlSessionFactory这些Mybatis的重要实例并交给spring容器管理，从而完成bean的自动注册。\n在Spring中还有很多这样的注解：@Component @Service @Controller …\n端点监控：（@待续）\n\n示例:一个简单的处理客户端请求案例\n\napplication.properties文件进行配置\n# ServerPropertiesserver.port&#x3D;8080         服务器端口server.servlet.context-path&#x3D;&#x2F;community  项目访问路径\n\n\n\n\n","categories":["讨论社区项目","编程笔记"],"tags":["Apache Maven","Spring","SpringBoot"]},{"title":"Python 爬虫 01-通用爬虫基本流程","url":"/2018/10/18/Python-%E7%88%AC%E8%99%AB-01-%E9%80%9A%E7%94%A8%E7%88%AC%E8%99%AB%E7%BB%93%E6%9E%84/","content":"爬虫是什么爬虫：一段自动抓取互联网信息的程序，从互联网上抓取对于我们有价值的信息。\n通用爬虫基本流程用一个通用的网络爬虫结构来说明网络爬虫的基本工作流程：\n\n网络爬虫的基本工作流程如下：\n(1).   首先抓取一部分待取的种子URL；\n(2).   将这些URL放入待取的URL队列；\n(3).   从待取的URL队列中读取待抓取网页的URL，解析DNS并且得到主机的IP，将URL对应的网页内容下载下来，存储已下载网页库中，并将这些URL放入已抓取URL队列；\n(4).   分析已抓取URL队列中的URL，从已下载的网页数据分析出其他URL冰河已抓取的URL进行对比去重，最后将去重后的URL放入待抓取队列，从而进入下一个循环。\n","categories":["编程笔记"],"tags":["爬虫"]}]