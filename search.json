[{"title":"FATE 1.2 实践02-FATE集群部署","url":"/2020/08/27/FATE-1-2-%E5%AE%9E%E8%B7%B502%EF%BC%9AFATE%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/","content":"配置FATE环境第1步中虚拟机创建完成后的信息如下\n\n\n\n主机名\nhost155\nguest156\nguest157\n\n\n\nIP\n192.168.119.155\n192.168.119.156\n192.168.119.157\n\n\n\n\n\n\n\n\n下面的步骤均是依据官方文档操作 \n基础环境配置注意：不特殊说明，下面配置需要在所有机器上操作！！\n由于在创建虚拟机过程中已经更改过每台主机名、创建用户app，所以文档中hostname配置可跳过。\nroot权限下创建文件夹  /data/projects 归属 app用户\n&#x2F;&#x2F;切换root用户，-p创建文件夹，给app用户赋予权限su rootmkdir -p &#x2F;data&#x2F;projectschown -R app &#x2F;data&#x2F;projects\n\n\n\n关闭selinux确认是否已安装selinux\ncentos系统执行：rpm -qa | grep selinux\nubuntu系统执行：apt list –installed | grep selinux\n如果已安装了selinux就执行：setenforce 0\n\n修改Linux最大打开文件数切换root用户，在limits.conf文件最后添加5、6行代码，保存退出\nsu rootvim &#x2F;etc&#x2F;security&#x2F;limits.conf* soft nofile 65536* hard nofile 65536\n\n\n\n\n添加主机映射vim &#x2F;etc&#x2F;hosts\n\n\n\n\n关闭虚拟机防火墙在实际生产环境中需要配置防火墙端口规则！虚拟机环境下采用关闭防火墙的方式。\n如果是Centos系统：\nsystemctl disable firewalld.servicesystemctl stop firewalld.servicesystemctl status firewalld.service\n\n本例的环境是Centos系统\n\n如果是Ubuntu系统：\nufw disableufw status\n\n给用户赋予sudo权限root用户下对app用户赋予sudo权限\nvim &#x2F;etc&#x2F;sudoers.d&#x2F;appapp ALL&#x3D;(ALL) ALLapp ALL&#x3D;(ALL) NOPASSWD: ALLDefaults !env_reset\n\n\n\n配置ssh远程登录a. 切换app用户，生成rsa_id，具体根据下面代码\n\nb.合并id_rsa_pub文件\n步骤如下：三台机器分别将id_rsa.pub 写入authorized_keys文件中并且赋予权限chomd 600\n\n155通过scp将authorized_keys文件发送到156上，并将156的id_rsa.pub文件写入，然后将生成的新文件发送至157上，并且写入157生成的id_rsa.pub文件，将最终生成的authorized_keys文件发送给155和156，此时通过ssh即可登录（在发送文件过程中建立连接需要输入密码）\n155-&gt;156\n\n156写入， -&gt;157\n\n157写入，-&gt;155  -&gt;156\n\n上述完成之后即可通过  ssh usernane@ip访问某台虚拟机\n需要注意的是，访问自身需要重新建立一个连接。\n建议配置以上步骤之后拍摄虚拟机快照，便于后期恢复重新部署。\nFATE部署完成基础环境配置之后，接下来就需要部署FATE的运行环境，本例使用的是Installation文档。\n下面的操作只需在其中一台机器操作即可，本例选用的是host 155。\n下载压缩包可以使用wget下载，也可以直接通过链接下载。\ncd &#x2F;data&#x2F;projectswget https:&#x2F;&#x2F;webank-ai-1251170195.cos.ap-guangzhou.myqcloud.com&#x2F;FATE_install_v1.2.0.tar.gztar -xf FATE_install_v1.2.0.tar.gz\n\n\n\n\n修改configuration文件可以使用vim，也可以直接使用编辑器打开并修改。\ncd &#x2F;data&#x2F;projects&#x2F;FATE&#x2F;cluster-deploy&#x2F;scriptvi multinode_cluster_configuration.sh\n\n\n\n\n\n建议在部署之前拍摄快照，为防止在部署过程中因某些配置出错造成部署失败。\n部署本例中选择在各机器上部署所有组件。\ncd FATE&#x2F;cluster-deploy&#x2F;scripts# 部署所有组件bash deploy_cluster_multinode.sh binary all # 只部署部分组件(可选：jdk python mysql redis fate_flow federatedml fateboard proxy federation roll meta-service egg)：bash deploy_cluster_multinode.sh binary fate_flow\n\n\n\n-———————————————————————————————————————-\n———————————————–漫长地等待过程——————————————————–\n-———————————————————————————————————————-\n（部署时间暂未统计，时间需要2-4个小时，记录下了部署过程中终端产生的日志）\n此处为语雀文档，点击链接查看：https://www.yuque.com/u190689/qoiq3w/seeq38\n配置检查请务必详细对照检查！！！\n到各个目标服务器上进行检查对应模块的配置是否准确，每个模块的对应配置文件所在路径可在此配置文件下查看，参考：https://github.com/FederatedAI/FATE/blob/master/cluster-deploy/doc/configuration.md\n至此，FATE v1.2的安装部署全部结束，接下来测试环境。\n建议部署成功之后拍摄快照，便于将来找到还原点。\n","categories":["联邦学习"],"tags":["FATE","FL"]},{"title":"FATE 1.2 实践01-虚拟机安装","url":"/2020/08/27/FATE-1-2-%E5%AE%9E%E8%B7%B501%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/","content":"创建虚拟机新建虚拟机使用VMWare WorkStation创建虚拟机（单机版只需要一台机器，集群版可以使用多台机器，下面示例中创建了3台虚拟机，配置均为 300G，16GB，4核处理器，系统镜像为 CentOS-7-x86_64-DVD-1810版本）\n\n\n\n                         \n\n\n                                       \n配置操作系统启动虚拟机，加载并配置操作系统\n       \n此处选择默认语言为【简体中文】，可以直接在编辑框输入快速查找。下一步则需要配置系统的软件、磁盘分区、网络等信息。\n\n这里需要注意的是详细配置图中标注的1，2，3。本例中详细的配置如下：\n\n本例中选择的是GNOME桌面版的软件，已选环境附加选项可根据实际需要选择，选择桌面版的可视化环境有利于后续工作的进行。下一步选择安装目标位置中提前配置分区信息尤为重要！！！\n\n\n\n官方文档中建议全部磁盘挂载到新建的用户app下，但是本例中将大部分磁盘挂载到root下，经实践是有效的，在如上配置之后点击【完成】即可完成磁盘及分区的配置。\n下一步需要提前完成系统网络信息的配置，如主机名、ip、子网掩码、DNS、路由信息等。\n\n点击【配置】可进入ip、DNS等信息的配置。\n\n在上图的配置中需要注意的是，选择手动配置IPv4的信息，地址、子网掩码和网关需要配置正确，本例中DNS服务器默认为网关信息。网络信息配置完成之后可以【开启】以太网的连接，详细的信息可以参考下图\n\n1，2，3的所有信息完成配置之后点击【开始安装】则进入安装界面，此时可以配置系统root用户的密码以及新建用户。本例中遵循官方文档创建用户 app，在“高级用户配置”中，编辑app分属apps组，用户id为6000。\n\n\n等待安装完成，【重启】即可进入桌面版的centos7 操作系统。\n\n初始设置需要接受许可证协议，【完成配置】即可登录输入密码，进入系统。\n\n提示：在实际操作中无需一步步按照上述步骤创建三台或多台虚拟机，在创建完成一台虚拟机之后可以通过“克隆”操作得到已安装完成的虚拟机镜像，这样可以在一定程度上节约创建虚拟机的时间，需要注意的是，在克隆完成启动之前需要重新生成机器的mac地址，否则会造成mac冲突。因为原始虚拟机使用的是静态地址，所以在开启之后需要重新对副本虚拟机分配静态IP。\n克隆方法主要是： 点击 虚拟机-管理-克隆  使用克隆虚拟机向导\n\n\n\n重命名和选择虚拟机所在路径之后点击【完成】即可。\n\n\n\n打开虚拟机之后可以使用  ifconfig查看网络配置信息\n\n需要更改的信息有 主机名、ip\n\n配置IP信息主要路径在 /etc/sysconfig/network-script，修改 sysconf-ens33 （ens33指的是网卡名称）\n文件中可以修改的有是否静态ip，PROTO一项改为 static  配置ip地址，子网掩码，网关，dns\n\n进入编辑页面\n\n半角状态输入’i’可修改内容，修改完成如下，Esc退出编辑，”:wq”可以保存修改并退出vim编辑页面\n\n重启之后使用ifconfig查看，ip已经改变。\n克隆得到另外两台虚拟机，按上述步骤修改IP信息之后即完成了本例中的创建虚拟机步骤。\n\n","categories":["联邦学习"],"tags":["FATE","FL"]},{"title":"hexo快速开始","url":"/2019/08/19/hexo%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":["随笔"],"tags":["随笔"]},{"title":"找不到请求的.Net Framework Data Provider.可能没有安装.  错误","url":"/2019/07/27/%E6%89%BE%E4%B8%8D%E5%88%B0%E8%AF%B7%E6%B1%82%E7%9A%84-Net-Framework-Data-Provider-%E5%8F%AF%E8%83%BD%E6%B2%A1%E6%9C%89%E5%AE%89%E8%A3%85-%E9%94%99%E8%AF%AF/","content":"问题：这几天在装.NET 的开发环境，在装好VS2013和Oracle 11g之后，做了一个测试项目，运行调试没问题但是涉及到数据库相关操作，如新建数据集、连接数据库等在调试的时候则会出现如下错误：\n\n目前百度之后现存的解决方案：\noracle odp.net 32位/64位版本的问题解决方案链接；当然如果觉得这篇写的不怎么清楚，还可以点击 这里*（我碰到的就是这个问题，但是据博主提供的方法没有解决问题）*\n\nMicrosoft SQL Server Compact 4.0没有安装 这个问题是比较好解决的，只用安装Microsoft SQL Server Compact4.0即可，具体可以点击这里\n\n还有修改machine.config配置文件的方法，大家也可以尝试点击这里\n当然如果你的数据库使用的Oracle，节点配置的时候需要根据实际情况做出调整。具体文件配置路径：C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\Config下面的machine.config用记事本打开，查看下列节点是否存在oracle的相关配置\n&lt;system.data&gt;    &lt;DbProviderFactories&gt;      &lt;add name&#x3D;&quot;ODP.NET, Managed Driver&quot; invariant&#x3D;&quot;Oracle.ManagedDataAccess.Client&quot; description&#x3D;&quot;Oracle Data Provider for .NET, Managed Driver&quot; type&#x3D;&quot;Oracle.ManagedDataAccess.Client.OracleClientFactory, Oracle.ManagedDataAccess, Version&#x3D;4.121.2.0, Culture&#x3D;neutral, PublicKeyToken&#x3D;89b483f429c47342&quot; &#x2F;&gt;      &lt;add name&#x3D;&quot;Microsoft SQL Server Compact Data Provider 4.0&quot; invariant&#x3D;&quot;System.Data.SqlServerCe.4.0&quot; description&#x3D;&quot;.NET Framework Data Provider for Microsoft SQL Server Compact&quot; type&#x3D;&quot;System.Data.SqlServerCe.SqlCeProviderFactory, System.Data.SqlServerCe, Version&#x3D;4.0.0.0, Culture&#x3D;neutral, PublicKeyToken&#x3D;89845dcd8080cc91&quot; &#x2F;&gt;    &lt;&#x2F;DbProviderFactories&gt;  &lt;&#x2F;system.data&gt;\n\n新添加的应该是这一块：\n&lt;add name&#x3D;&quot;ODP.NET, Managed Driver&quot; invariant&#x3D;&quot;Oracle.ManagedDataAccess.Client&quot; description&#x3D;&quot;Oracle Data Provider for .NET, Managed Driver&quot; type&#x3D;&quot;Oracle.ManagedDataAccess.Client.OracleClientFactory, Oracle.ManagedDataAccess, Version&#x3D;4.121.2.0, Culture&#x3D;neutral, PublicKeyToken&#x3D;89b483f429c47342&quot; &#x2F;&gt;\n\n个人解决方案前面说过了，我尝试了上述的一些办法之后仍然没有解决问题，熬不住了我就去csdn的论坛发了帖，等了半个小时没人回复（可能是积分太少吧），无奈我就自己继续鼓捣了。想起来自己有一个 ODAC 12c的安装包，就直接点击安装了，安装完成之后重启VS，继续新建项目，配置数据库，调试之后竟然没有再继续报错，也就是说这个问题被我糊里糊涂解决了，哈哈哈~\n写一篇记录一下，给各位一个借鉴也给自己一个教训。下面提供ODAC 12c的下载地址\n官方下载地址：x64下载、x86下载\n如果没有oracle账号又或是账号无法登陆，可以通过这个链接下载， 密码：amvz\n\n\n","categories":["编程笔记"],"tags":[".net"]},{"title":"JavaSpring项目使用Mail包发送邮件报错无法连接服务器Could not connect to SMTP host","url":"/2019/06/28/JavaSpring%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8Mail%E5%8C%85%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E6%8A%A5%E9%94%99%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8Could-not-connect-to-SMTP-host/","content":"问题在使用SpringBoot的mail依赖库连接sina邮箱发送邮件时遇到如下问题：\norg.springframework.mail.MailSendException: Mail server connection failed; nested exception is javax.mail.MessagingException: Could not connect to SMTP host: smtp.sina.com, port: 465;  nested exception is:\tjavax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target. Failed messages: javax.mail.MessagingException: Could not connect to SMTP host: smtp.sina.com, port: 465;  nested exception is:\tjavax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target; message exception details (1) are:Failed message 1:javax.mail.MessagingException: Could not connect to SMTP host: smtp.sina.com, port: 465;  nested exception is:\tjavax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target\tat com.sun.mail.smtp.SMTPTransport.openServer(SMTPTransport.java:2211)\tat com.sun.mail.smtp.SMTPTransport.protocolConnect(SMTPTransport.java:722)\tat javax.mail.Service.connect(Service.java:342)\tat org.springframework.mail.javamail.JavaMailSenderImpl.connectTransport(JavaMailSenderImpl.java:518)\tat org.springframework.mail.javamail.JavaMailSenderImpl.doSend(JavaMailSenderImpl.java:437)\tat org.springframework.mail.javamail.JavaMailSenderImpl.send(JavaMailSenderImpl.java:361)\tat org.springframework.mail.javamail.JavaMailSenderImpl.send(JavaMailSenderImpl.java:356)\tat com.wx.talking.util.MailClient.sendMail(MailClient.java:36)\tat com.wx.talking.MailTests.testTextMail(MailTests.java:24)\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\tat java.lang.reflect.Method.invoke(Method.java:497)\tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\tat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\tat org.springframework.test.context.junit4.statements.RunBeforeTestExecutionCallbacks.evaluate(RunBeforeTestExecutionCallbacks.java:74)\tat org.springframework.test.context.junit4.statements.RunAfterTestExecutionCallbacks.evaluate(RunAfterTestExecutionCallbacks.java:84)\tat org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:75)\tat org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:86)\tat org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:84)\tat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)\tat org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:251)\tat org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:97)\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\tat org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61)\tat org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70)\tat org.junit.runners.ParentRunner.run(ParentRunner.java:363)\tat org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:190)\tat org.junit.runner.JUnitCore.run(JUnitCore.java:137)\tat com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)\tat com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:33)\tat com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:230)\tat com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:58)Caused by: javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target\tat sun.security.ssl.Alerts.getSSLException(Alerts.java:192)\tat sun.security.ssl.SSLSocketImpl.fatal(SSLSocketImpl.java:1949)\tat sun.security.ssl.Handshaker.fatalSE(Handshaker.java:302)\tat sun.security.ssl.Handshaker.fatalSE(Handshaker.java:296)\tat sun.security.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:1509)\tat sun.security.ssl.ClientHandshaker.processMessage(ClientHandshaker.java:216)\tat sun.security.ssl.Handshaker.processLoop(Handshaker.java:979)\tat sun.security.ssl.Handshaker.process_record(Handshaker.java:914)\tat sun.security.ssl.SSLSocketImpl.readRecord(SSLSocketImpl.java:1062)\tat sun.security.ssl.SSLSocketImpl.performInitialHandshake(SSLSocketImpl.java:1375)\tat sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1403)\tat sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1387)\tat com.sun.mail.util.SocketFetcher.configureSSLSocket(SocketFetcher.java:602)\tat com.sun.mail.util.SocketFetcher.createSocket(SocketFetcher.java:376)\tat com.sun.mail.util.SocketFetcher.getSocket(SocketFetcher.java:214)\tat com.sun.mail.smtp.SMTPTransport.openServer(SMTPTransport.java:2160)\t... 38 moreCaused by: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target\tat sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:387)\tat sun.security.validator.PKIXValidator.engineValidate(PKIXValidator.java:292)\tat sun.security.validator.Validator.validate(Validator.java:260)\tat sun.security.ssl.X509TrustManagerImpl.validate(X509TrustManagerImpl.java:324)\tat sun.security.ssl.X509TrustManagerImpl.checkTrusted(X509TrustManagerImpl.java:229)\tat sun.security.ssl.X509TrustManagerImpl.checkServerTrusted(X509TrustManagerImpl.java:124)\tat sun.security.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:1491)\t... 49 moreCaused by: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target\tat sun.security.provider.certpath.SunCertPathBuilder.build(SunCertPathBuilder.java:146)\tat sun.security.provider.certpath.SunCertPathBuilder.engineBuild(SunCertPathBuilder.java:131)\tat java.security.cert.CertPathBuilder.build(CertPathBuilder.java:280)\tat sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:382)\t... 55 more\n\n分析从日志可以定位原因——没有连接到服务器（smtp.sina.com），原因有很多：\n\n账号密码配置错误？\n开启SSL登录，端口是否正确？\n证书问题？\n\n本文遇到的就是第三个问题。\n先放一张图，便于理解\n\n解决方法当然，StackOverflow上也能找到对应解决方法。\n代码在最后，先给出使用方法\nUsage:Need to compile, first:javac InstallCert.javaNote: since java 11, you can run it directly without compiling it first:java --source 11 InstallCert.java &lt;args&gt;# Access server, and retrieve certificate (accept default certificate 1)java InstallCert [--proxy&#x3D;proxyHost:proxyPort] &lt;host&gt;[:port] [passphrase]# Extract certificate from created jssecacerts keystorekeytool -exportcert -alias [host]-1 -keystore jssecacerts -storepass changeit -file [host].cer# Import certificate into system keystorekeytool -importcert -alias [host] -keystore [path to system keystore] -storepass changeit -file [host].cer# Example:java InstallCert woot.com:443    Loading KeyStore &#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-6-sun-1.6.0.26&#x2F;jre&#x2F;lib&#x2F;security&#x2F;cacerts...    Opening connection to woot.com:443...    Starting SSL handshake...    javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target    &lt;...&gt;    Server sent 1 certificate(s):     1 Subject O&#x3D;Woot Inc, C&#x3D;US, ST&#x3D;Texas, L&#x3D;Carrollton, CN&#x3D;*.woot.com       Issuer  CN&#x3D;SecureTrust CA, O&#x3D;SecureTrust Corporation, C&#x3D;US       sha1    4b 46 ca 6b 83 05 b3 51 ff c6 e7 9c fd b3 9b e3 3f 2e c4 53        md5     e8 a5 88 1b d5 67 bb fc 88 cc b1 c5 2b ac c4 7d     Enter certificate to add to trusted keystore or &#39;q&#39; to quit: [1][enter]    [    [      Version: V3      Subject: O&#x3D;Woot Inc, C&#x3D;US, ST&#x3D;Texas, L&#x3D;Carrollton, CN&#x3D;*.woot.com      Signature Algorithm: SHA1withRSA, OID &#x3D; 1.2.840.113549.1.1.5    &lt;...&gt;    Added certificate to keystore &#39;jssecacerts&#39; using alias &#39;woot.com-1&#39;keytool -exportcert -alias woot.com-1 -keystore jssecacerts -storepass changeit -file woot.com.cer    Certificate stored in file &lt;woot.com.cer&gt;  (sudo) keytool -importcert -alias woot.com -keystore &#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-6-sun-1.6.0.26&#x2F;jre&#x2F;lib&#x2F;security&#x2F;cacerts -storepass changeit -file woot.com.cer    Owner: O&#x3D;Woot Inc, C&#x3D;US, ST&#x3D;Texas, L&#x3D;Carrollton, CN&#x3D;*.woot.com    Issuer: CN&#x3D;SecureTrust CA, O&#x3D;SecureTrust Corporation, C&#x3D;US      &lt;...&gt;      Trust this certificate? [no]:  yes    Certificate was added to keystore\n\n//利用java生成证书文件，复制到jre的security文件夹\n&#x2F;* * Copyright 2006 Sun Microsystems, Inc.  All Rights Reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * *   - Redistributions of source code must retain the above copyright *     notice, this list of conditions and the following disclaimer. * *   - Redistributions in binary form must reproduce the above copyright *     notice, this list of conditions and the following disclaimer in the *     documentation and&#x2F;or other materials provided with the distribution. * *   - Neither the name of Sun Microsystems nor the names of its *     contributors may be used to endorse or promote products derived *     from this software without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS * IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. *&#x2F;&#x2F;** * Originally from: * http:&#x2F;&#x2F;blogs.sun.com&#x2F;andreas&#x2F;resource&#x2F;InstallCert.java * Use: * java InstallCert hostname * Example: *% java InstallCert ecc.fedora.redhat.com *&#x2F;import javax.net.ssl.*;import java.io.*;import java.security.KeyStore;import java.security.MessageDigest;import java.security.cert.CertificateException;import java.security.cert.X509Certificate;&#x2F;** * Class used to add the server&#39;s certificate to the KeyStore * with your trusted certificates. *&#x2F;public class InstallCert &#123;    public static void main(String[] args) throws Exception &#123;        String host;        int port;        char[] passphrase;        if ((args.length &#x3D;&#x3D; 1) || (args.length &#x3D;&#x3D; 2)) &#123;            String[] c &#x3D; args[0].split(&quot;:&quot;);            host &#x3D; c[0];            port &#x3D; (c.length &#x3D;&#x3D; 1) ? 443 : Integer.parseInt(c[1]);            String p &#x3D; (args.length &#x3D;&#x3D; 1) ? &quot;changeit&quot; : args[1];            passphrase &#x3D; p.toCharArray();        &#125; else &#123;            System.out.println(&quot;Usage: java InstallCert &lt;host&gt;[:port] [passphrase]&quot;);            return;        &#125;        File file &#x3D; new File(&quot;jssecacerts&quot;);        if (file.isFile() &#x3D;&#x3D; false) &#123;            char SEP &#x3D; File.separatorChar;            File dir &#x3D; new File(System.getProperty(&quot;java.home&quot;) + SEP                    + &quot;lib&quot; + SEP + &quot;security&quot;);            file &#x3D; new File(dir, &quot;jssecacerts&quot;);            if (file.isFile() &#x3D;&#x3D; false) &#123;                file &#x3D; new File(dir, &quot;cacerts&quot;);            &#125;        &#125;        System.out.println(&quot;Loading KeyStore &quot; + file + &quot;...&quot;);        InputStream in &#x3D; new FileInputStream(file);        KeyStore ks &#x3D; KeyStore.getInstance(KeyStore.getDefaultType());        ks.load(in, passphrase);        in.close();        SSLContext context &#x3D; SSLContext.getInstance(&quot;TLS&quot;);        TrustManagerFactory tmf &#x3D;                TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());        tmf.init(ks);        X509TrustManager defaultTrustManager &#x3D; (X509TrustManager) tmf.getTrustManagers()[0];        SavingTrustManager tm &#x3D; new SavingTrustManager(defaultTrustManager);        context.init(null, new TrustManager[]&#123;tm&#125;, null);        SSLSocketFactory factory &#x3D; context.getSocketFactory();        System.out.println(&quot;Opening connection to &quot; + host + &quot;:&quot; + port + &quot;...&quot;);        SSLSocket socket &#x3D; (SSLSocket) factory.createSocket(host, port);        socket.setSoTimeout(10000);        try &#123;            System.out.println(&quot;Starting SSL handshake...&quot;);            socket.startHandshake();            socket.close();            System.out.println();            System.out.println(&quot;No errors, certificate is already trusted&quot;);        &#125; catch (SSLException e) &#123;            System.out.println();            e.printStackTrace(System.out);        &#125;        X509Certificate[] chain &#x3D; tm.chain;        if (chain &#x3D;&#x3D; null) &#123;            System.out.println(&quot;Could not obtain server certificate chain&quot;);            return;        &#125;        BufferedReader reader &#x3D;                new BufferedReader(new InputStreamReader(System.in));        System.out.println();        System.out.println(&quot;Server sent &quot; + chain.length + &quot; certificate(s):&quot;);        System.out.println();        MessageDigest sha1 &#x3D; MessageDigest.getInstance(&quot;SHA1&quot;);        MessageDigest md5 &#x3D; MessageDigest.getInstance(&quot;MD5&quot;);        for (int i &#x3D; 0; i &lt; chain.length; i++) &#123;            X509Certificate cert &#x3D; chain[i];            System.out.println                    (&quot; &quot; + (i + 1) + &quot; Subject &quot; + cert.getSubjectDN());            System.out.println(&quot;   Issuer  &quot; + cert.getIssuerDN());            sha1.update(cert.getEncoded());            System.out.println(&quot;   sha1    &quot; + toHexString(sha1.digest()));            md5.update(cert.getEncoded());            System.out.println(&quot;   md5     &quot; + toHexString(md5.digest()));            System.out.println();        &#125;        System.out.println(&quot;Enter certificate to add to trusted keystore or &#39;q&#39; to quit: [1]&quot;);        String line &#x3D; reader.readLine().trim();        int k;        try &#123;            k &#x3D; (line.length() &#x3D;&#x3D; 0) ? 0 : Integer.parseInt(line) - 1;        &#125; catch (NumberFormatException e) &#123;            System.out.println(&quot;KeyStore not changed&quot;);            return;        &#125;        X509Certificate cert &#x3D; chain[k];        String alias &#x3D; host + &quot;-&quot; + (k + 1);        ks.setCertificateEntry(alias, cert);        OutputStream out &#x3D; new FileOutputStream(&quot;jssecacerts&quot;);        ks.store(out, passphrase);        out.close();        System.out.println();        System.out.println(cert);        System.out.println();        System.out.println                (&quot;Added certificate to keystore &#39;jssecacerts&#39; using alias &#39;&quot;                        + alias + &quot;&#39;&quot;);    &#125;    private static final char[] HEXDIGITS &#x3D; &quot;0123456789abcdef&quot;.toCharArray();    private static String toHexString(byte[] bytes) &#123;        StringBuilder sb &#x3D; new StringBuilder(bytes.length * 3);        for (int b : bytes) &#123;            b &amp;&#x3D; 0xff;            sb.append(HEXDIGITS[b &gt;&gt; 4]);            sb.append(HEXDIGITS[b &amp; 15]);            sb.append(&#39; &#39;);        &#125;        return sb.toString();    &#125;    private static class SavingTrustManager implements X509TrustManager &#123;        private final X509TrustManager tm;        private X509Certificate[] chain;        SavingTrustManager(X509TrustManager tm) &#123;            this.tm &#x3D; tm;        &#125;        public X509Certificate[] getAcceptedIssuers() &#123;\t   \t    &#x2F;** \t     * This change has been done due to the following resolution advised for Java 1.7+\t\thttp:&#x2F;&#x2F;infposs.blogspot.kr&#x2F;2013&#x2F;06&#x2F;installcert-and-java-7.html       \t     **&#x2F; \t    \t    return new X509Certificate[0];\t            &#x2F;&#x2F;throw new UnsupportedOperationException();        &#125;        public void checkClientTrusted(X509Certificate[] chain, String authType)                throws CertificateException &#123;            throw new UnsupportedOperationException();        &#125;        public void checkServerTrusted(X509Certificate[] chain, String authType)                throws CertificateException &#123;            this.chain &#x3D; chain;            tm.checkServerTrusted(chain, authType);        &#125;    &#125;&#125;\n\n","categories":["编程笔记"],"tags":["SpringBoot","MailSender"]},{"title":"Python 爬虫 01-通用爬虫基本流程","url":"/2018/10/18/Python-%E7%88%AC%E8%99%AB-01-%E9%80%9A%E7%94%A8%E7%88%AC%E8%99%AB%E7%BB%93%E6%9E%84/","content":"爬虫是什么爬虫：一段自动抓取互联网信息的程序，从互联网上抓取对于我们有价值的信息。\n通用爬虫基本流程用一个通用的网络爬虫结构来说明网络爬虫的基本工作流程：\n\n网络爬虫的基本工作流程如下：\n(1).   首先抓取一部分待取的种子URL；\n(2).   将这些URL放入待取的URL队列；\n(3).   从待取的URL队列中读取待抓取网页的URL，解析DNS并且得到主机的IP，将URL对应的网页内容下载下来，存储已下载网页库中，并将这些URL放入已抓取URL队列；\n(4).   分析已抓取URL队列中的URL，从已下载的网页数据分析出其他URL冰河已抓取的URL进行对比去重，最后将去重后的URL放入待抓取队列，从而进入下一个循环。\n","tags":["爬虫"]}]