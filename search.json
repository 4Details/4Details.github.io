[{"title":"FATE 1.2 实践02-FATE集群部署","url":"/2020/08/27/FATE-1-2-%E5%AE%9E%E8%B7%B502%EF%BC%9AFATE%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/","content":"配置FATE环境第1步中虚拟机创建完成后的信息如下\n\n\n\n主机名\nhost155\nguest156\nguest157\n\n\n\nIP\n192.168.119.155\n192.168.119.156\n192.168.119.157\n\n\n\n\n\n\n\n\n下面的步骤均是依据官方文档操作 \n基础环境配置注意：不特殊说明，下面配置需要在所有机器上操作！！\n由于在创建虚拟机过程中已经更改过每台主机名、创建用户app，所以文档中hostname配置可跳过。\nroot权限下创建文件夹  /data/projects 归属 app用户\n&#x2F;&#x2F;切换root用户，-p创建文件夹，给app用户赋予权限su rootmkdir -p &#x2F;data&#x2F;projectschown -R app &#x2F;data&#x2F;projects\n\n\n\n关闭selinux确认是否已安装selinux\ncentos系统执行：rpm -qa | grep selinux\nubuntu系统执行：apt list –installed | grep selinux\n如果已安装了selinux就执行：setenforce 0\n\n修改Linux最大打开文件数切换root用户，在limits.conf文件最后添加5、6行代码，保存退出\nsu rootvim &#x2F;etc&#x2F;security&#x2F;limits.conf* soft nofile 65536* hard nofile 65536\n\n\n\n\n添加主机映射vim &#x2F;etc&#x2F;hosts\n\n\n\n\n关闭虚拟机防火墙在实际生产环境中需要配置防火墙端口规则！虚拟机环境下采用关闭防火墙的方式。\n如果是Centos系统：\nsystemctl disable firewalld.servicesystemctl stop firewalld.servicesystemctl status firewalld.service\n\n本例的环境是Centos系统\n\n如果是Ubuntu系统：\nufw disableufw status\n\n给用户赋予sudo权限root用户下对app用户赋予sudo权限\nvim &#x2F;etc&#x2F;sudoers.d&#x2F;appapp ALL&#x3D;(ALL) ALLapp ALL&#x3D;(ALL) NOPASSWD: ALLDefaults !env_reset\n\n\n\n配置ssh远程登录a. 切换app用户，生成rsa_id，具体根据下面代码\n\nb.合并id_rsa_pub文件\n步骤如下：三台机器分别将id_rsa.pub 写入authorized_keys文件中并且赋予权限chomd 600\n\n155通过scp将authorized_keys文件发送到156上，并将156的id_rsa.pub文件写入，然后将生成的新文件发送至157上，并且写入157生成的id_rsa.pub文件，将最终生成的authorized_keys文件发送给155和156，此时通过ssh即可登录（在发送文件过程中建立连接需要输入密码）\n155-&gt;156\n\n156写入， -&gt;157\n\n157写入，-&gt;155  -&gt;156\n\n上述完成之后即可通过  ssh usernane@ip访问某台虚拟机\n需要注意的是，访问自身需要重新建立一个连接。\n建议配置以上步骤之后拍摄虚拟机快照，便于后期恢复重新部署。\nFATE部署完成基础环境配置之后，接下来就需要部署FATE的运行环境，本例使用的是Installation文档。\n下面的操作只需在其中一台机器操作即可，本例选用的是host 155。\n下载压缩包可以使用wget下载，也可以直接通过链接下载。\ncd &#x2F;data&#x2F;projectswget https:&#x2F;&#x2F;webank-ai-1251170195.cos.ap-guangzhou.myqcloud.com&#x2F;FATE_install_v1.2.0.tar.gztar -xf FATE_install_v1.2.0.tar.gz\n\n\n\n\n修改configuration文件可以使用vim，也可以直接使用编辑器打开并修改。\ncd &#x2F;data&#x2F;projects&#x2F;FATE&#x2F;cluster-deploy&#x2F;scriptvi multinode_cluster_configuration.sh\n\n\n\n\n\n建议在部署之前拍摄快照，为防止在部署过程中因某些配置出错造成部署失败。\n部署本例中选择在各机器上部署所有组件。\ncd FATE&#x2F;cluster-deploy&#x2F;scripts# 部署所有组件bash deploy_cluster_multinode.sh binary all # 只部署部分组件(可选：jdk python mysql redis fate_flow federatedml fateboard proxy federation roll meta-service egg)：bash deploy_cluster_multinode.sh binary fate_flow\n\n\n\n-———————————————————————————————————————-\n———————————————–漫长地等待过程——————————————————–\n-———————————————————————————————————————-\n（部署时间暂未统计，时间需要2-4个小时，记录下了部署过程中终端产生的日志）\n此处为语雀文档，点击链接查看：https://www.yuque.com/u190689/qoiq3w/seeq38\n配置检查请务必详细对照检查！！！\n到各个目标服务器上进行检查对应模块的配置是否准确，每个模块的对应配置文件所在路径可在此配置文件下查看，参考：https://github.com/FederatedAI/FATE/blob/master/cluster-deploy/doc/configuration.md\n至此，FATE v1.2的安装部署全部结束，接下来测试环境。\n建议部署成功之后拍摄快照，便于将来找到还原点。\n","categories":["联邦学习"],"tags":["FATE","FL"]},{"title":"九种基础排序算法原理及实现","url":"/2020/09/01/%E4%B9%9D%E7%A7%8D%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/","content":"注：本文所述待排序列排序结果均为升序。\n冒泡排序冒泡排序是一种简单的排序算法，主要过程是循环遍历待排序列，一次比较两个元素，若是与结果序列顺序相反，则两个元素交换，直至序列中元素无需交换为止。\n算法描述\n比较相邻元素，如果前一个元素比后一个元素大，则交换二者，否则进入2；\n对每一对相邻元素做同样的判断和操作，从开始第一对到序列中的最后一对元素，此时序列中最大元素在最后；\n针对序列中所有元素重复上述操作，除掉最后一个元素（此时最大值已经在最终位置）；\n重复1~3步骤，直至序列为升序序列。\n\n代码实现朴素版\n\n优化版\n\n算法分析稳定性：在相邻元素相等时，元素之间不会发生交换，所以冒泡排序是稳定排序。\n时间复杂度：双重循环，时间复杂度为O(n^2)。在最好情况下（数据已经有序），时间复杂度为O(n)。\n适用场景算法的时间复杂度为平方级，所以冒泡排序适合少量数据的排序，一般数量少于1000，一旦数据量过大，排序效率会下降很大，所以在数据量大的时候不适用。\n选择排序选择排序是一种简单直观的排序算法，同时也是一种交换类排序算法，与冒泡排序有些类似。\n算法描述\n在待排序列中找出最小（大）元素，放入已排序数组的起始位置；\n在剩下的待排序列中继续找出最小（大）元素，放入已排序数组的最后位置；\n重复第2步，直至序列有序。\n\n代码实现private static void selectionSort(int[] arr, int n)&#123;    int min = 0;    for (int i = 0; i &lt; n; i++)&#123;        min = i;        // 循环查找待排序列中的最小值        for (int j = i+1; j &lt; n; j++)&#123;            if (arr[min] &gt; arr[j])&#123;                min = j;            &#125;        &#125;        if (min != i)&#123;            swap(arr, i, min);        &#125;    &#125;&#125;\n\n算法分析稳定性：使用数组实现的选择排序算法，在遇到相等元素时，插入到排序序列中，相对位置会发生变化，所以选择排序是不稳定的算法。但是使用链表实现的选择排序算法是稳定的。\n时间复杂度：双重循环实现，时间复杂度为O(n^2)，在最好情况下（数据基本或已经有序），仍然需要O(n^2)。\n适应场景因为在各种情况下的时间复杂度固定为O(n^2)，所以只适用于小量数据的排序。\n选择排序实现比较简单，并且在各种情况下的波动性较小，一般优于冒泡排序，在所有的完全交换类排序中，也是一个比较不多的算法。\n插入排序快速排序归并排序堆排序希尔排序桶排序","categories":["算法笔记"],"tags":["排序"]},{"title":"回文串引发的“血案”","url":"/2020/08/28/%E5%9B%9E%E6%96%87%E4%B8%B2%E5%BC%95%E5%8F%91%E7%9A%84%E2%80%9C%E8%A1%80%E6%A1%88%E2%80%9D/","content":"简单枚举# 基于中心线枚举Class Solution:\tdef longestPalindrome(self,s):        if not s:            return &quot;&quot;                self.start, self.longest = 0, 0        for middle in range(len(s)):            self.find_longest_palidrome_from(s, middle, middle)            self.find_longest_palidrome_from(s, middle, middle+1)        return s[self.start:self.start + self.longest]        def find_longest_palidrome_from(self, s, left, right):        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:            left -= 1            right += 1        if self.longest &lt; right -left -1:            self.longest = right - left -1            self.start = left +1\n\n\n动态规划# 基于动态规划（区间型：从小到大枚举区间）class Solution:\tdef longestPalindrome(self, s):        if not s:            return &quot;&quot;                n = len(s)        is_palindrome = [[False] * n for _ in range(n)]        for i in range(n):            is_palindrome[i][i] = True        for i in range(1, n):            is_palindrome[i][i-1] = True                start, longest = 0, 1        for length in range(2, n-1):            for i in range(n - length + 1):                j = i + length -1                is_palindrome[i][j] = is_palindrome[i+1][j-1] and s[i] == s[j]                if is_palindrome[i][j] and length &gt; longest:                    longest = length                    start = i         return s[start:start + longest]\n\n","categories":["算法笔记"],"tags":["回文串","动态规划"]},{"title":"FATE 1.2 实践01-虚拟机安装","url":"/2020/08/27/FATE-1-2-%E5%AE%9E%E8%B7%B501%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/","content":"创建虚拟机新建虚拟机使用VMWare WorkStation创建虚拟机（单机版只需要一台机器，集群版可以使用多台机器，下面示例中创建了3台虚拟机，配置均为 300G，16GB，4核处理器，系统镜像为 CentOS-7-x86_64-DVD-1810版本）\n\n\n\n                         \n\n\n                                       \n配置操作系统启动虚拟机，加载并配置操作系统\n     \n  \n此处选择默认语言为【简体中文】，可以直接在编辑框输入快速查找。下一步则需要配置系统的软件、磁盘分区、网络等信息。\n\n这里需要注意的是详细配置图中标注的1，2，3。本例中详细的配置如下：\n\n本例中选择的是GNOME桌面版的软件，已选环境附加选项可根据实际需要选择，选择桌面版的可视化环境有利于后续工作的进行。下一步选择安装目标位置中提前配置分区信息尤为重要！！！\n\n\n\n官方文档中建议全部磁盘挂载到新建的用户app下，但是本例中将大部分磁盘挂载到root下，经实践是有效的，在如上配置之后点击【完成】即可完成磁盘及分区的配置。\n下一步需要提前完成系统网络信息的配置，如主机名、ip、子网掩码、DNS、路由信息等。\n\n点击【配置】可进入ip、DNS等信息的配置。\n\n在上图的配置中需要注意的是，选择手动配置IPv4的信息，地址、子网掩码和网关需要配置正确，本例中DNS服务器默认为网关信息。网络信息配置完成之后可以【开启】以太网的连接，详细的信息可以参考下图\n\n1，2，3的所有信息完成配置之后点击【开始安装】则进入安装界面，此时可以配置系统root用户的密码以及新建用户。本例中遵循官方文档创建用户 app，在“高级用户配置”中，编辑app分属apps组，用户id为6000。\n\n\n等待安装完成，【重启】即可进入桌面版的centos7 操作系统。\n\n初始设置需要接受许可证协议，【完成配置】即可登录输入密码，进入系统。\n\n提示：在实际操作中无需一步步按照上述步骤创建三台或多台虚拟机，在创建完成一台虚拟机之后可以通过“克隆”操作得到已安装完成的虚拟机镜像，这样可以在一定程度上节约创建虚拟机的时间，需要注意的是，在克隆完成启动之前需要重新生成机器的mac地址，否则会造成mac冲突。因为原始虚拟机使用的是静态地址，所以在开启之后需要重新对副本虚拟机分配静态IP。\n克隆方法主要是： 点击 虚拟机-管理-克隆  使用克隆虚拟机向导\n\n\n\n重命名和选择虚拟机所在路径之后点击【完成】即可。\n\n\n\n打开虚拟机之后可以使用  ifconfig查看网络配置信息\n\n需要更改的信息有 主机名、ip\n\n配置IP信息主要路径在 /etc/sysconfig/network-script，修改 sysconf-ens33 （ens33指的是网卡名称）\n文件中可以修改的有是否静态ip，PROTO一项改为 static  配置ip地址，子网掩码，网关，dns\n\n进入编辑页面\n\n半角状态输入’i’可修改内容，修改完成如下，Esc退出编辑，”:wq”可以保存修改并退出vim编辑页面\n\n重启之后使用ifconfig查看，ip已经改变。\n克隆得到另外两台虚拟机，按上述步骤修改IP信息之后即完成了本例中的创建虚拟机步骤。\n\n","categories":["联邦学习"],"tags":["FATE","FL"]},{"title":"HashMap解析","url":"/2020/08/22/HashMap%E8%A7%A3%E6%9E%90/","content":"HashMap继承体系\n","tags":["HashMap"]},{"title":"讨论社区50  -  常见面试题","url":"/2019/09/06/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA50%20-%20%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/","content":"MySQL\n存储引擎\nInnoDB支持事务（Transations）\n\n\n事务\n事务的特性：原子性、一致性、隔离性、持久性\n事务的隔离\n并发异常：第一类丢失更新、第二类丢失更新、脏读、不可重复读、幻读\n隔离级别：Read Uncommited、Read Committed、Repeatable Read、Serializable\nSpring事务管理：声明式事务、编程式事务\n\n\n\n\n锁\n范围\n表级锁：开销小、加锁快，发生锁冲突的概率高、并发度低，不会出现死锁。\n行级锁：开销大、加锁慢，发生锁冲突的概率低、并发度高，会出现死锁。\n\n\n\n\n索引（InnoDB）\n共享锁（S）：行级，读取一行；\n排他锁（X）：表级，更新一行；\n意向共享锁（IS）：表级，准备加共享锁；\n意向排他锁（IX）：表级，准备加排他锁；\n间隙锁（NK）：行级，使用范围条件时，对范围内不存在的记录加锁。一是为了防止幻读，二是为了满足恢复和复制的需要。\n\n\n\n\n\n\n\nIS\nIX\nS\nX\n\n\n\nIS\n\n\n\nx\n\n\nIX\n\n\nx\nx\n\n\nS\n\nx\n\nx\n\n\nX\nx\nx\nx\nx\n\n\n\n加锁\n\n增加行级锁之前，InnoDB会自动给表加意向锁；\n执行DML语句时，InnoDB会自动给数据加排他锁；\n执行DQL语句时\n共享锁（S）：SELECT...FROM...WHERE...LOCK IN SHARE MODE;\n排他锁（X）：SELECT...FROM...WHERE...FOR UPDATE;\n间隙锁（NK）：上述SQL采用范围条件时，InnoDB对不存在的记录自动增加间隙锁。\n\n\n\n\n死锁\n\n场景\n事务1：UPDATE T SET...WHERE ID=1;UPDATE T SET...WHERE ID=2;\n事务2：UPDATE T SET...WHERE ID=2;UPDATE T SET...WHERE ID=1;\n\n\n解决方案\n一般InnoDB会自动检测到，并使一个事务回滚，另一个事务继续；\n设置超时等参数 innodb_lock_wait_timeout；\n\n\n避免死锁\n不同的业务并发访问多个表时，应约定以相同的顺序来访问这些表；\n以批量的方式处理数据时，应事先对数据排序，保证线程按固定的顺序来处理数据；\n在事务中，如果要更新记录，应直接申请足够级别的锁，即排他锁；\n\n\n\n\n悲观锁（数据库）\n\n乐观锁（自定义）\n\n版本号机制\n\nUPDATE..SET...,VERSION=#&#123;version+1&#125; WHERE ... AND ... VERSION=#&#123;version&#125;\n\n\nCAS算法（Compare and swap）\n是一种无锁的算法，该算法涉及3个操作数（内存值V、旧值A、新值B），当V等于A时，采用原子方式用B的值更新V的值。该算法通常采用自旋操作，也叫自旋锁。它的缺点是：\n\nABA问题：某线程将A改为B，再改回A，则CAS会误认为A没被修改过。\n自旋操作采用循环的方式实现，若加锁时间长，则会给CPU带来巨大的开销。\nCAS只能保证一个共享变量的原子操作。\n\n\n\n\nB+Tree(InnoDB)\n\n数据分块存储，每一块称为一页；\n所有值都是按顺序存储的，并且每一个叶子到根的距离相同；\n非叶子节点存储数据的边界，叶子节点存储指向数据行的指针；\n通过边界缩小数据的范围，从而避免全表扫描，加快了查找的速度。\n\n\n\nRedis\n数据类型\n\n\n\n\n数据类型\n最大存储数据量\n\n\n\nkey\n512M\n\n\nstring\n512M\n\n\nhash\n2^32-1\n\n\nlist\n2^32-1\n\n\nset\n2^32-1\n\n\nsorted set\n官方没给\n\n\nbitmap\n512M\n\n\nhyperloglog\n12K\n\n\n\n过期策略\nRedis会把设置了过期时间的key放入一个独立的字典里，在key过期时并不会立刻删除它。\nRedis会通过如下两种策略，来删除过期的key：\n\n惰性删除\n客户端访问某个key时，Redis会检查该key是否过期，若过期则删除。\n\n定期扫描\nRedis默认每秒执行10次过期扫描（配置hz选项），扫描策略如下：\n\n从过期字典中随机选择20个key；\n删除这20个key中已过期的key；\n如果过期的key的比例超过25%，则重复步骤1；\n\n\n\n\n淘汰策略\n当Redis占用内存超出最大限制（maxmemory）时，可采用如下策略（maxmemory-policy），让Redis淘汰一些数据，以腾出空间继续提供读写服务：\n\nnoeviction：对可能导致增大内存的命令返回错误（大多数写命令，DEL除外）；\nvolatile-ttl：在设置了过期时间的key中，选择剩余寿命（TTL）最短的key，将其淘汰；\nvolatile-lru：在设置了过期时间的key中，选择最少使用的key（LRU），将其淘汰；\nvolatile-random：在设置了过期时间的key中，随机选择一些key，将其淘汰；\nallkeys-lru：在所有的key中，选择最少使用的key（LRU），将其淘汰；\nallkeys-random：在所有的key中，随机选择一些key，将其淘汰；\n\nLRU算法：\n\n维护一个链表，用于顺序存储被访问过的key。在访问数据时，最新访问过的key将被移动到表头，即最近访问的key在表头，最少访问的key在表尾。\n\n近似LRU算法（Redis）\n\n给每个key维护一个时间戳，淘汰时随机采样5个key，从中淘汰掉最旧的key。如果还是超出内存限制，则继续随机采样淘汰。\n优点：比LRU算法节约内存，却可以取得非常近似的效果。\n\n\n缓存穿透\n\n场景\n查询根本不存在的数据，使得请求直达存储层，导致其负载过大，甚至宕机。\n\n解决方案：\n\n缓存空对象：存储层未命中后，仍然将空值存入缓存层。再次访问该数据时，缓存层会直接返回空值。\n布隆过滤器：将所有存在的key提前存入布隆过滤器，在访问缓存层之前，先通过过滤器拦截，若请求的是不存在的key，则直接返回空值。\n\n\n\n\n缓存击穿\n\n场景\n一份热点数据，它的访问量非常大。在其缓存失效瞬间，大量请求直达存储层，导致服务崩溃。\n\n解决方案：\n\n加互斥锁：对数据的访问加互斥锁，当一个线程访问该数据时，其他线程只能等待。这个线程访问过后，缓存中的数据将被 重建，届时其他线程就可以直接从缓存取值。\n永不过期：不设置过期时间，所以不会出现上述问题，这是“物理“上的不过期。为每个value设置逻辑过期时间，当发现该值逻辑过期时，使用单独的线程重建缓存。\n\n\n\n\n缓存雪崩\n\n场景\n由于某些原因，缓存层不能提供服务，导致所有请求直达存储层，造成存储层宕机。\n\n解决方案：\n\n避免同时过期：设置过期时间时，附加一个随机数，避免大量的key同时过期。\n构建高可用的Redis缓存：部署多个Redis实例，个别节点宕机，依然可以保持服务的整体可用。\n构建多级缓存：增加本地缓存，在存储层前面多加一级屏障，降低请求直达存储层的几率。\n启用限流和降级措施：对存储层增加限流措施，当请求超出限制时，对其提供降级服务。\n\n\n\n\n分布式锁\n\n场景\n修改时，经常需要将数据读取到内存，在内存中修改后再存回去。在分布式应用中，可能多个进程同时执行上述操作，而读取和修改非原子操作，所以会产生冲突。增加分布式锁，可以解决此类问题。\n\n基本原理\n\n同步锁：在多个线程都能访问到的地方，做一个标记，标识该数据的访问权限。\n分布式锁：在多个进程都能访问到的地方，做一个标记，标识该数据的访问权限。\n\n\n实现方式\n\n基于数据库实现分布式锁；\n基于Redis实现分布式锁；\n基于Zookeeper实现分布式锁；\n\n\nRedis实现分布式锁的原则\n\n安全属性：独享。在任一时刻，只有一个客户端持有锁。\n活性A：无死锁。即便持有锁的客户端崩溃或者网络被分裂，锁仍然可以被获取。\n活性B：容错。只要大部分Redis节点都活着，客户端就可以获取和释放锁。\n\n\n单Redis实例实现分布式锁\n\n获取锁使用命令：\nSET resource_name my_random_value NX PX 30000\n\nNX：仅在key不存在时才执行成功。PX：设置锁的自动过期时间。\n\n通过Lua脚本释放锁：\nif redis.call(&quot;get&quot;,KEYS[1]) &#x3D;&#x3D; ARGV[1] then \treturn redis.call(&quot;del&quot;,KEYS[1])else return 0 end\n\n可以避免删除别的客户端获取成功的锁：\nA加锁 –&gt; A阻塞 –&gt; 因超时释放锁 –&gt; B加锁 –&gt; A恢复 –&gt; 释放锁\n\n\n\n多Redis实例实现分布式锁\nRedlock算法，该算法有现成的实现，其Java版本的库为Redisson。\n\n获取当前Unix时间，以毫秒为单位。\n依次尝试从N个实例，使用相同的key和随机值获取锁，并设置响应超时时间。如果服务器没有在规定时间内响应，客户端应该尽快尝试另外一个Redis实例。\n客户端使用当前时间减去开始获取锁的时间，得到获取锁使用的时间。当且仅当大多数的Redis节点都取到锁，并且使用的时间小于锁失效的时间时，锁才算取得成功。\n如果取到了锁，key的真正有效时间等于有效时间减去获取锁使用的时间。\n如果获取锁失败，客户端应该在所有的Redis实例上进行解锁。\n\n\n\n\n\nSpring\nSpring IOC\nBean的作用域\n\n\n\n\n\n\n作用域\n使用范围\n描述\n\n\n\nsingleton\n所有Spring应用\n在容器中只存在一个实例，默认值。\n\n\nprototype\n所有Spring应用\n在容器中存在多个实例，即每次获取该Bean时，都会创建一个新实例。\n\n\nrequest\nSpringWeb应用\n为每个请求创建一个新的实例。\n\n\nsession\nSpringWeb应用\n为每个会话创建一个新的实例。\n\n\nglobalSession\nSpringWeb应用\n为全局的session创建一个实例，只在Portlet上下文中有效。\n\n\napplication\nSpringWeb应用\n为整个Web应用创建一个新的实例。\n\n\n\nSpring AOP\n\nAOP的术语\nTarget（Joinpoint）&lt;– Weaving &lt;– Aspect(Pointcut(s.find*(..))、Advice(q前、后、返回、异常))\n\n编译时织入，需使用特殊的编译器。\n装载时织入，需使用特殊的类装载器。\n运行时织入，需为目标生成代理对象。\n\n\n\n\n\nSpring MVC\n\n客户端发出请求访问服务器时，由DispatcherServlet处理。\nDispatcherServlet调用HandlerMapping(根据访问路径找到对应Controller)。\nHandlerMapping给DispatcherServlet返回HandlerExecutionChain对象（封装了Controller和拦截器）。\nDispatcherServlet调用拦截器的preHandle()方法，接着调用HandlerAdapter(内部调了Controller)。\nHandlerAdapter返回ModelAndView给DispatcherServlet，返回后调用postHandle()方法。\nDispatcherServlet调用ViewResolver(视图解析器)。\nViewResolver解析View，由模板引擎渲染，（拦截器的afterCompletion()方法）返回客户端。\n\n\n\n\n","categories":["讨论社区项目"]},{"title":"讨论社区49  -  项目总结","url":"/2019/09/04/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA49%20-%20%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/","content":"\n\nSpring Boot\nSpring\nSpring MVC、Spring Mybatis、Spring Security\n权限@会话管理\n注册、登录、退出、状态、设置、授权\nSpring Email、Interceptor\n\n\n核心@敏感词、@事务\n首页、帖子、评论、私信、异常、日志\nAdvice、AOP、Transaction\n\n\n性能@数据结构\n点赞、关注、统计、缓存\nRedis\n\n\n通知@模式\n系统通知\nKafka\n\n\n搜索@索引\n全文搜索\nElasticsearch\n\n\n其他@线程池、@缓存\n排行、上传、服务器缓存\nQuartz、Caffeine\n\n\n\n动态请求：客户端–&gt;Nginx主(从)–&gt;Sever(talking-&gt;本地缓存)–&gt;Redis、DB、Kafka、Elasticsearch、文件服务器（七牛云）\n静态资源：客户端–&gt; 部署到CDN缓存服务（全国都有服务器，就近加载）\n\n项目地址：https://github.com/4Details/talking\n","categories":["讨论社区项目"]},{"title":"讨论社区48  -  项目部署","url":"/2019/09/01/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA48%20-%20%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/","content":"\n浏览器访问Nginx（负责分发请求，反向代理）\nTomcat服务器（装JRE和Maven）\nMySQL、Redis、Kafka、Elasticsearch、Wkhtmltopdf\nPutty(访问服务器的客户端)\n\n\n\n需要修改几处代码：\napplication.properties context_path\n首页访问路径改为空（HomeController访问首页和global.js的context_path）\n项目打包为war，且文件名为ROOT\n另建开发和生产环境下使用的application-develop.properties、application-produce.properties和logback-spring-develop.xml、logback-spring-produce.xml，还需要在默认的application.properties中配置启用哪份文件配置。\n\n\nTomcat访问下面的文件，文件声明主启动文件\nimport org.springframework.boot.builder.SpringApplicationBuilder;import org.springframework.boot.web.servlet.support.SpringBootServletInitializer;public class TalkingServletInitializer extends SpringBootServletInitializer &#123;    @Override    protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) &#123;        return builder.sources(TalkingApplication.class);    &#125;&#125;\n\n","categories":["讨论社区项目"],"tags":["Nginx"]},{"title":"讨论社区47  -  项目监控","url":"/2019/08/31/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA47%20-%20%E9%A1%B9%E7%9B%AE%E7%9B%91%E6%8E%A7/","content":"\nSpring Boot Actuator\nEndpoints: 监控应用的入口，Spring Boot内置了很多端点，也支持自定义端点。\n监控方式：HTTP或JMX。\n访问路径：例如“/actuator/health”。\n注意事项：按需配置暴露的端点，并对所有端点进行权限控制。\n\n\n\n导包\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;\n\n配置\n# actuatormanagement.endpoints.web.exposure.include=*# 不暴露的端点management.endpoints.web.exposure.exclude=info,caches\n\n自定义端点\n/***  监控数据库连接是否正常*/import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.actuate.endpoint.annotation.Endpoint;import org.springframework.boot.actuate.endpoint.annotation.ReadOperation;import org.springframework.stereotype.Component;import javax.sql.DataSource;import java.sql.Connection;import java.sql.SQLException;@Component@Endpoint(id = &quot;database&quot;)public class DatabaseEndpoint &#123;    private static final Logger logger = LoggerFactory.getLogger(DatabaseEndpoint.class);    @Autowired    private DataSource dataSource;    @ReadOperation    public String checkConnection() &#123;        try (                Connection conn = dataSource.getConnection();        ) &#123;            return TalkingUtil.getJSONString(0, &quot;获取连接成功!&quot;);        &#125; catch (SQLException e) &#123;            logger.error(&quot;获取连接失败:&quot; + e.getMessage());            return TalkingUtil.getJSONString(1, &quot;获取连接失败!&quot;);        &#125;    &#125;&#125;\n\n","categories":["讨论社区项目"],"tags":["Spring Boot","Actuator"]},{"title":"讨论社区46  -  单元测试","url":"/2019/08/30/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA46%20-%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/","content":"单元测试\nSpring Boot Testing\n\n依赖：spring-boot-starter-test\n包括：Junit、Spring Test 、AssertJ、…\n\n\nTest Case\n\n要求：保证测试方法的独立性。\n步骤：初始化数据、执行测试代码、验证测试结果、清理测试数据。\n常用注解：@BeforeClass、@AfterClass、@Before、@After。\n\n\n\nimport com.wx.talking.entity.DiscussPost;import com.wx.talking.service.DiscussPostService;import org.junit.*;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringRunner;import java.util.Date;@RunWith(SpringRunner.class)@SpringBootTest@ContextConfiguration(classes = TalkingApplication.class)public class SpringBootTests &#123;    @Autowired    private DiscussPostService discussPostService;    private DiscussPost data;    @BeforeClass    public static void beforeClass() &#123;        System.out.println(&quot;beforeClass&quot;);    &#125;    @AfterClass    public static void afterClass() &#123;        System.out.println(&quot;afterClass&quot;);    &#125;    @Before    public void before() &#123;        System.out.println(&quot;before&quot;);        // 初始化测试数据        data = new DiscussPost();        data.setUserId(111);        data.setTitle(&quot;Test Title&quot;);        data.setContent(&quot;Test Content&quot;);        data.setCreateTime(new Date());        discussPostService.addDiscussPost(data);    &#125;    @After    public void after() &#123;        System.out.println(&quot;after&quot;);        // 删除测试数据        discussPostService.updateStatus(data.getId(), 2);    &#125;    @Test    public void test1() &#123;        System.out.println(&quot;test1&quot;);    &#125;    @Test    public void test2() &#123;        System.out.println(&quot;test2&quot;);    &#125;   // 特定需求，调用方法即可&#125;\n\n@BeforeClass和@AfterClass只会在类加载和销毁时调用一次，@Before和@After在每调用一次方法会分别执行一次\n测试\n先修改，然后再查询，利用断言（Assert）判断是否相等，@Test正常运行则方法无误，否则出现错误。\n","categories":["讨论社区项目"]},{"title":"讨论社区45  -  优化网站性能","url":"/2019/08/25/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA45%20-%20%E4%BC%98%E5%8C%96%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD/","content":"缓存简介\n本地缓存\n\n将数据缓存在应用服务器上，性能最好。\n常用缓存工具：Ehcache、Cuava、Caffeine等。\n\n\n分布式缓存\n\n将数据缓存在NoSQL数据库上，跨服务器。\n常用缓存工具：MemCache、Redis等。\n\n\n多级缓存\n\n-&gt;一级缓存（本地缓存）-&gt;二级缓存（分布式缓存）-&gt; DB\n避免缓存雪崩（缓存失效，大量请求直达DB），提高系统的可用性。\n\n尽最大可能避免直接访问数据库！\n\n\n项目整合缓存&lt;dependency&gt;    &lt;groupId&gt;com.github.ben-manes.caffeine&lt;/groupId&gt;    &lt;artifactId&gt;caffeine&lt;/artifactId&gt;    &lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt;\n\n# caffeine  配置本地参数caffeine.posts.max-size&#x3D;15caffeine.posts.expire-seconds&#x3D;180\n\n主要在service业务层优化就可以\n@Value(&quot;$&#123;caffeine.posts.max-size&#125;&quot;)private int maxSize;@Value(&quot;$&#123;caffeine.posts.expire-seconds&#125;&quot;)private int expireSeconds;// Caffeine核心接口: Cache, LoadingCache（同步缓存）, AsyncLoadingCache（异步缓存，支持并发）// 帖子列表缓存private LoadingCache&lt;String, List&lt;DiscussPost&gt;&gt; postListCache;// 帖子总数缓存private LoadingCache&lt;Integer, Integer&gt; postRowsCache;@PostConstructpublic void init() &#123;    // 初始化帖子列表缓存    postListCache = Caffeine.newBuilder()            .maximumSize(maxSize)            .expireAfterWrite(expireSeconds, TimeUnit.SECONDS)            .build(new CacheLoader&lt;String, List&lt;DiscussPost&gt;&gt;() &#123;                @Nullable                @Override                public List&lt;DiscussPost&gt; load(@NonNull String key) throws Exception &#123;                    if (key == null || key.length() == 0) &#123;                        throw new IllegalArgumentException(&quot;参数错误!&quot;);                    &#125;                    String[] params = key.split(&quot;:&quot;);                    if (params == null || params.length != 2) &#123;                        throw new IllegalArgumentException(&quot;参数错误!&quot;);                    &#125;                    int offset = Integer.valueOf(params[0]);                    int limit = Integer.valueOf(params[1]);                    // 二级缓存: Redis -&gt; mysql                    logger.debug(&quot;load post list from DB.&quot;);                    return discussPostMapper.selectDiscussPosts(0, offset, limit, 1);                &#125;            &#125;);    // 初始化帖子总数缓存    postRowsCache = Caffeine.newBuilder()            .maximumSize(maxSize)            .expireAfterWrite(expireSeconds, TimeUnit.SECONDS)            .build(new CacheLoader&lt;Integer, Integer&gt;() &#123;                @Nullable                @Override                public Integer load(@NonNull Integer key) throws Exception &#123;                    logger.debug(&quot;load post rows from DB.&quot;);                    return discussPostMapper.selectDiscussPostRows(key);                &#125;            &#125;);&#125;// 更改查询数据// 查询帖子，先从缓存读取if (userId == 0 &amp;&amp; orderMode == 1) &#123;            return postListCache.get(offset + &quot;:&quot; + limit);&#125;\n\n网站压力测试Apache JMeter 工具\n对比测试：无缓存策略，有缓存策略\n\n无缓存需先将LogAspect注解 注释，且将第二部分代码块相应注释\n\n","categories":["讨论社区项目"],"tags":["性能优化","缓存"]},{"title":"讨论社区44  -  文件上传至云服务器","url":"/2019/08/23/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA44%20-%20%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E8%87%B3%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/","content":"\n客户端上传\n客户端将数据提交给云服务器，并等待其响应。\n用户上传头像时，将表单数据提交给云服务器。\n\n\n服务器直传\n应用服务器将数据直接提交给云服务器，并等待其响应。\n分享时，服务端将自动生成的图片，直接提交给云服务器。\n\n\n\n","categories":["讨论社区项目"]},{"title":"讨论社区43  -  生成长图","url":"/2019/08/21/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA43%20-%20%E7%94%9F%E6%88%90%E9%95%BF%E5%9B%BE/","content":"\nwkhtmltopdf\nwkhtmltopdf url file    模板内容转成PDF\nwkhtmltoimage url file   网页内容转成图片\n\n\n\nhttps://wkhtmltopdf.org\n软件下载，建议将bin配置到环境变量\n\njava\nRuntime.getRuntime().exec()\n\n\n\nimport java.io.IOException;public class WkTests &#123;    public static void main(String[] args) &#123;        String cmd = &quot;D:/Program Files/wkhtmltopdf/bin/wkhtmltoimage --quality 75  https://www.nowcoder.com d:/work/data/wk-images/3.png&quot;;        String cmd1 = &quot;D:/Program Files/wkhtmltopdf/bin/wkhtmltopdf https://www.nowcoder.com d:/work/data/wk-pdfs/1.pdf&quot;;        try &#123;            Runtime.getRuntime().exec(cmd1);            System.out.println(&quot;ok.&quot;);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n","categories":["讨论社区项目"]},{"title":"讨论社区42  -  热帖排行","url":"/2019/08/21/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA42%20-%20%E7%83%AD%E5%B8%96%E6%8E%92%E8%A1%8C/","content":"Hacker News\nScore = (P-1) / (T+2) ^G\nStackOverflow\n&#123; (log(Qviews)*4)  + ((Qanswers * Qscore) / 5)  + sum(Ascores) &#125;  /  &#123; ((QageInhours  + 1 )  -  (( QageInHours  -  Qupdated ) / 2)) ^ 1.5 &#125;\n牛客：\nlog(精华分 + 评论数 * 10 + 点赞数 * 2+ 收藏数 * 2) +（发布时间 - 牛客纪元）\n\n在发帖、加精、点赞、评论时计算帖子分数（存入Redis中）\n\n@Autowiredprivate RedisTemplate redisTemplate;// 发帖时 -- DiscussPostController// 计算帖子分数String redisKey = RedisKeyUtil.getPostScoreKey();redisTemplate.opsForSet().add(redisKey, post.getId());//加精时 -- DiscussPostController// 计算帖子分数String redisKey = RedisKeyUtil.getPostScoreKey();redisTemplate.opsForSet().add(redisKey, id);//点赞时 -- LikeControllerif(entityType == ENTITY_TYPE_POST) &#123;    // 计算帖子分数    String redisKey = RedisKeyUtil.getPostScoreKey();    redisTemplate.opsForSet().add(redisKey, postId);&#125;//评论时 -- CommentController// 计算帖子分数String redisKey = RedisKeyUtil.getPostScoreKey();redisTemplate.opsForSet().add(redisKey, discussPostId);\n\n\n\n\n新建PostScoreRefreshJob类进行处理\n\n","categories":["讨论社区项目"]},{"title":"讨论社区41  -  任务执行和调度","url":"/2019/08/20/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA41%20-%20%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E5%92%8C%E8%B0%83%E5%BA%A6/","content":"JDK线程池\nExecutorService\nScheduledExecutorService(可以执行定时任务)\n\n没有解决分布式部署的问题\n// JDK普通线程池private ExecutorService executorService = Executors.newFixedThreadPool(5);// JDK可执行定时任务的线程池private ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(5);// 1. JDK 普通线程池@Testpublic void testExecutorService()&#123;\tRunnable task = new Runnable() &#123;\t\t@Override\t\tpublic void run() &#123;\t\t\tlogger.debug(&quot;hello ExecutorService&quot;);\t\t&#125;\t&#125;;\tfor (int i = 0; i &lt; 10; i++) &#123;\texecutorService.submit(task);\t&#125;\tsleep(10000);\t&#125;// 2.JDK可执行定时任务的线程池@Testpublic void testScheduledExecutorService()&#123;\tRunnable task = new Runnable() &#123;\t\t@Override\t\tpublic void run() &#123;\t\t\tlogger.debug(&quot;hello ScheduledExecutorService&quot;);\t\t&#125;\t&#125;;\tscheduledExecutorService.scheduleAtFixedRate(task, 10000, 1000, TimeUnit.MILLISECONDS);\tsleep(10000);&#125;\n\n\n\nSpring 线程池\nThreadPoolTaskExecutor\nThreadPoolTaskScheduler（分布式环境可能出问题）\n\n正常版// 3. Spring 普通线程池@Testpublic void testThreadPoolExecutor()&#123;    Runnable task = new Runnable() &#123;        @Override        public void run() &#123;            logger.debug(&quot;hello ThreadPoolExecutor&quot;);        &#125;    &#125;;    for (int i = 0; i &lt; 10; i++) &#123;        threadPoolExecutor.submit(task);    &#125;    sleep(10000);&#125;// 4. Spring 可执行定时任务的线程池@Testpublic void testThreadPoolTaskScheduler()&#123;    Runnable task = new Runnable() &#123;        @Override        public void run() &#123;            logger.debug(&quot;hello ThreadPoolTaskScheduler&quot;);        &#125;    &#125;;    Date date = new Date(System.currentTimeMillis()+10000);    threadPoolTaskScheduler.scheduleAtFixedRate(task, date, 1000);    sleep(10000);&#125;\n\n简化版//service中定义// 让该方法在多线程环境下,被异步的调用.@Asyncpublic void execute1() &#123;\tlogger.debug(&quot;execute1&quot;);&#125;@Scheduled(initialDelay = 10000, fixedRate = 1000)public void execute2() &#123;\tlogger.debug(&quot;execute2&quot;);&#125;\n\n// 5.Spring普通线程池(简化)@Testpublic void testThreadPoolTaskExecutorSimple() &#123;    for (int i = 0; i &lt; 10; i++) &#123;        alphaService.execute1();    &#125;    sleep(10000);&#125;// 6.Spring定时任务线程池(简化)@Testpublic void testThreadPoolTaskSchedulerSimple() &#123;     sleep(30000);&#125;\n\n\n\n分布式定时任务http://www.quartz-scheduler.org\n\nSpring Quartz（将数据存储到数据库，分布式时可以共享数据）\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt;&lt;/dependency&gt;\n\n导入包之后还需要在数据库导入对应的表，可从Quartz-Github根据数据库类型选择下载。\nQuartz 表介绍​    Quartz的集群部署方案在架构上是分布式的，没有负责集中管理的节点，各节点间不会直接通信而是利用数据库锁的方式来实现集群环境下进行并发控制，所以Quartz集群化部署时必须要启用持久化配置。分布式部署时需要保证各个节点的系统时间一致。Quartz默认提供了11张表。\n​    本文使用的是tables_mysql_innodb.sql文件，它显示指定了使用innodb存储引擎，另一个tables_mysql.sql文件没有指定具体的存储引擎；本文将对这些张表做简单介绍。\n\n​    前面6张都是关于各种triggers的信息，后面包括job，日程表，调度节点状态，悲观锁等信息；相关表操作在类StdJDBCDelegate中，相关sql语句在StdJDBCConstants中；\n\n\n  1.qrtz_blob_triggers  \n  用户自定义的Trigger使用Blob类型进行trigger详细信息的存储（这样设计，JobStore更容易通用），非自定义的Trigger不会存放在此表中;\n  Quartz提供的triggers包括：CronTrigger，CalendarIntervalTrigger，  DailyTimeIntervalTrigger以及SimpleTrigger，这几个trigger信息会保存在后面的几张表中； \n   2.qrtz_cron_triggers \n  存储CronTrigger的详细信息，这也是我们使用最多的触发器, 包括cron表达式，时区信息等; Spring对应的封装CronTriggerFactoryBean\n  3.qrtz_simple_triggers  \n  存储SimpleTrigger的详细信息,  包括重复次数，重复间隔时间和已经执行的次数等\n  Spring对应的封装SimpleTriggerFactoryBean\n  4.qrtz_simprop_triggers\n  存储CalendarIntervalTrigger和DailyTimeIntervalTrigger两种类型的触发器\n  Spring没有对应的封装类，可能因为这两种不常用，且基本上可以用CronTrigger来实现\n  5.qrtz_triggers\n  存储所有Trigger(包括自带的4种Trigger和用户自定义Trigger)的通用动态信息；随着调度的触发preFireTime,nextFireTime, triggerState等都会相应的跟着变化\n  6.qrtz_fired_triggers\n  存储即将触发或正在触发的trigger相关信息，trigger随着时间的推移状态发生变化，直到最后trigger执行完成，从表中被删除\n  7.qrtz_job_details\n  存储jobDetails信息，相关信息在定义的时候指定，后续不会发生变化\n  8.qrtz_calendars\n   Quartz为我们提供了日历的功能，可以自己定义多个时间段，可以控制触发器在这个时间段内不触发或者触发；实际使用中一般是用于定义多个不触发的时间段，用于排除特殊日期，节假日等\n  系统提供6种类型：AnnualCalendar，CronCalendar，DailyCalendar，HolidayCalendar，MonthlyCalendar，WeeklyCalendar\n  9.qrtz_paused_trigger_grps\n  存储已暂停的Trigger组的信息，批量暂停Trigger时用到，不常用。\n  10.qrtz_scheduler_state\n  开启集群功能时，存储Scheduler实例名称，检查周期，各节点最后活跃时间等信息；Quartz集群下的故障转移就是借助这个表来实现的\n  11.qrtz_locks\n  Quartz提供的锁表，为多个节点调度提供分布式锁，实现分布式调度，默认有2个锁：STATE_ACCESS 主要用在scheduler定期检查是否有失效节点的时候，保证只有一个节点去检查和处理；\n  TRIGGER_ACCESS 主要用在Trigger触发和触发完成的时候，保证只有一个节点去执行相应的逻辑， 当然也可以通过配置让Trigger在获取任务时也加锁\n\n核心调度接口Scheduler\n\n定义任务的接口Job的execute方法\n\nJobdetail接口来配置Job的名字、组等\n\nTrigger接口配置Job的什么时候运行、运行频率\n\nQuartzConfig：配置 -&gt; 数据库 -&gt; 调用\nimport com.wx.talking.quartz.AlphaJob;import com.wx.talking.quartz.PostScoreRefreshJob;import org.quartz.JobDataMap;import org.quartz.JobDetail;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.scheduling.quartz.JobDetailFactoryBean;import org.springframework.scheduling.quartz.SimpleTriggerFactoryBean;// 配置 -&gt; 数据库 -&gt; 调用   //进第一次配置初始化到数据库@Configurationpublic class QuartzConfig &#123;    // FactoryBean可简化Bean的实例化过程:    // 1.通过FactoryBean封装Bean的实例化过程.    // 2.将FactoryBean装配到Spring容器里.    // 3.将FactoryBean注入给其他的Bean.    // 4.该Bean得到的是FactoryBean所管理的对象实例.    // 配置JobDetail    // @Bean    public JobDetailFactoryBean alphaJobDetail() &#123;        JobDetailFactoryBean factoryBean = new JobDetailFactoryBean();        factoryBean.setJobClass(AlphaJob.class);        factoryBean.setName(&quot;alphaJob&quot;);        factoryBean.setGroup(&quot;alphaJobGroup&quot;);        factoryBean.setDurability(true); // 设置任务是否持久保存        factoryBean.setRequestsRecovery(true); // 任务是否可恢复        return factoryBean;    &#125;    // 配置Trigger(SimpleTriggerFactoryBean, CronTriggerFactoryBean)    // @Bean    public SimpleTriggerFactoryBean alphaTrigger(JobDetail alphaJobDetail) &#123;        SimpleTriggerFactoryBean factoryBean = new SimpleTriggerFactoryBean();        factoryBean.setJobDetail(alphaJobDetail);        factoryBean.setName(&quot;alphaTrigger&quot;);        factoryBean.setGroup(&quot;alphaTriggerGroup&quot;);        factoryBean.setRepeatInterval(3000);        factoryBean.setJobDataMap(new JobDataMap());        return factoryBean;    &#125;&#125;\n\n\n\n\nFactoryBean可简化Bean的实例化过程:\n通过FactoryBean封装Bean的实例化过程\n将FactoryBean装配到Spring容器里\n将FactoryBean注入给其他的Bean.\n该Bean得到的是FactoryBean所管理的对象实例.\n\n\n\n","categories":["讨论社区项目"],"tags":["线程池"]},{"title":"讨论社区40  -  网站数据统计","url":"/2019/08/18/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA40%20-%20%E7%BD%91%E7%AB%99%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/","content":"UV(Unique Visitor)\n独立访客，需通过用户IP排重新统计数据。\n每次访问都要进行统计。\nHyperLoglog,性能好，且存储空间小。\n\nDAU(Daily Active User)\n日活跃用户，需通过用户ID排重新统计数据。\n访问过一次，则认为其为活跃。QW\nBitmap,性能好、且可以统计精确的结果。\n\n新建DataService类进行统计操作。表现层一分为二，首先是何时记录这个值，其次是查看。记录值在拦截器写比较合适。新建DataInterceptor和DataController。\n返回时使用forward转发，表明当前请求仅完成一半，还需另外一个方法继续处理请求。\n网站统计是管理员的功能，所以最后需要将访问权限定义给管理员\n","categories":["讨论社区项目"],"tags":["Redis","HyperLoglog"]},{"title":"讨论社区39  -  Redis高级数据类型","url":"/2019/08/16/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA39%20-%20Redis%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","content":"HyperLoglog\n采用一种基数算法，用于完成独立总数的统计。\n占据空间小，无论统计多少个数据，只占12K的内存空间。\n不精确的统计算法，标准误差为0.81%。\n\n// 统计20万个重复数据的独立总数@Testpublic void testHyperLogLog()&#123;    String redisKey = &quot;test:hll:01&quot;;    for(int i=0;i&lt;100000;i++)&#123;        redisTemplate.opsForHyperLogLog().add(redisKey,i);    &#125;    for(int i=0;i&lt;100000;i++)&#123;        int rd = (int) (Math.random() * 100000 +1);        redisTemplate.opsForHyperLogLog().add(redisKey,rd);    &#125;    long size = redisTemplate.opsForHyperLogLog().size(redisKey);    System.out.println(size);&#125;// 将3组数据合并，再统计合并后的重复数据的独立总数public void testHyperLogLogUnion()&#123;    String redisKey2 = &quot;test:hll:02&quot;;    for(int i=0;i&lt;100000;i++)&#123;        redisTemplate.opsForHyperLogLog().add(redisKey2,i);    &#125;    String redisKey3 = &quot;test:hll:02&quot;;    for(int i=0;i&lt;100000;i++)&#123;        redisTemplate.opsForHyperLogLog().add(redisKey3,i);    &#125;    String redisKey4 = &quot;test:hll:02&quot;;    for(int i=0;i&lt;100000;i++)&#123;        redisTemplate.opsForHyperLogLog().add(redisKey4,i);    &#125;    String unionKey = &quot;test:hll:union&quot;;    redisTemplate.opsForHyperLogLog().union(unionKey,redisKey2,redisKey3,redisKey4);    long size = redisTemplate.opsForHyperLogLog().size(unionKey);    System.out.println(size);&#125;\n\n\n\nBitmap\n不是一种独立的数据结构，实际上就是字符串。\n支持按位存取数据，可以将其看成是byte数组。\n适合存储大量的连续的数据的布尔值。\n\n如论坛签到？两种状态，用连续的01字符串存储\n// Bitmap 统计一组数据的bool值public void testBitMap()&#123;    String redisKey = &quot;test:bm:01&quot;;    // 记录    redisTemplate.opsForValue().setBit(redisKey,1,true);    redisTemplate.opsForValue().setBit(redisKey,4,true);    redisTemplate.opsForValue().setBit(redisKey,7,true);    // 查询    System.out.println(redisTemplate.opsForValue().getBit(redisKey,0));    System.out.println(redisTemplate.opsForValue().getBit(redisKey,1));    System.out.println(redisTemplate.opsForValue().getBit(redisKey,2));    // 统计    Object obj = redisTemplate.execute(new RedisCallback() &#123;        @Override        public Object doInRedis(RedisConnection redisConnection) throws DataAccessException &#123;            return redisConnection.bitCount(redisKey.getBytes());        &#125;    &#125;);    System.out.println(obj);&#125;// 统计3组数据的bool值，并对这3组数据做OR运算public void testBitMapOperation()&#123;    String redisKey2 = &quot;test:bm:02&quot;;    redisTemplate.opsForValue().setBit(redisKey2,0,true);    redisTemplate.opsForValue().setBit(redisKey2,1,true);    redisTemplate.opsForValue().setBit(redisKey2,0,true);    String redisKey3 = &quot;test:bm:03&quot;;    redisTemplate.opsForValue().setBit(redisKey3,2,true);    redisTemplate.opsForValue().setBit(redisKey3,3,true);    redisTemplate.opsForValue().setBit(redisKey3,4,true);    String redisKey4 = &quot;test:bm:04&quot;;    redisTemplate.opsForValue().setBit(redisKey4,4,true);    redisTemplate.opsForValue().setBit(redisKey4,5,true);    redisTemplate.opsForValue().setBit(redisKey4,6,true);    String redisKey = &quot;test:bm:or&quot;;    Object obj = redisTemplate.execute(new RedisCallback() &#123;        @Override        public Object doInRedis(RedisConnection redisConnection) throws DataAccessException &#123;            redisConnection.bitOp(RedisCommands.BitOperation.OR, redisKey.getBytes(), redisKey2.getBytes(),                    redisKey3.getBytes(), redisKey4.getBytes());            return redisConnection.bitCount(redisKey.getBytes());        &#125;    &#125;);    System.out.println(obj);    System.out.println(redisTemplate.opsForValue().getBit(redisKey,0));    System.out.println(redisTemplate.opsForValue().getBit(redisKey,1));    System.out.println(redisTemplate.opsForValue().getBit(redisKey,2));    System.out.println(redisTemplate.opsForValue().getBit(redisKey,3));    System.out.println(redisTemplate.opsForValue().getBit(redisKey,4));    System.out.println(redisTemplate.opsForValue().getBit(redisKey,5));    System.out.println(redisTemplate.opsForValue().getBit(redisKey,6));&#125;\n\n","categories":["讨论社区项目"],"tags":["Redis","HyperLoglog","Bitmap"]},{"title":"讨论社区38  -  置顶、加精、删除功能实现","url":"/2019/08/15/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA38%20-%20%E7%BD%AE%E9%A1%B6%E3%80%81%E5%8A%A0%E7%B2%BE%E3%80%81%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/","content":"功能实现\n点击“置顶”、“加精”、“删除”，修改帖子的状态\n在DiscussPostMapper增加修改方法\nDiscussPostService、DiscussPostController相应增加方法，注意在Es中同步变化\n要在EventConsumer增加消费删帖事件\n修改html和js文件\n\n\n\n// 修改帖子类型int updateType(int id, int type);\n\n// DiscussPostServicepublic int updateType(int id, int type) &#123;\treturn discussPostMapper.updateType(id, type);&#125;\n\n// DiscussPostController，还需要出发Es中的事件// 置顶@RequestMapping(path = &quot;/top&quot;, method = RequestMethod.POST)@ResponseBodypublic String setTop(int id) &#123;    discussPostService.updateType(id, 1);    // 触发发帖事件    Event event = new Event()            .setTopic(TOPIC_PUBLISH)            .setUserId(hostHolder.getUser().getId())            .setEntityType(ENTITY_TYPE_POST)            .setEntityId(id);    eventProducer.fireEvent(event);    return TalkingUtil.getJSONString(0);&#125;// 加精@RequestMapping(path = &quot;/wonderful&quot;, method = RequestMethod.POST)@ResponseBodypublic String setWonderful(int id) &#123;    discussPostService.updateStatus(id, 1);    // 触发发帖事件    Event event = new Event()            .setTopic(TOPIC_PUBLISH)            .setUserId(hostHolder.getUser().getId())            .setEntityType(ENTITY_TYPE_POST)            .setEntityId(id);    eventProducer.fireEvent(event);&#125;// 删除@RequestMapping(path = &quot;/delete&quot;, method = RequestMethod.POST)@ResponseBodypublic String setDelete(int id) &#123;    discussPostService.updateStatus(id, 2);    // 触发删帖事件    Event event = new Event()            .setTopic(TOPIC_DELETE)            .setUserId(hostHolder.getUser().getId())            .setEntityType(ENTITY_TYPE_POST)            .setEntityId(id);    eventProducer.fireEvent(event);    return TalkingUtil.getJSONString(0);&#125;\n\n// EventConsumer   Es中也要添加相应的消费事件// 消费发帖事件@KafkaListener(topics = &#123;TOPIC_PUBLISH&#125;)public void handlePublishMessage(ConsumerRecord record) &#123;    if (record == null || record.value() == null) &#123;        logger.error(&quot;消息的内容为空!&quot;);        return;    &#125;    Event event = JSONObject.parseObject(record.value().toString(), Event.class);    if (event == null) &#123;        logger.error(&quot;消息格式错误!&quot;);        return;    &#125;    DiscussPost post = discussPostService.findDiscussPostById(event.getEntityId());    elasticsearchService.saveDiscussPost(post);&#125;// 消费删帖事件@KafkaListener(topics = &#123;TOPIC_DELETE&#125;)public void handleDeleteMessage(ConsumerRecord record) &#123;    if (record == null || record.value() == null) &#123;        logger.error(&quot;消息的内容为空!&quot;);        return;    &#125;    Event event = JSONObject.parseObject(record.value().toString(), Event.class);    if (event == null) &#123;        logger.error(&quot;消息格式错误!&quot;);        return;    &#125;    elasticsearchService.deleteDiscussPost(event.getEntityId());&#125;\n\n\n\n权限管理\n版主可以执行“置顶”、“加精”操作。管理员可以执行“删除”操作。\n在SecurityConfig类下配置，置顶、加精、删除的访问权限。\n\n\n\nimport org.springframework.context.annotation.Configuration;import org.springframework.security.access.AccessDeniedException;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.builders.WebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.core.AuthenticationException;import org.springframework.security.web.AuthenticationEntryPoint;import org.springframework.security.web.access.AccessDeniedHandler;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter implements TalkingConstant &#123;    // 忽略静态资源的拦截    @Override    public void configure(WebSecurity web) &#123;        web.ignoring().antMatchers(&quot;/resources/**&quot;);    &#125;\t// 根据角色权限，添加访问路径    @Override    protected void configure(HttpSecurity http) throws Exception &#123;        // 授权        http.authorizeRequests()                .antMatchers(                        ...所有用户可访问路径...                )                .hasAnyAuthority(                        AUTHORITY_USER,                        AUTHORITY_ADMIN,                        AUTHORITY_MODERATOR                )                .antMatchers(                        ...版主可访问路径...                )                .hasAnyAuthority(                        AUTHORITY_MODERATOR                )                .antMatchers(                        ...管理员可访问路径...                )                .hasAnyAuthority(                        AUTHORITY_ADMIN                )                .anyRequest().permitAll()                .and().csrf().disable(); //禁用csrf检查        // 权限不够时的处理：未登录？权限不足？        http.exceptionHandling()                .authenticationEntryPoint(new AuthenticationEntryPoint() &#123;                    // 没有登录                    @Override                    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException e) throws IOException, ServletException &#123;                        // 获取请求体的字符串                        String xRequestedWith = request.getHeader(&quot;x-requested-with&quot;);                        // 请求为xml，则为异步请求                        if (&quot;XMLHttpRequest&quot;.equals(xRequestedWith)) &#123;                            response.setContentType(&quot;application/plain;charset=utf-8&quot;);                            PrintWriter writer = response.getWriter();                            writer.write(TalkingUtil.getJSONString(403, &quot;你还没有登录哦!&quot;));                        &#125; else &#123;// 普通请求                            response.sendRedirect(request.getContextPath() + &quot;/login&quot;);                        &#125;                    &#125;                &#125;)                .accessDeniedHandler(new AccessDeniedHandler() &#123;                    // 权限不足                    @Override                    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException e) throws IOException, ServletException &#123;                        String xRequestedWith = request.getHeader(&quot;x-requested-with&quot;);                        if (&quot;XMLHttpRequest&quot;.equals(xRequestedWith)) &#123;                            response.setContentType(&quot;application/plain;charset=utf-8&quot;);                            PrintWriter writer = response.getWriter();                            writer.write(TalkingUtil.getJSONString(403, &quot;你没有访问此功能的权限!&quot;));                        &#125; else &#123;                            response.sendRedirect(request.getContextPath() + &quot;/denied&quot;);                        &#125;                    &#125;                &#125;);        // Security底层默认会拦截/logout请求,进行退出处理.        // 覆盖它默认的逻辑/logout,才能执行我们自己的退出代码.        http.logout().logoutUrl(&quot;/securitylogout&quot;);    &#125;&#125;\n\n\n\n按钮显示\n版主可以看到“置顶”、“加精”按钮。管理员可以看到“删除“按钮。\n\n导包：thymeleaf-extras-springsecurity5，thymeleaf对security的支持。\n\n\n\n&lt;dependency&gt;    &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt;    &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt;&lt;/dependency&gt;\n\n  文档：https://github.com/thymeleaf/thymeleaf-extras-springsecurity\n&lt;!-- sec:authorize=&quot;hasAnyAuthority(&#x27;moderator&#x27;)&quot; 判断是否有权限 --&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-danger btn-sm&quot; id=&quot;topBtn&quot;        th:disabled=&quot;$&#123;post.type==1&#125;&quot; sec:authorize=&quot;hasAnyAuthority(&#x27;moderator&#x27;)&quot;&gt;置顶&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-danger btn-sm&quot; id=&quot;wonderfulBtn&quot;        th:disabled=&quot;$&#123;post.status==1&#125;&quot; sec:authorize=&quot;hasAnyAuthority(&#x27;moderator&#x27;)&quot;&gt;加精&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-danger btn-sm&quot; id=&quot;deleteBtn&quot;        th:disabled=&quot;$&#123;post.status==2&#125;&quot; sec:authorize=&quot;hasAnyAuthority(&#x27;admin&#x27;)&quot;&gt;删除&lt;/button&gt;\n\n","categories":["讨论社区项目"],"tags":["Spring Security"]},{"title":"讨论社区37  -  权限控制","url":"/2019/08/13/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA37%20-%20%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/","content":"导入security\n&lt;dependency&gt;   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;   &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;\n\n登录检查\n之前采用拦截器实现了登录检查，这是简单的权限管理方案，现在将废弃。\n修改WebMvcConfig，将loginRequiredInterceptor注释。\n\n\n\n授权配置\n对当前系统内的所有的请求，分配访问权限（普通用户、版主、管理员）。\n新建SecurityConfig类，配置静态资源都可以访问\n配置授权操作，以及权限不够时的处理\n\n\n\n认证方案\n绕过Security认证流程，采用系统原来的认证方案。\nSecurity底层默认会拦截/logout请求,进行退出处理。覆盖它默认的逻辑,才能执行我们自己的退出代码.\n这里没有用Security进行认证，需要将结果自己存入SecurityContext\nUserService增加查询用户权限方法 \n在LoginTicketInterceptor,构建用户认证的结果,并存入SecurityContext,以便于Security进行授权.请求之前需要存储用户认证信息、请求处理之后及退出系统需要将用户认证信息删除。\n\n\n\nCSRF配置\n防止CSRF攻击的基本原理，以及表单、AJAX的相关配置。\n\nCSRF攻击：某网站盗取你的Cookie（ticket）凭证，模拟你的身份访问服务器。（发生在提交表单的时候）\nSecurity会在表单里增加一个TOCKEN(自动生成)\n异步请求Security无法处理，在html文件生成CSRF令牌，（异步不是通过请求体传数据，通过请求头）\n发送AJAX请求之前,将CSRF令牌设置到请求的消息头中.\n\n&lt;!--访问该页面时,在此处生成CSRF令牌.--&gt;&lt;meta name=&quot;_csrf&quot; th:content=&quot;$&#123;_csrf.token&#125;&quot;&gt;&lt;meta name=&quot;_csrf_header&quot; th:content=&quot;$&#123;_csrf.headerName&#125;&quot;&gt;\n\n// 发送AJAX请求之前,将CSRF令牌设置到请求的消息头中.var token = $(&quot;meta[name=&#x27;_csrf&#x27;]&quot;).attr(&quot;content&quot;);    var header = $(&quot;meta[name=&#x27;_csrf_header&#x27;]&quot;).attr(&quot;content&quot;);    $(document).ajaxSend(function(e, xhr, options)&#123;    xhr.setRequestHeader(header, token);&#125;);\n\n\n\n","categories":["讨论社区项目"],"tags":["Spring Security"]},{"title":"讨论社区36  -  Spring Security","url":"/2019/08/12/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA36%20-%20Spring%20Security/","content":"https://sping.io/projects/spring-security\n学习文档：http://www.spring4all.com/article/428\n\n介绍\n简介\nSpring Security是一个专注与为Java应用程序提供身份认证和授权的框架，它的强大之处在于它可以轻松扩展以满足自定义的需求。\n\n\n特征\n对身份的认证和授权提供全面的、可扩展的支持。\n防止各种攻击，如会话固定攻击、点击劫持、csrf攻击等。\n支持与Servelt API、Spring MVC等Web技术集成。\n\n\n原理\n底层使用Filter（javaEE标准）进行拦截\nFilter–&gt;DispatchServlet–&gt;Interceptor–&gt;Controller(后三者属于Spring MVC)\n\n\n推荐学习网站：www.spring4all.com\n看几个核心的Filter源码\n\n\n\n使用\n导包：spring-boot-starter-security\n\nUser实体类实现UserDetails接口，实现接口中各方法（账号、凭证是否可用过期，管理权限）\n\nUserService实现UserDetailsService接口,实现接口方法（security检查用户是否登录时用到该接口）\n\n新建SecurityConfig类\n\n继承WebSecurityConfigurerAdapter\n配置忽略静态资源的访问\n实现认证的逻辑，自定义认证规则（AuthenticationManager: 认证的核心接口）\n登录相关配置\n退出相关配置\n\n\n委托模式: ProviderManager将认证委托给AuthenticationProvider.\n实现授权的逻辑\n授权配置\n增加Filter,处理验证码\n记住我\n\n\n\n\n重定向，浏览器访问A,服务器返回302，建议访问B.一般不能带数据给B（Session和Cookie）\n\n转发，浏览器访问A，A完成部分请求，存入Request,转发给B完成剩下请求。（有耦合）\n\n判断请求在服务端业务是否有耦合，在服务端A，B是独立业务则用重定向；否则使用转发。\n\n\n在HomeController添加认证逻辑\n\n认证成功后,结果会通过SecurityContextHolder存入SecurityContext中.\n\n\n\n\n\n","categories":["讨论社区项目"],"tags":["Spring","Spring Security"]},{"title":"讨论社区35  -  社区搜索功能实现","url":"/2019/08/10/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA35%20-%20%E7%A4%BE%E5%8C%BA%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/","content":"搜索服务\n将帖子保存至Elasticsearch服务器。\n对贴子实体类DiscussPost用注解进行相关配置\n从Mybatis取数据存入\n在dao层创建DiscussPostRepository类，继承ElasticsearchRepository接口即可，它集成了CRUD方法\n\n\n从Elasticsearch服务器删除帖子。\n从Elasticsearch服务器搜索帖子。\nEs可以在搜索到的词加标签，达到高亮显示\n利用elasticTemplate.queryForPage()查询\n\n\n\n发布事件\n发布帖子时，将帖子异步的提交到Elasticsearch服务器。\n新建ElasticsearchService类，定义CRUD和搜索方法。\n在DiscussPostController类发帖时，定义和触发发帖事件（Event、eventProducer.fireEvent(event)）\n\n\n增加评论时，将帖子异步的提交到Elasticsearch服务器。\n在CommentController类发表评论时，定义和触发发帖事件\n\n\n在消费组件中增加一个方法，消费帖子发布事件。\n在EventConsumer类增加消费发帖事件的方法\n在事件中查询帖子，存到Es服务器\n\n\n\n显示结果\n在控制器中处理搜索请求，在HTML上显示搜索结果。\n新建SearchController类处理搜索请求\n此时为GET请求，keyword的传入（search?keyword=xxx）\n修改index.html,表单提交路径，文本框name=”keyword”\n在search.html修改，遍历取到帖子。\n\n\n\nDEBUG\n记得要在kafka创建新的TOPIC,坑爹的debug了好久。\n\n","categories":["讨论社区项目"],"tags":["Elasticsearch"]},{"title":"讨论社区34  -  Spring整合Elasticsearch","url":"/2019/08/08/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA34%20-%20Spring%E6%95%B4%E5%90%88Elasticsearch/","content":"\n引入依赖\n\nspring-boot-starter-data-elasticsearch\n\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;&lt;/dependency&gt;\n\n配置Elasticsearch\n# ElasticSearchspring.data.elasticsearch.cluster-name=talking# 9200是http访问的端口，9300是tcp访问的端口spring.data.elasticsearch.cluster-nodes=127.0.0.1:9300\n\ncluster-name、cluster-nodes（集群的名字，节点）\n\nRedis和Es底层都用到了Netty,有启动冲突。解决：在TalkingApplication类加入初始化方法进行配置。\n\n\n@PostConstructpublic void init() &#123;    // 解决netty启动冲突问题    // see Netty4Utils.setAvailableProcessors()    System.setProperty(&quot;es.set.netty.runtime.available.processors&quot;, &quot;false&quot;);&#125;\n\n\n\n\nSpring Data Elasticsearch(调用API)\nElasticsearchTemplate（集成了Es的CRUD方法）\nElasticsearchRepository（接口，底层为ElasticsearchTemplate，用起来更方便）\n\n\n\n// 使用 ElasticsearchRepository@Testpublic void testSearchByRepository()&#123;    SearchQuery searchQuery = new NativeSearchQueryBuilder()    \t.withQuery(QueryBuilders.multiMatchQuery(&quot;test&quot;,&quot;title&quot;,&quot;content&quot;))    \t.withSort(SortBuilders.fieldSort(&quot;type&quot;).order(SortOrder.DESC))    \t.withSort(SortBuilders.fieldSort(&quot;score&quot;).order(SortOrder.DESC))    \t.withSort(SortBuilders.fieldSort(&quot;createTime&quot;).order(SortOrder.DESC))    \t.withPageable(PageRequest.of(0,10))    \t.withHighlightFields(    \t\tnew HighlightBuilder.Field(&quot;title&quot;).preTags(&quot;&lt;em&gt;&quot;).postTags(&quot;&lt;/em&gt;&quot;),    \t\tnew HighlightBuilder.Field(&quot;content&quot;).preTags(&quot;&lt;em&gt;&quot;).postTags(&quot;&lt;/em&gt;&quot;)    \t).build();    // elasticTemplate.queryForPage(searchQuery, class, SearchResultMapper)    // 底层获取得到了高亮显示的值, 但是没有返回.    Page&lt;DiscussPost&gt; page = discussPostRepository.search(searchQuery);    System.out.println(page.getTotalElements());    System.out.println(page.getTotalPages());    System.out.println(page.getNumber());    System.out.println(page.getSize());        for (DiscussPost post : page) &#123;    \tSystem.out.println(post);    &#125;&#125;\n\n@Testpublic void testSearchByTemplate() &#123;\tSearchQuery searchQuery = new NativeSearchQueryBuilder()    \t.withQuery(QueryBuilders.multiMatchQuery(&quot;互联网寒冬&quot;, &quot;title&quot;, &quot;content&quot;))        .withSort(SortBuilders.fieldSort(&quot;type&quot;).order(SortOrder.DESC))         .withSort(SortBuilders.fieldSort(&quot;score&quot;).order(SortOrder.DESC))         .withSort(SortBuilders.fieldSort(&quot;createTime&quot;).order(SortOrder.DESC))         .withPageable(PageRequest.of(0, 10))         .withHighlightFields(                 new HighlightBuilder.Field(&quot;title&quot;).preTags(&quot;&lt;em&gt;&quot;).postTags(&quot;&lt;/em&gt;&quot;),                 new HighlightBuilder.Field(&quot;content&quot;).preTags(&quot;&lt;em&gt;&quot;).postTags(&quot;&lt;/em&gt;&quot;)          ).build();        Page&lt;DiscussPost&gt; page = elasticTemplate.queryForPage(searchQuery, DiscussPost.class, new SearchResultMapper() &#123;        @Override        public &lt;T&gt; AggregatedPage&lt;T&gt; mapResults(SearchResponse response, Class&lt;T&gt; aClass, Pageable pageable) &#123;            SearchHits hits = response.getHits();            if (hits.getTotalHits() &lt;= 0) &#123;                    return null;                &#125;\t\t   //封装数据            List&lt;DiscussPost&gt; list = new ArrayList&lt;&gt;();            for (SearchHit hit : hits) &#123;            DiscussPost post = new DiscussPost();            String id = hit.getSourceAsMap().get(&quot;id&quot;).toString();            post.setId(Integer.valueOf(id));            String userId = hit.getSourceAsMap().get(&quot;userId&quot;).toString();            post.setUserId(Integer.valueOf(userId));            String title = hit.getSourceAsMap().get(&quot;title&quot;).toString();            post.setTitle(title);            String content = hit.getSourceAsMap().get(&quot;content&quot;).toString();            post.setContent(content);            String status = hit.getSourceAsMap().get(&quot;status&quot;).toString();            post.setStatus(Integer.valueOf(status));            String createTime = hit.getSourceAsMap().get(&quot;createTime&quot;).toString();            post.setCreateTime(new Date(Long.valueOf(createTime)));            String commentCount = hit.getSourceAsMap().get(&quot;commentCount&quot;).toString();            post.setCommentCount(Integer.valueOf(commentCount));            // 处理高亮显示的结果            HighlightField titleField = hit.getHighlightFields().get(&quot;title&quot;);            if (titleField != null) &#123;            \tpost.setTitle(titleField.getFragments()[0].toString());            &#125;            HighlightField contentField = hit.getHighlightFields().get(&quot;content&quot;);            if (contentField != null) &#123;            \tpost.setContent(contentField.getFragments()[0].toString());            &#125;            list.add(post);         &#125;            return new AggregatedPageImpl(list, pageable,                        hits.getTotalHits(), response.getAggregations(), response.getScrollId(), hits.getMaxScore());            &#125;            @Override            public &lt;T&gt; T mapSearchHit(SearchHit searchHit, Class&lt;T&gt; aClass) &#123;            \treturn null;            \t&#125;            &#125;);            System.out.println(page.getTotalElements());            System.out.println(page.getTotalPages());            System.out.println(page.getNumber());            System.out.println(page.getSize());            for (DiscussPost post : page) &#123;                System.out.println(post);            &#125;    &#125;\n\n匹配的结果是与高亮匹配相关的前后文，不会只高亮匹配显示所有text文本。\n","categories":["讨论社区项目"],"tags":["Spring","Elasticsearch"]},{"title":"讨论社区33  -  Elasticsearch入门","url":"/2019/08/06/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA33%20-%20Elasticsearch%E5%85%A5%E9%97%A8/","content":"https://elastic.co\nElasticsearch简介\n一个分布式的、Restful风格（请求标准的描述）的搜索引擎。\n支持对各种类型的数据的检索。\n搜索速度快，可以提供实时的搜索服务。\n便于水平扩展，每秒可以处理PB级海量数据。\n\n\n\nElasticsearch术语\n索引（对应数据库）、类型（对应表）、文档（表里一行）、字段（一列）。   最新的版本类型被废弃。                                                                                                                                                                                                                                                                                                                                                                                                                               \n集群(服务器组合在一起)、节点（集群中每台服务器）、分片（对索引的划分）、副本（分片的备份）。\n\n通过ES搜索的数据必须要在ES中转存一份，某种角度来说它是一个数据库。\nElasticsearch使用\n安装、修改配置文件\n\nelasticsearch.yml文件，修改cluster.name，path.data，path.logs\n\n# ----------------------------------- Paths ------------------------------------## Path to directory where to store the data (separate multiple locations by comma):#path.data: d:\\work\\data\\elasticsearch-6.4.3\\data## Path to log files:#path.logs: d:\\work\\data\\elasticsearch-6.4.3\\logs#\n\n\n配置环境变量\n\n\n\n\n安装中文分词插件（ES仅支持中文分词）\ngithub下载   https://github.com/medcl/elasticsearch-analysis-ik\n\nik插件安装（解压缩）到plugins文件夹下，注意版本对应\n\nconfig目录下IKAnalyzer.cfg.xml可以配置自定义词典\n\n\n\n安装postman(提交html数据给ES)模拟web客户端，或者在浏览器安装postman插件\n\n\n启动ES:打开 bin/elasticsearch.bat\n\n查看集群健康状态：curl -X GET “localhost:9200/_cat/health?v”\n\n查看节点：curl -X GET “localhost:9200/_cat/nodes?v”\n\n查看索引：curl -X GET “localhost:9200/_cat/indices?v”\n\n创建索引：curl -X PUT “localhost:9200/test”\n\n删除索引：curl -X DELETE “localhost:9200/test”\n\n\n\n\n\nPUT,GET,DELETE HTTP协议的请求\n\n使用postman查询\n提交数据，PUT localhost:9200/test/_doc/1选择Body,raw,JSON\n搜索，GET localhost:9200/test/_search?q=title(/content):xxx\n搜索时ES对关键词进行了分词\n通过请求体构造复杂搜索条件\n\n\n\n&lt;!--构造搜索条件  网址/索引名/_search?q=字段:字段名 --&gt;localhost:9200/test/_search?q=title:$&#123;search_condition&#125;&lt;!--构造复杂搜索条件  网址/索引名/_search 提交请求体为JSON数据 --&gt;localhost:9200/test/_search\n\n插入test的数据请求体为&#123;    &quot;title&quot;:&quot;...&quot;,    &quot;content&quot;:&quot;....&quot;&#125;复杂查询请求体为：&#123;&quot;query&quot;:&#123;&quot;multi_match&quot;:&#123;\t&quot;query&quot;: &quot;条件&quot;,\t&quot;fields&quot;: [&quot;title&quot;,&quot;content&quot;]\t\t\t&#125;&#125;&#125;\n\n","categories":["讨论社区项目"],"tags":["Elasticsearch"]},{"title":"讨论社区32  -  发送、显示系统通知","url":"/2019/08/05/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA32%20-%20%E5%8F%91%E9%80%81%E3%80%81%E6%98%BE%E7%A4%BA%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%9F%A5/","content":"发送系统通知\n触发事件\n评论后，发布通知\n点赞后，发布通知\n关注后，发布通知\n\n\n处理事件\n封装事件对象\n开发事件的生产者\n开发事件的消费者\n\n\n\n显示系统通知\n通知列表\n\n显示评论、点赞、关注三种类型的通知\n\n统一处理三种类型的通知\n\n通知详情\n\n分页显示某一类主题所包含的通知\n\n\n未读消息\n\n在页面头部显示所有的未读消息数量\n\n用拦截器处理，要注册拦截器\n@Componentpublic class MessageInterceptor implements HandlerInterceptor &#123;    @Autowired    private HostHolder hostHolder;    @Autowired    private MessageService messageService;    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;        User user = hostHolder.getUser();        if (user != null &amp;&amp; modelAndView != null) &#123;            int letterUnreadCount = messageService.findLetterUnreadCount(user.getId(), null);            int noticeUnreadCount = messageService.findNoticeUnreadCount(user.getId(), null);            modelAndView.addObject(&quot;allUnreadCount&quot;, letterUnreadCount + noticeUnreadCount);        &#125;    &#125;&#125;\n\n\n\n\n","categories":["讨论社区项目"],"tags":["Kafka"]},{"title":"讨论社区31  -  Spring整合Kafka","url":"/2019/08/04/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA31%20-%20Spring%E6%95%B4%E5%90%88Kafka/","content":"\n引入依赖\nspring-kafka\n\n\n\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;    &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n配置Kafka\n配置server、consumer\n\n\n\n# KafkaPropertiesspring.kafka.bootstrap-servers=localhost:9092# kafka/config下consumer.properties，默认group-id是test-consumer-groupspring.kafka.consumer.group-id=talking-consumer-groupspring.kafka.consumer.enable-auto-commit=truespring.kafka.consumer.auto-commit-interval=3000\n\n\n\n\n访问Kafka\n生产者kafkaTemplate.send(topic, data);\n消费者@KafkaListener(topics = &#123;&quot;test&quot;&#125;)public void handleMessage(ConsumerRecord record) &#123;&#125;\n\n\n\nimport org.apache.kafka.clients.consumer.ConsumerRecord;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.kafka.annotation.KafkaListener;import org.springframework.kafka.core.KafkaTemplate;import org.springframework.stereotype.Component;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTest@ContextConfiguration(classes = TalkingApplication.class)public class KafkaTests &#123;    @Autowired    private KafkaProducer kafkaProducer;    @Test    public void testKafka() &#123;        kafkaProducer.sendMessage(&quot;test&quot;, &quot;你好&quot;);        kafkaProducer.sendMessage(&quot;test&quot;, &quot;在吗&quot;);        try &#123;            Thread.sleep(1000 * 10);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;@Componentclass KafkaProducer &#123;    @Autowired    private KafkaTemplate kafkaTemplate;    public void sendMessage(String topic, String content) &#123;        kafkaTemplate.send(topic, content);    &#125;&#125;@Componentclass KafkaConsumer &#123;    @KafkaListener(topics = &#123;&quot;test&quot;&#125;)    public void handleMessage(ConsumerRecord record) &#123;        System.out.println(record.value());    &#125;&#125;\n\n","categories":["讨论社区项目"],"tags":["Spring","Kafka"]},{"title":"讨论社区30  -  Kafka入门","url":"/2019/08/03/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA30%20-%20Kafka%E5%85%A5%E9%97%A8/","content":"本项目中仅使用Kafka的消息系统\n\nKafka简介\nKafka是一个分布式的流媒体平台。\n应用：消息系统、日志收集、用户行为追踪、流式处理。\n\n\nKafka特点\n高吞吐量、消息持久化、高可靠性、高扩展性。\n\n\nKafka术语\nBroker、Zookeeper\nTopic、Partition、Offset\nLeader Replica 、Follower Replica\n\n\n\n下载地址：http://kafka.apache.org/downloads\n解压缩之后需要更改一些配置\nwindows 启动zookeeper和kafka（windows下启动报错，可以尝试直接删除日志文件夹重新启动）\nzookeeper-server-start.bat d:\\software\\kafka_2.12-2.3.0\\config\\zookeeper.propertieskafka-server-start.bat d:\\software\\kafka_2.12-2.3.0\\config\\server.properties\n\n\n\n创建一个test主题 分区\n\n查询是否创建成功\nD:\\software\\kafka_2.12-2.3.0\\bin\\windows&gt;kafka-topics.bat --list --bootstrap-server localhost:9092test\n\n生产者生产消息（重新开生产者终端）\nD:\\software\\kafka_2.12-2.3.0\\bin\\windows&gt;kafka-console-producer.bat --broker-list localhost:9092 --topic test&gt;hi&gt;hello world&gt;\n\n消费者消费消息（重新开消费者终端）\n# 从头开始消费D:\\software\\kafka_2.12-2.3.0\\bin\\windows&gt;kafka-console-consumer.bat --bootstrap-server localhost:9092 --topic test --from-beginninghihello world\n\n","categories":["讨论社区项目"],"tags":["Kafka"]},{"title":"讨论社区29  -  阻塞队列","url":"/2019/08/01/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA29%20-%20%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/","content":"BlockingQueue\n\n解决线程通信的问题。\n\n\n传统解决线程通信问题也可以使用Object中的 wait(),notify()方法等\n\n\n阻塞方法：put、take。\n\n\n\n生产者消费者模式\n没有缓存区域（阻塞队列），生产者和消费者速率不一致，会浪费CPU资源（生产&gt;消费？ 生产&lt;消费？）\n\n阻塞队列满了，生产者线程阻塞暂停生产，等待消费；阻塞队列空了，消费者线程阻塞暂停消费，等待生产。\n\n\n\n\n生产者：产生数据的线程。\n消费者：使用数据的线程。\n\n\n实现类\n\nArrayBlockingQueue\nLinkedBlockingQueue\nPriorityBlockingQueue、SynchronousQueue、DelayQueue等。\n\n\n\n/***  ArrayBlockingQueue 实现类 demo**/import java.util.Random;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.BlockingQueue;public class BlockingQueueTests &#123;    public static void main(String[] args) &#123;        BlockingQueue queue = new ArrayBlockingQueue(10);        new Thread(new Producer(queue)).start();        new Thread(new Consumer(queue)).start();        new Thread(new Consumer(queue)).start();        new Thread(new Consumer(queue)).start();    &#125;&#125;// 定义生产者的类，继承线程 Runnable接口，实现 run() 方法class Producer implements Runnable &#123;    private BlockingQueue&lt;Integer&gt; queue;    public Producer(BlockingQueue&lt;Integer&gt; queue) &#123;        this.queue = queue;    &#125;    @Override    public void run() &#123;        try &#123;            for (int i = 0; i &lt; 100; i++) &#123;                Thread.sleep(20);                queue.put(i);                System.out.println(Thread.currentThread().getName() + &quot;生产:&quot; + queue.size());            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;// 定义消费者的类，继承线程 Runnable接口，实现 run() 方法class Consumer implements Runnable &#123;    private BlockingQueue&lt;Integer&gt; queue;    public Consumer(BlockingQueue&lt;Integer&gt; queue) &#123;        this.queue = queue;    &#125;    @Override    public void run() &#123;        try &#123;            while (true) &#123;                Thread.sleep(new Random().nextInt(1000)); //消费者消费较慢                queue.take();                System.out.println(Thread.currentThread().getName() + &quot;消费:&quot; + queue.size());            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n","categories":["讨论社区项目"],"tags":["Redis"]},{"title":"讨论社区28  -  优化登录模块","url":"/2019/07/31/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA28%20-%20%E4%BC%98%E5%8C%96%E7%99%BB%E5%BD%95%E6%A8%A1%E5%9D%97/","content":"前面临时方案将验证码存储进Session，分布式部署场景会存在Session同步和共享的问题。\n\n使用Redis存储验证码\n验证码需要频繁的访问与刷新，对性能要求较高。\n验证码不需永久保存，通常在很短的时间后就会失效。\n分布式部署时，绕过Session共享的问题。\n\n\n\n\n使用Redis存储登录凭证\n处理每次请求时，都要查询用户的登录凭证，访问的频率非常高。\n\n\n\n\n登录凭证使用频率高，关系型数据库存储登录凭证，每一次都要重新查询，影响性能。\n\n重构 UserService   登录成功保存凭证，退出时需删除凭证，查询凭证\n\n退出删除并不是真的删除，而是将登录凭证的状态值改为1，为将来扩展预留。如第一次登录？\n\n\n使用Redis缓存用户信息\n处理每次请求时，都要根据凭证查询用户信息，访问的频率非常高。\n\n\n\n重构 UserService\n查询过程：尝试从缓存中取值，若取不到说明没有初始化进Redis中，需要初始化。\n​        改变用户数据之后，需要更新缓存：1.更新缓存，更新操作麻烦且可能存在用户数据并发的问题；2.删除缓存，下一次请求重新初始化\n// 1.优先从缓存中取值private User getCache(int userId) &#123;    String redisKey = RedisKeyUtil.getUserKey(userId);    return (User) redisTemplate.opsForValue().get(redisKey);&#125;// 2.取不到时初始化缓存数据private User initCache(int userId) &#123;    User user = userMapper.selectById(userId);    String redisKey = RedisKeyUtil.getUserKey(userId);    redisTemplate.opsForValue().set(redisKey, user, 3600, TimeUnit.SECONDS);    return user;&#125;// 3.数据变更时清除缓存数据private void clearCache(int userId) &#123;    String redisKey = RedisKeyUtil.getUserKey(userId);    redisTemplate.delete(redisKey);&#125;\n\n","categories":["讨论社区项目"],"tags":["Redis"]},{"title":"讨论社区27  -  关注相关功能实现","url":"/2019/07/29/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA27%20-%20%E5%85%B3%E6%B3%A8%E5%92%8C%E5%8F%96%E6%B6%88%E5%85%B3%E6%B3%A8%E5%AE%9E%E7%8E%B0/","content":"开发时应考虑性能问题：用户关注另一用户、帖子等，如何做到实时响应，实时获取？\n——数据存到Redis中，提升性能。\n为什么使用Redis实现这个功能？\n关注、取消关注\n需求\n开发关注、取消关注功能。\n统计用户的关注数、粉丝数。\n\n\n关注\n若A关注了B，则A是B的Follower（粉丝），B是A的Followee（目标）。\n关注的目标可以是用户、帖子、题目等，在实现时将这些目标抽象为实体。\n\n\n\n关注列表、粉丝列表\n业务层\n查询某个用户关注的人，支持分页。\n查询某个用户的粉丝，支持分页。\n\n\n表现层\n处理“查询关注的人”、“查询粉丝”请求。\n编写“查询关注的人”、“查询粉丝”模板。\n\n\n\n","categories":["讨论社区项目"],"tags":["Redis"]},{"title":"讨论社区26  -  点赞功能和收到赞实现","url":"/2019/07/28/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA26%20-%20%E7%82%B9%E8%B5%9E%E5%8A%9F%E8%83%BD%E5%92%8C%E6%94%B6%E5%88%B0%E8%B5%9E%E5%AE%9E%E7%8E%B0/","content":"开发时应考虑性能问题：很多用户对同一帖子或回复点赞。——数据存到Redis中，提升性能。\n为什么使用Redis实现这个功能？\n点赞\n点赞\n支持对帖子、评论点赞。\n第1次点赞，第2次取消点赞。\n\n\n首页点赞数量\n统计帖子的点赞数量。\n\n\n详情页点赞数量\n统计点赞数量。\n显示点赞状态。\n\n\n\n无需再写DAO层，直接在Service实现，然后通过RedisConfig文件操作。\n\n\n\n\n我收到的赞可以基于上面的点赞数据实现去统计，但是需要统计所有帖子，然后针对帖子去统计赞，业务繁杂。\n一般采用下面的方式：\n\n重构点赞功能\n以用户为key，记录点赞数量\nincrement(key)，decrement(key)\n\n\n\n\n开发个人主页\n以用户为key，查询点赞数量\n\n\n\n","categories":["讨论社区项目"],"tags":["Redis"]},{"title":"讨论社区25  -  Spring整合Redis","url":"/2019/07/27/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA25%20-%20Spring%E6%95%B4%E5%90%88Redis/","content":"\n引入依赖\n\nspring-boot-starter-data-redis\n\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;    &lt;!--包含在spring boot中可以不用写VersionId，已做好兼容--&gt;&lt;/dependency&gt;\n\n配置Redis\n\n配置数据库参数\n编写配置类，构造RedisTemplate\n\n# RedisPropertiesspring.redis.database=1spring.redis.host=localhostspring.redis.port=6379\n\nimport org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.RedisSerializer;@Configurationpublic class RedisConfig &#123;    @Bean    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory)&#123;        RedisTemplate&lt;String, Object&gt;  template = new RedisTemplate&lt;String, Object&gt;();        template.setConnectionFactory(factory);        // 设置key的序列化方式        template.setKeySerializer(RedisSerializer.string());        // 设置value的序列化方式        template.setValueSerializer(RedisSerializer.json());        // 设置hash的key的序列化方式        template.setHashKeySerializer(RedisSerializer.string());        // 设置hash的value的序列化方式        template.setHashValueSerializer(RedisSerializer.json());        template.afterPropertiesSet();        return template;    &#125;&#125;\n\n访问Redis\n\nredisTemplate.opsForValue()\nredisTemplate.opsForHash()\nredisTemplate.opsForList()\nredisTemplate.opsForSet()\nredisTemplate.opsForZSet()\n\n\n\n多次访问一个redisKey可以做绑定操作\n// 多次访问同一个key@Testpublic void testBoundOperations() &#123;    String redisKey = &quot;test:count&quot;;    BoundValueOperations operations = redisTemplate.boundValueOps(redisKey);    operations.increment();    operations.increment();    operations.increment();    operations.increment();    operations.increment();    System.out.println(operations.get());&#125;\n\nRedis的事务处理\n// 编程式事务@Testpublic void testTransactional() &#123;    Object obj = redisTemplate.execute(new SessionCallback() &#123;    @Override    public Object execute(RedisOperations operations) throws DataAccessException &#123;        String redisKey = &quot;test:tx&quot;;        operations.multi();        operations.opsForSet().add(redisKey, &quot;zhangsan&quot;);        operations.opsForSet().add(redisKey, &quot;lisi&quot;);        operations.opsForSet().add(redisKey, &quot;wangwu&quot;);        \t\t//立即查询不会得出结果        System.out.println(operations.opsForSet().members(redisKey));        // 提交事务        return operations.exec();        &#125;    &#125;);        System.out.println(obj);&#125;\n\n","categories":["讨论社区项目","编程笔记"],"tags":["Spring","Redis"]},{"title":"找不到请求的.Net Framework Data Provider.可能没有安装.  错误","url":"/2019/07/27/%E6%89%BE%E4%B8%8D%E5%88%B0%E8%AF%B7%E6%B1%82%E7%9A%84-Net-Framework-Data-Provider-%E5%8F%AF%E8%83%BD%E6%B2%A1%E6%9C%89%E5%AE%89%E8%A3%85-%E9%94%99%E8%AF%AF/","content":"问题：这几天在装.NET 的开发环境，在装好VS2013和Oracle 11g之后，做了一个测试项目，运行调试没问题但是涉及到数据库相关操作，如新建数据集、连接数据库等在调试的时候则会出现如下错误：\n\n目前百度之后现存的解决方案：\noracle odp.net 32位/64位版本的问题解决方案链接；当然如果觉得这篇写的不怎么清楚，还可以点击 这里*（我碰到的就是这个问题，但是据博主提供的方法没有解决问题）*\n\nMicrosoft SQL Server Compact 4.0没有安装 这个问题是比较好解决的，只用安装Microsoft SQL Server Compact4.0即可，具体可以点击这里\n\n还有修改machine.config配置文件的方法，大家也可以尝试点击这里\n当然如果你的数据库使用的Oracle，节点配置的时候需要根据实际情况做出调整。具体文件配置路径：C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\Config下面的machine.config用记事本打开，查看下列节点是否存在oracle的相关配置\n&lt;system.data&gt;    &lt;DbProviderFactories&gt;      &lt;add name&#x3D;&quot;ODP.NET, Managed Driver&quot; invariant&#x3D;&quot;Oracle.ManagedDataAccess.Client&quot; description&#x3D;&quot;Oracle Data Provider for .NET, Managed Driver&quot; type&#x3D;&quot;Oracle.ManagedDataAccess.Client.OracleClientFactory, Oracle.ManagedDataAccess, Version&#x3D;4.121.2.0, Culture&#x3D;neutral, PublicKeyToken&#x3D;89b483f429c47342&quot; &#x2F;&gt;      &lt;add name&#x3D;&quot;Microsoft SQL Server Compact Data Provider 4.0&quot; invariant&#x3D;&quot;System.Data.SqlServerCe.4.0&quot; description&#x3D;&quot;.NET Framework Data Provider for Microsoft SQL Server Compact&quot; type&#x3D;&quot;System.Data.SqlServerCe.SqlCeProviderFactory, System.Data.SqlServerCe, Version&#x3D;4.0.0.0, Culture&#x3D;neutral, PublicKeyToken&#x3D;89845dcd8080cc91&quot; &#x2F;&gt;    &lt;&#x2F;DbProviderFactories&gt;  &lt;&#x2F;system.data&gt;\n\n新添加的应该是这一块：\n&lt;add name&#x3D;&quot;ODP.NET, Managed Driver&quot; invariant&#x3D;&quot;Oracle.ManagedDataAccess.Client&quot; description&#x3D;&quot;Oracle Data Provider for .NET, Managed Driver&quot; type&#x3D;&quot;Oracle.ManagedDataAccess.Client.OracleClientFactory, Oracle.ManagedDataAccess, Version&#x3D;4.121.2.0, Culture&#x3D;neutral, PublicKeyToken&#x3D;89b483f429c47342&quot; &#x2F;&gt;\n\n个人解决方案前面说过了，我尝试了上述的一些办法之后仍然没有解决问题，熬不住了我就去csdn的论坛发了帖，等了半个小时没人回复（可能是积分太少吧），无奈我就自己继续鼓捣了。想起来自己有一个 ODAC 12c的安装包，就直接点击安装了，安装完成之后重启VS，继续新建项目，配置数据库，调试之后竟然没有再继续报错，也就是说这个问题被我糊里糊涂解决了，哈哈哈~\n写一篇记录一下，给各位一个借鉴也给自己一个教训。下面提供ODAC 12c的下载地址\n官方下载地址：x64下载、x86下载\n如果没有oracle账号又或是账号无法登陆，可以通过这个链接下载， 密码：amvz\n\n\n","categories":["编程笔记"],"tags":[".Net"]},{"title":"讨论社区24  -  Redis入门","url":"/2019/07/25/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA24%20-%20Redis%E5%85%A5%E9%97%A8/","content":"\nRedis是一款基于键值对的NoSQL数据库，它的值支持多种数据结构：字符串(strings)、哈希(hashes)、列表(lists)、集合(sets)、有序集合(sorted sets)等。\n\nredis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。\n这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。\n\n\nRedis将所有的数据都存放在内存中，所以它的读写性能十分惊人。同时，Redis还可以将内存中的数据以快照或日志的形式保存到硬盘上，以保证数据的安全性。\n\n\n\nRDB  体积小。以快照形式存储到硬盘比较耗时，也会对进程造成阻塞，故可以隔一段时间执行\nAOF  可以实时存储。以日志形式存储Redis命令，是以追加日志的方式，占磁盘空间，恢复则是重复执行所有的记录命令，恢复速度较差。\n\n\nRedis典型的应用场景包括：缓存、排行榜、计数器、社交网络、消息队列等。\n\nLinux安装\n官网下载压缩包安装  http://download.redis.io/releases/redis-3.0.0.tar.gz\n通过wget命令下载安装\n\n# 下载之后解压到/usr/local路径，进入redis文件夹，make编译安装wget http://download.redis.io/releases/redis-3.0.0.tar.gztar -xvzf redis-3.0.0.tar.gz /usr/localcd redis-3.0.0make PREFIX=/usr/local/redis install\n\n启动redis服务端\n# 前台启动，终端关闭，服务端就关闭./redis-server# 推荐使用下面的后台启动，终端关闭，服务端不会关闭# 修改conf文件，将daemonize改为yesvim /usr/local/redis/bin/redis.conf# 启动redis服务端cd /usr/local/redis./bin/redis-server ./redis.conf\n\n启动redis客户端\n/usr/local/redis/bin/redis-cli \n\nWindows 安装https://github.com/microsoftarchive/redis/releases/download/win-3.2.100/Redis-x64-3.2.100.msi\n一路点击下一步即可安装，建议将安装路径添加到环境变量。\ncmd  $ redis-cli  启动redis客户端\n使用redis键值对的管理和操作1 DEL key该命令用于在 key 存在时删除 key。2 DUMP key序列化给定 key ，并返回被序列化的值。3 EXISTS key检查给定 key 是否存在。4 EXPIRE key seconds为给定 key 设置过期时间。5 EXPIREAT key timestampEXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。6 PEXPIRE key milliseconds设置 key 的过期时间以毫秒计。7 PEXPIREAT key milliseconds-timestamp设置 key 过期时间的时间戳(unix timestamp) 以毫秒计8 KEYS pattern查找所有符合给定模式( pattern)的 key 。9 MOVE key db将当前数据库的 key 移动到给定的数据库 db 当中。10 PERSIST key移除 key 的过期时间，key 将持久保持。11 PTTL key以毫秒为单位返回 key 的剩余的过期时间。12 TTL key以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。13 RANDOMKEY从当前数据库中随机返回一个 key 。14 RENAME key newkey修改 key 的名称15 RENAMENX key newkey仅当 newkey 不存在时，将 key 改名为 newkey 。16 TYPE key返回 key 所储存的值的类型。\n\nredis哈希的操作HDEL key field2 [field2] 删除一个或多个哈希表字段HEXISTS key field 查看哈希表 key 中，指定的字段是否存在。HGET key field 获取存储在哈希表中指定字段的值。HGETALL key 获取在哈希表中指定 key 的所有字段和值HINCRBY key field increment 为哈希表 key 中的指定字段的整数值加上增量 increment 。HINCRBYFLOAT key field increment 为哈希表 key 中的指定字段的浮点数值加上增量 increment 。HKEYS key 获取所有哈希表中的字段HLEN key 获取哈希表中字段的数量HMGET key field1 [field2] 获取所有给定字段的值HMSET key field1 value1 [field2 value2 ] 同时将多个 field-value (域-值)对设置到哈希表 key 中。HSET key field value 将哈希表 key 中的字段 field 的值设为 value 。HSETNX key field value 只有在字段 field 不存在时，设置哈希表字段的值。HVALS key 获取哈希表中所有值HSCAN key cursor [MATCH pattern] [COUNT count] 迭代哈希表中的键值对。\n\nredis列表操作BLPOP key1 [key2 ] timeout 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。BRPOP key1 [key2 ] timeout 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。BRPOPLPUSH source destination timeout 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。LINDEX key index 通过索引获取列表中的元素LINSERT key BEFORE|AFTER pivot value 在列表的元素前或者后插入元素LLEN key 获取列表长度LPOP key 移出并获取列表的第一个元素LPUSH key value1 [value2] 将一个或多个值插入到列表头部LPUSHX key value 将一个或多个值插入到已存在的列表头部LRANGE key start stop 获取列表指定范围内的元素LREM key count value 移除列表元素LSET key index value 通过索引设置列表元素的值LTRIM key start stop 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。RPOP key 移除并获取列表最后一个元素RPOPLPUSH source destination 移除列表的最后一个元素，并将该元素添加到另一个列表并返回RPUSH key value1 [value2] 在列表中添加一个或多个值RPUSHX key value 为已存在的列表添加值\n\nredis集合SADD key member1 [member2] 向集合添加一个或多个成员SCARD key 获取集合的成员数SDIFF key1 [key2] 返回给定所有集合的差集SDIFFSTORE destination key1 [key2] 返回给定所有集合的差集并存储在 destination 中SINTER key1 [key2] 返回给定所有集合的交集SINTERSTORE destination key1 [key2] 返回给定所有集合的交集并存储在 destination 中SISMEMBER key member 判断 member 元素是否是集合 key 的成员SMEMBERS key 返回集合中的所有成员SMOVE source destination member 将 member 元素从 source 集合移动到 destination 集合SPOP key 移除并返回集合中的一个随机元素SRANDMEMBER key [count] 返回集合中一个或多个随机数SREM key member1 [member2] 移除集合中一个或多个成员SUNION key1 [key2] 返回所有给定集合的并集SUNIONSTORE destination key1 [key2] 所有给定集合的并集存储在 destination 集合中SSCAN key cursor [MATCH pattern] [COUNT count] 迭代集合中的元素\n\n有序集合ZADD key score1 member1 [score2 member2] 向有序集合添加一个或多个成员，或者更新已存在成员的分数ZCARD key 获取有序集合的成员数ZCOUNT key min max 计算在有序集合中指定区间分数的成员数ZINCRBY key increment member 有序集合中对指定成员的分数加上增量 incrementZINTERSTORE destination numkeys key [key ...] 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中ZLEXCOUNT key min max 在有序集合中计算指定字典区间内成员数量ZRANGE key start stop [WITHSCORES] 通过索引区间返回有序集合成指定区间内的成员ZRANGEBYLEX key min max [LIMIT offset count] 通过字典区间返回有序集合的成员ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT] 通过分数返回有序集合指定区间内的成员ZRANK key member 返回有序集合中指定成员的索引ZREM key member [member ...] 移除有序集合中的一个或多个成员ZREMRANGEBYLEX key min max 移除有序集合中给定的字典区间的所有成员ZREMRANGEBYRANK key start stop 移除有序集合中给定的排名区间的所有成员ZREMRANGEBYSCORE key min max 移除有序集合中给定的分数区间的所有成员ZREVRANGE key start stop [WITHSCORES] 返回有序集中指定区间内的成员，通过索引，分数从高到底ZREVRANGEBYSCORE key max min [WITHSCORES] 返回有序集中指定分数区间内的成员，分数从高到低排序ZREVRANK key member 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序ZSCORE key member 返回有序集中，成员的分数值ZUNIONSTORE destination numkeys key [key ...] 计算给定的一个或多个有序集的并集，并存储在新的 key 中ZSCAN key cursor [MATCH pattern] [COUNT count] 迭代有序集合中的元素（包括元素成员和元素分值）\n\nredis事务的实现DISCARD 取消事务，放弃执行事务块内的所有命令。EXEC 执行所有事务块内的命令。MULTI 标记一个事务块的开始。UNWATCH 取消 WATCH 命令对所有 key 的监视。WATCH key [key ...] 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。\n\n\n\n\n\nhttps://redis.io\nhttps://github.com/microsoftarchive/redis\n","categories":["讨论社区项目","编程笔记"],"tags":["Redis","NoSQL"]},{"title":"讨论社区23  -  统一记录日志","url":"/2019/07/22/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA23%20-%20%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86%E6%97%A5%E5%BF%97/","content":"需求：\n\n帖子模块\n评论模块\n消息模块\n\nAOP的概念：\n\nAspect Oriented Programing，即面向方面（切面）编程。\nAOP是一种编程思想，是对OOP的补充，可以进一步提高编程的效率。\n\n\nAOP的术语：\n\n每一个Bean称为一个Target，目标对象上有多处可以织入代码，可织入的点称为Joinpoint，AOP解决统一处理需求的方式是将代码定义到切片组件Aspect中，Aspect要通过Pointcut知道哪些位置需要织入代码，最后需要Advice处理通知。\nAOP的实现\n\nAspectJ\n\nAspectJ是语言级的实现，它扩展了Java语言，定义了AOP语法。\nAspectJ在编译期织入代码，它有一个专门的编译器，用来生成遵守Java字节码规范的class文件。\n\n\nSpring AOP\n\nSpring AOP使用纯Java实现，它不需要专门的编译过程，也不需要特殊的类装载器。\nSpring AOP在运行时通过代理的方式织入代码，只支持方法类型的连接点。\nSpring支持对AspectJ的集成。\n\nSpring AOP 是一个高性价比的AOP实现技术。\n\n\nSpring AOP\n\nJDK动态代理\nJava提供的动态代理技术，可以在运行时创建接口的代理实例。\nSpring AOP默认采用此种方式，在接口的代理实例中织入代码。\n\n\nCGLib动态代理\n采用底层的字节码技术，在运行时创建子类代理实例。\n当目标对象不存在接口时，Spring AOP会采用此种方式，在子类实例中织入代码。\n\n\n\nimport org.aspectj.lang.ProceedingJoinPoint;import org.springframework.stereotype.Component;import org.aspectj.lang.annotation.*;@Component@Aspectpublic class AlphaAspect &#123;    // service 包下所有class的所有方法及所有返回值    @Pointcut(&quot;execution(* com.wx.talking.service.*.*(..))&quot;)    public void pointcut() &#123;    &#125;    @Before(&quot;pointcut()&quot;)    public void before() &#123;        System.out.println(&quot;before&quot;);    &#125;    @After(&quot;pointcut()&quot;)    public void after() &#123;        System.out.println(&quot;after&quot;);    &#125;    @AfterReturning(&quot;pointcut()&quot;)    public void afterReturning() &#123;        System.out.println(&quot;afterReturning&quot;);    &#125;    @AfterThrowing(&quot;pointcut()&quot;)    public void afterThrowing() &#123;        System.out.println(&quot;afterThrowing&quot;);    &#125;    @Around(&quot;pointcut()&quot;)    public Object around(ProceedingJoinPoint joinPoint) throws Throwable &#123;        System.out.println(&quot;around before&quot;);        Object obj = joinPoint.proceed(); //Target的方法        System.out.println(&quot;around after&quot;);        return obj;    &#125;&#125;\n\n","categories":["讨论社区项目","编程笔记"],"tags":["日志处理","Spring AOP"]},{"title":"讨论社区22  -  统一处理异常","url":"/2019/07/20/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA22%20-%20%E7%BB%9F%E4%B8%80%E8%AE%B0%E5%BD%95%E5%BC%82%E5%B8%B8/","content":"SpringBoot 的统一处理方法：\n在template文件夹下包含error文件夹，且内容为错误代码.html文件。 template/error/404.html\n\n@ControllerAdvice\n用于修饰类，表示该类是Controller的全局配置类。\n在此类中，可以对Controller进行如下三种全局配置：异常处理方案、绑定数据方案、绑定参数方案。\n\n\n@ExceptionHandler\n用于修饰方法，该方法会在Controller出现异常后被调用，用于处理捕获到的异常。\n\n\n@ModelAttribute\n用于修饰方法，该方法会在Controller方法执行前被调用，用于为Model对象绑定参数。\n\n\n@DataBinder\n用于修饰方法，该方法会在Controller方法执行前被调用，用于绑定参数的转换器。\n\n\n\n// 在Controller出现异常后被调用@ControllerAdvice(annotations = Controller.class)public class ExceptionAdvice &#123;    private static final Logger logger = LoggerFactory.getLogger(ExceptionAdvice.class);    @ExceptionHandler(&#123;Exception.class&#125;)    public void handleException(Exception e, HttpServletRequest request, HttpServletResponse response) throws IOException &#123;        logger.error(&quot;服务器发生异常: &quot; + e.getMessage());        for (StackTraceElement element : e.getStackTrace()) &#123;            logger.error(element.toString());        &#125;        //返回的是异步请求？普通请求        String xRequestedWith = request.getHeader(&quot;x-requested-with&quot;);         if (&quot;XMLHttpRequest&quot;.equals(xRequestedWith)) &#123;            response.setContentType(&quot;application/plain;charset=utf-8&quot;);            PrintWriter writer = response.getWriter();            //...转成JSON对象反馈给视图....            writer.write(getJSONString(1, &quot;服务器异常!&quot;));        &#125; else &#123;            response.sendRedirect(request.getContextPath() + &quot;/error&quot;);        &#125;    &#125;&#125;\n\n","categories":["讨论社区项目","编程笔记"],"tags":["注解","异常处理"]},{"title":"讨论社区21  -  私信列表和发送私信","url":"/2019/07/18/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA21%20-%20%E7%A7%81%E4%BF%A1%E5%88%97%E8%A1%A8%E5%92%8C%E5%8F%91%E9%80%81%E7%A7%81%E4%BF%A1/","content":"表结构\nCREATE TABLE &#96;message&#96; (  &#96;id&#96; int NOT NULL AUTO_INCREMENT,  &#96;from_id&#96; int DEFAULT NULL,  &#96;to_id&#96; int DEFAULT NULL,  &#96;conversation_id&#96; varchar(100) DEFAULT NULL,  &#96;content&#96; text,  &#96;status&#96; int DEFAULT NULL COMMENT &#39;&#39;&#39;0-未读;1-已读;2-删除;&#39;&#39;&#39;,  &#96;create_time&#96; timestamp NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,  PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;\n\nid 为表主键，from_id 、to_id 发送人、接收人；conversation_id 为冗余的会话id，便于查询，拼接规则是 from_id-to_id （但是小id在前，大id在后）；content为会话内容；status为会话状态。\n注：系统或超级管理员在表中user_id为1，所以在查询的时候，from_id为1的会话是系统下发的通知。\n发送私信\n发送私信\n采用异步的方式发送私信。\n发送成功后刷新私信列表。\n\n\n设置已读\n访问私信详情时，将显示的私信设置为已读状态。\n\n\n\n私信列表\n私信列表\n查询当前用户的会话列表\n每个会话只显示一条最新的私信。\n支持分页显示。\n\n\n私信详情\n查询某个会话所包含的私信。\n支持分页显示。\n\n\n\n","categories":["讨论社区项目"]},{"title":"讨论社区20  -  显示、添加评论","url":"/2019/07/16/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA20%20-%20%E6%98%BE%E7%A4%BA%E3%80%81%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA/","content":"显示评论\n数据层\n\n根据实体查询一页评论数据。\n根据实体查询评论的数量。\n\n\n业务层\n\n处理查询评论的业务。\n处理查询评论数量的业务。\n\n\n表现层\n\n显示帖子详情数据时，同时显示该帖子所有的评论数据。\n\n层层封装\n\n\n添加评论\n数据层\n\n增加评论数据。\n修改帖子的评论数量。\n\n\n业务层\n\n处理添加评论的业务：先增加评论、再更新帖子的评论数量。\n\n使用声明式事务\n\n表现层\n\n处理添加评论数据的请求。\n设置添加评论的表单。\n\n\n\n","categories":["讨论社区项目"]},{"title":"讨论社区19  -  事务管理","url":"/2019/07/14/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA19%20-%20%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/","content":"\n回顾\n\n什么是事务\n事务是由N步数据库操作序列组成的逻辑执行单元，这系列操作要么全执行，要么全放弃执行。\n\n\n事务的特性（ACID）\n原子性（Atomicity）：事务是应用中不可再分的最小执行体。\n一致性（Consistency）：事务执行的结果，须使数据从一个一致性状态，变为另一个一致性状态。\n隔离性（Isolation）：各个事务的执行互不干扰，任何事务的内部操作对其他的事务都是隔离的。\n持久性（Durability）：事务一旦提交，对数据所做的任何改变都要记录到永久存储器中。\n\n\n\n事务的隔离性\n\n常见的并发异常\n第一类丢失更新、第二类丢失更新。\n脏读、不可重复读、幻读。\n\n\n常见的隔离级别\nRead Uncommitted：读取未提交的数据。\nRead Committed：读取已提交的数据。\nRepeatable Read：可重复读。\nSerializable：串行化。\n\n\n\n第一类丢失更新：某一个事务的回滚，导致另外一个事务已更新的数据丢失了。\n第二类丢失更新：某一个事务的提交，导致另外一个事务已更新的数据丢失了。\n脏读：某一个事务，读取了另外一个事务未提交的数据。\n不可重复读：某一个事务，对同一个数据前后读取的结果不一致。\n幻读：某一个事务，对同一个表前后查询到的行数不一致。\n事务隔离级别：\n\n实现机制\n\n悲观锁（数据库）\n共享锁（S锁）事务A对某数据加了共享锁后，其他事务只能对该数据加共享锁，但不能加排他锁。\n排他锁（X锁）事务A对某数据加了排他锁后，其他事务对该数据既不能加共享锁，也不能加排他锁。\n\n\n乐观锁（自定义）\n版本号、时间戳等在更新数据前，检查版本号是否发生变化。若变化则取消本次更新，否则就更新数据（版本号+1）。\n\n\n\nSpring事务管理\n\n声明式事务\n\n通过XML配置，声明某方法的事务特征。\n通过注解，声明某方法的事务特征。\n\n\n编程式事务\n\n通过 TransactionTemplate 管理事务，并通过它执行数据库的操作。\n\n\n\n\n\ndemo：用户注册并发帖\n1 使用@Transactional 注入\n2 使用TransactionTemplate\n// REQUIRED: 支持当前事务(外部事务),如果不存在则创建新事务.// REQUIRES_NEW: 创建一个新事务,并且暂停当前事务(外部事务).// NESTED: 如果当前存在事务(外部事务),则嵌套在该事务中执行(独立的提交和回滚),否则就会REQUIRED一样.@Transactional(isolation = Isolation.READ_COMMITTED, propagation = Propagation.REQUIRED)public Object save1()&#123;    //新增用户    ....    //新增帖子    ....&#125;\n\n@Autowiredprivate TransactionTemplate transactionTemplate;public Object save2() &#123;    transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_READ_COMMITTED);    transactionTemplate.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);    return transactionTemplate.execute(new TransactionCallback&lt;Object&gt;() &#123;        @Override        public Object doInTransaction(TransactionStatus status) &#123;            //新增用户            ....            //新增帖子            ....        &#125;        &#125;);    &#125;\n\n","categories":["讨论社区项目"],"tags":["事务","Mysql","事务隔离","事务管理"]},{"title":"讨论社区18  -  帖子详情","url":"/2019/07/12/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA18%20-%20%E5%B8%96%E5%AD%90%E8%AF%A6%E6%83%85/","content":"\nDiscussPostMapper       定义DAO方法\n\nDiscussPostService         业务层\n\nDiscussPostController    控制层\n\nindex.html\n\n在帖子标题上增加访问详情页面的链接\n\n\ndiscuss-detail.html\n\n处理静态资源的访问路径\n复用index.html的header区域\n显示标题、作者、发布时间、帖子正文等内容\n\n\n\n","categories":["讨论社区项目"]},{"title":"讨论社区17  -  发布帖子功能实现","url":"/2019/07/11/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA17%20-%20%E5%8F%91%E5%B8%83%E5%B8%96%E5%AD%90%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/","content":"\nAJAX\nAsynchronous JavaScript and XML\n异步的JavaScript与XML，不是一门新技术，只是一个新的术语。\n使用AJAX，网页能够将增量更新呈现在页面上，而不需要刷新整个页面。\n虽然X代表XML，但目前JSON的使用比XML更加普遍。\nhttps://developer.mozilla.org/zh-CN/docs/Web/Guide/AJAX\n\n\n示例\n使用jQuery发送AJAX请求。\n\n\n实践\n采用AJAX请求，实现发布帖子的功能。\n\n\n\n","categories":["讨论社区项目"]},{"title":"讨论社区16  -  过滤敏感词","url":"/2019/07/09/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA16%20-%20%E8%BF%87%E6%BB%A4%E6%95%8F%E6%84%9F%E8%AF%8D/","content":"最直接：字符串替换 replace方法\n\n问题：敏感词数量多了怎么办？帖子字数很多怎么办？\n生产一般使用前缀树过滤敏感词\n\n\n前缀树\n\n\n名称：Trie、字典树、查找树\n特点：查找效率高，消耗内存大\n应用：字符串检索、词频统计、字符串排序等\n\n\n构建敏感词前缀树：根节点不存储任何信息，每一个敏感词从第一个字符开始，逐个加入树，前缀相同继续在其后添加字符，不相同则从根节点重新开启一颗子树，直至到叶子节点整个路径构成一个敏感词。\n敏感词过滤：\n定义三个指针p，begin，end（p 指向树的根节点，begin 和 end 开始均指向待检测字符串的第一个位置）。\n开始begin、end与 p 同时移动，遇到前缀树中第一层结点，begin停止不动，p 与end 继续移动，检查p 与end 能否匹配至叶子节点，如果是则替换begin 与end之间所有字符，然后begin 与 end 移到敏感词后一个位置，且p 指针归位到根节点；不是则p归位到根节点，begin 向前移动1位，end后退至begin 的位置，重新开始判断。\n注意，在其中不是敏感词的字符存储到新的变量区不改变，敏感词用 特殊符号代替之后append到非敏感词后面。\n\n\n\n\n敏感词过滤器\n\n定义前缀树\n根据敏感词，初始化前缀树\n编写过滤敏感词的方法\n\n// 前缀树private class TrieNode &#123;    // 关键词结束标识    private boolean isKeywordEnd = false;    // 子节点(key是下级字符,value是下级节点)    private Map&lt;Character, TrieNode&gt; subNodes = new HashMap&lt;&gt;();    public boolean isKeywordEnd() &#123;        return isKeywordEnd;    &#125;    public void setKeywordEnd(boolean keywordEnd) &#123;        isKeywordEnd = keywordEnd;    &#125;    // 添加子节点    public void addSubNode(Character c, TrieNode node) &#123;        subNodes.put(c, node);    &#125;    // 获取子节点    public TrieNode getSubNode(Character c) &#123;        return subNodes.get(c);    &#125;&#125;\n\n// 替换符private static final String REPLACEMENT = &quot;***&quot;;// 根节点private TrieNode rootNode = new TrieNode();@PostConstructpublic void init() &#123;    try (        InputStream is = this.getClass().getClassLoader().getResourceAsStream(&quot;sensitive-words.txt&quot;); //sensitive-words.txt存放在resource文件夹下，编译之后一定要在classes下能找到        BufferedReader reader = new BufferedReader(new InputStreamReader(is));    ) &#123;        String keyword;        while ((keyword = reader.readLine()) != null) &#123;            // 添加到前缀树            this.addKeyword(keyword);        &#125;    &#125; catch (IOException e) &#123;        logger.error(&quot;加载敏感词文件失败: &quot; + e.getMessage());    &#125;&#125;// 将一个敏感词添加到前缀树中private void addKeyword(String keyword) &#123;    TrieNode tempNode = rootNode;    for (int i = 0; i &lt; keyword.length(); i++) &#123;        char c = keyword.charAt(i);        TrieNode subNode = tempNode.getSubNode(c);        if (subNode == null) &#123;            // 初始化子节点            subNode = new TrieNode();            tempNode.addSubNode(c, subNode);        &#125;        // 指向子节点,进入下一轮循环        tempNode = subNode;        // 设置结束标识        if (i == keyword.length() - 1) &#123;            tempNode.setKeywordEnd(true);        &#125;    &#125;&#125;\n\n/**  * 过滤敏感词  *  * @param text 待过滤的文本  * @return 过滤后的文本*/public String filter(String text) &#123;    if (StringUtils.isBlank(text)) &#123;        return null;    &#125;    // 指针1    TrieNode tempNode = rootNode;    // 指针2    int begin = 0;    // 指针3    int position = 0;    // 结果    StringBuilder sb = new StringBuilder();    while (position &lt; text.length()) &#123;        char c = text.charAt(position);        // 跳过符号        if (isSymbol(c)) &#123;            // 若指针1处于根节点,将此符号计入结果,让指针2向下走一步            if (tempNode == rootNode) &#123;                sb.append(c);                begin++;            &#125;            // 无论符号在开头或中间,指针3都向下走一步            position++;            continue;        &#125;        // 检查下级节点        tempNode = tempNode.getSubNode(c);        if (tempNode == null) &#123;            // 以begin开头的字符串不是敏感词            sb.append(text.charAt(begin));            // 进入下一个位置            position = ++begin;            // 重新指向根节点            tempNode = rootNode;        &#125; else if (tempNode.isKeywordEnd()) &#123;            // 发现敏感词,将begin~position字符串替换掉            sb.append(REPLACEMENT);            // 进入下一个位置            begin = ++position;            // 重新指向根节点            tempNode = rootNode;        &#125; else &#123;            // 检查下一个字符            position++;        &#125;    &#125;    // 将最后一批字符计入结果 position提前到终点，但begin没有到终点    sb.append(text.substring(begin));    return sb.toString();&#125;// 判断是否为符号private boolean isSymbol(Character c) &#123;    // 0x2E80~0x9FFF 是东亚文字范围    return !CharUtils.isAsciiAlphanumeric(c) &amp;&amp; (c &lt; 0x2E80 || c &gt; 0x9FFF);&#125;\n\n\n","categories":["讨论社区项目"],"tags":["Tire"]},{"title":"讨论社区15  -  检查登录状态","url":"/2019/07/08/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA15%20-%20%E6%A3%80%E6%9F%A5%E7%99%BB%E5%BD%95%E7%8A%B6%E6%80%81/","content":"\n使用拦截器\n\n在方法前标注自定义注解\n拦截所有请求，只处理带有该注解的方法\n\n\n自定义注解\n\n常用的元注解：@Target、@Retention、@Document、@Inherited\n\n\n@Target声明自定义注解的位置（类？方法？属性？）\n@Retention  自定义注解的有效时间（编译时？运行时？）\n@Document  生成文档是否携带注解？\n@Inherited  子类继承父类是否继承注解？\n\n\n如何读取注解：Method.getDeclaredAnnotations ()  //获取方法上所有注解Method.getAnnotation (Class&lt;T&gt; annotationClass)\n\n\n项目中添加自定义注解：\n\n定义自定义注解的类，无需详细实现方法，只需声明为接口，且加上@Target、@Retention\n\nimport java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface LoginRequired &#123;&#125;\n\n\n在需要使用的方法（如上则是在必须登录之后才能访问的路径处）加上@LoginRequired\n拦截器的使用逻辑，拦截有自定义注解的方法，进一步判断，符合则继续，不符合则拒绝\n\nimport com.wx.talking.annotation.LoginRequired;import com.wx.talking.util.HostHolder;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import org.springframework.web.method.HandlerMethod;import org.springframework.web.servlet.HandlerInterceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.lang.reflect.Method;@Componentpublic class LoginRequiredInterceptor implements HandlerInterceptor &#123;    @Autowired    private HostHolder hostHolder;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        if (handler instanceof HandlerMethod) &#123;            HandlerMethod handlerMethod = (HandlerMethod) handler;            // 获取拦截的对象            Method method = handlerMethod.getMethod();            LoginRequired loginRequired = method.getAnnotation(LoginRequired.class);            // 需要登录但当前用户未登录，重定向到首页            if (loginRequired != null &amp;&amp; hostHolder.getUser() == null) &#123;                response.sendRedirect(request.getContextPath() + &quot;/login&quot;);                return false;            &#125;        &#125;        return true;    &#125;&#125;\n\n配置拦截器，不拦截静态文件等\n@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123; \tpublic void addInterceptors(InterceptorRegistry registry) &#123; \t\tregistry.addInterceptor(loginRequiredInterceptor)                .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;); &#125;&#125;\n\n","categories":["讨论社区项目"],"tags":["拦截器","注解"]},{"title":"讨论社区14  -  账号设置","url":"/2019/07/07/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA14%20-%20%E8%B4%A6%E5%8F%B7%E8%AE%BE%E7%BD%AE/","content":"\n上传文件\n\n请求：必须是POST请求\n表单：enctype=“multipart/form-data”\nSpring MVC：通过 MultipartFile 处理上传文件\n\n\n开发步骤\n\n访问账号设置页面\n\n\nService定义访问路径，模板页修改\n\n\n上传头像\n\n\n定义上传路径\n视图层更新\n\n\n获取头像\n\n\n\n","categories":["讨论社区项目"],"tags":["Spring MVC","MultipartFile"]},{"title":"讨论社区13  -  显示登录信息","url":"/2019/07/05/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA13%20-%20%E6%98%BE%E7%A4%BA%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF/","content":"\n拦截器示例\n\n定义拦截器，实现HandlerInterceptor\n配置拦截器，为它指定拦截、排除的路径\n\n@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123;    @Autowired    private AlphaInterceptor alphaInterceptor;    @Autowired    private LoginTicketInterceptor loginTicketInterceptor;    @Autowired    private LoginRequiredInterceptor loginRequiredInterceptor;    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        registry.addInterceptor(alphaInterceptor)                .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;)                .addPathPatterns(&quot;/register&quot;, &quot;/login&quot;);        registry.addInterceptor(loginTicketInterceptor)                .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;);        registry.addInterceptor(loginRequiredInterceptor)                .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;);    &#125;&#125;\n\n拦截器应用\n\n在请求开始时查询登录用户\n在本次请求中持有用户数据\n\n\n需要暂存用户数据，使用本地的类暂存？\nClient访问Server是多线程的，多对一。所以存储用户数据的时候需要考虑多线程，如果仅简单存储用户数据，在并发情况下可能会造成数据混乱。\n线程隔离 ThreadLocal\n\n\n在模板视图上显示用户数据\n在请求结束时清理用户数据\n\n\n\n","categories":["讨论社区项目"],"tags":["拦截器","ThreadLocal"]},{"title":"讨论社区12  -  登录、退出功能实现","url":"/2019/07/04/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA12%20-%20%E7%99%BB%E5%BD%95%E3%80%81%E9%80%80%E5%87%BA%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/","content":"\n访问登录页面\n点击顶部区域内的链接，打开登录页面。\n\n\n登录\n验证账号、密码、验证码。\n成功时，生成登录凭证，发放给客户端。\n失败时，跳转回登录页。\n\n\n退出\n将登录凭证修改为失效状态。\n跳转至网站首页。\n\n\n\n","categories":["讨论社区项目"],"tags":["Spring"]},{"title":"讨论社区11  -  图片验证码","url":"/2019/07/02/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA11%20-%20%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81/","content":"Kaptcha\n\n导入 jar 包\n编写 Kaptcha 配置类\n生成随机字符、生成图片\n\n","categories":["讨论社区项目"],"tags":["图片验证码"]},{"title":"讨论社区10  -  会话管理","url":"/2019/07/01/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA10%20-%20%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/","content":"\nHTTP的基本性质\n\nHTTP是简单的\nHTTP是可扩展的\nHTTP是无状态的，有会话的\n\n\nCookie\n\n是服务器发送到浏览器，并保存在浏览器端的一小块数据。\n浏览器下次访问该服务器时，会自动携带块该数据，将其发送给服务器。\n\n\nSession\n\n是JavaEE的标准，用于在服务端记录客户端信息。\n数据存放在服务端更加安全，但是也会增加服务端的内存压力。\n\n\nSession 依赖于Cookie，Server在Client请求时生成Session（包含Client的一些信息），然后将携带SessionId的Cookie发送给Client\nClient本地存储Cookie，下一次访问Server，服务器识别Client发送的Cookie中携带的SessionId，查找到属于特定Client的登录或其他信息。\n以上可以综合Server和Client，不仅在一定程度上可以缓解双方压力，也能保证安全。\n有必要就存，尽量使用Cookie，减小服务的压力。\n分布式部署使用Session？\n粘性Session——负载均衡不友好\n同步Session——服务端需要同步Session，服务器之间有耦合\n共享Session——单体Session服务器，服务器宕机会所有的都出现问题\n以上可得出目前的处理方式：尽量存在Client端，否则存在服务端数据库。对于传统关系型数据可能仍然出现瓶颈，查询性能（内存中快，硬盘中慢）；但现在出现的NoSQL数据库（如Redis）可以很好的解决上述问题。\n\n\n\n","categories":["讨论社区项目"],"tags":["HTTP","Session","Cookie"]},{"title":"讨论社区09  -  注册功能实现","url":"/2019/06/30/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA09%20-%20%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/","content":"\n访问注册页面\n\n点击顶部区域内的链接，打开注册页面。\n\n\n复用Thymeleaf的标签，复用头部区域\n\n&lt;header class=&quot;bg-dark sticky-top&quot; th:fragment=&quot;header&quot;&gt;\n\n在需要复用的地方\n&lt;header class=&quot;bg-dark sticky-top&quot; th:replace=&quot;index::header&quot;&gt;\n\n提交注册数据\n\n通过表单提交数据。\n服务端验证账号是否已存在、邮箱是否已注册。\n服务端发送激活邮件。\n\n\n激活注册账号\n\n点击邮件中的链接，访问服务端的激活服务。\n\n\n在Service处理，三种结果：激活成功、激活失败、重复激活\npublic int activation(int userId, String code) &#123;        User user = userMapper.selectById(userId);        if (user.getStatus() == 1) &#123;            return ACTIVATION_REPEAT;        &#125; else if (user.getActivationCode().equals(code)) &#123;            userMapper.updateStatus(userId, 1);            clearCache(userId);            return ACTIVATION_SUCCESS;        &#125; else &#123;            return ACTIVATION_FAILURE;        &#125;    &#125;\n\nLoginController处理请求\n@RequestMapping(path = &quot;/activation/&#123;userId&#125;/&#123;code&#125;&quot;, method = RequestMethod.GET)public String activation(Model model, @PathVariable(&quot;userId&quot;) int userId, @PathVariable(&quot;code&quot;) String code) &#123;    int result = userService.activation(userId, code);    if (result == ACTIVATION_SUCCESS) &#123;        model.addAttribute(&quot;msg&quot;, &quot;激活成功,您的账号已经可以正常使用了!&quot;);        model.addAttribute(&quot;target&quot;, &quot;/login&quot;);    &#125; else if (result == ACTIVATION_REPEAT) &#123;        model.addAttribute(&quot;msg&quot;, &quot;无效操作,该账号已经激活过了!&quot;);        model.addAttribute(&quot;target&quot;, &quot;/index&quot;);    &#125; else &#123;        model.addAttribute(&quot;msg&quot;, &quot;激活失败,您提供的激活码不正确!&quot;);        model.addAttribute(&quot;target&quot;, &quot;/index&quot;);    &#125;    return &quot;/site/operate-result&quot;;//返回信息到激活页面&#125;\n\n\n\n\n","categories":["讨论社区项目"],"tags":["JavaMailSender","Thymeleaf"]},{"title":"hexo快速开始","url":"/2019/06/30/hexo%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":["随笔"],"tags":["随笔"]},{"title":"讨论社区08  -  发送邮件","url":"/2019/06/28/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA08%20-%20%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/","content":"\n邮箱设置\n启用客户端SMTP服务\n\n\nSpring Email\n导入 jar 包\n邮箱参数配置\n使用 JavaMailSender 发送邮件\n\n\n模板引擎\n使用 Thymeleaf 发送 HTML 邮件\n\n\n\n","categories":["讨论社区项目"],"tags":["SMTP","JavaMailSender"]},{"title":"JavaSpring项目使用Mail包发送邮件报错无法连接服务器Could not connect to SMTP host","url":"/2019/06/28/JavaSpring%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8Mail%E5%8C%85%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E6%8A%A5%E9%94%99%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8Could-not-connect-to-SMTP-host/","content":"问题在使用SpringBoot的mail依赖库连接sina邮箱发送邮件时遇到如下问题：\norg.springframework.mail.MailSendException: Mail server connection failed; nested exception is javax.mail.MessagingException: Could not connect to SMTP host: smtp.sina.com, port: 465;  nested exception is:\tjavax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target. Failed messages: javax.mail.MessagingException: Could not connect to SMTP host: smtp.sina.com, port: 465;  nested exception is:\tjavax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target; message exception details (1) are:Failed message 1:javax.mail.MessagingException: Could not connect to SMTP host: smtp.sina.com, port: 465;  nested exception is:\tjavax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target\tat com.sun.mail.smtp.SMTPTransport.openServer(SMTPTransport.java:2211)\tat com.sun.mail.smtp.SMTPTransport.protocolConnect(SMTPTransport.java:722)\tat javax.mail.Service.connect(Service.java:342)\tat org.springframework.mail.javamail.JavaMailSenderImpl.connectTransport(JavaMailSenderImpl.java:518)\tat org.springframework.mail.javamail.JavaMailSenderImpl.doSend(JavaMailSenderImpl.java:437)\tat org.springframework.mail.javamail.JavaMailSenderImpl.send(JavaMailSenderImpl.java:361)\tat org.springframework.mail.javamail.JavaMailSenderImpl.send(JavaMailSenderImpl.java:356)\tat com.wx.talking.util.MailClient.sendMail(MailClient.java:36)\tat com.wx.talking.MailTests.testTextMail(MailTests.java:24)\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\tat java.lang.reflect.Method.invoke(Method.java:497)\tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\tat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\tat org.springframework.test.context.junit4.statements.RunBeforeTestExecutionCallbacks.evaluate(RunBeforeTestExecutionCallbacks.java:74)\tat org.springframework.test.context.junit4.statements.RunAfterTestExecutionCallbacks.evaluate(RunAfterTestExecutionCallbacks.java:84)\tat org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:75)\tat org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:86)\tat org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:84)\tat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)\tat org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:251)\tat org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:97)\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\tat org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61)\tat org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70)\tat org.junit.runners.ParentRunner.run(ParentRunner.java:363)\tat org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:190)\tat org.junit.runner.JUnitCore.run(JUnitCore.java:137)\tat com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)\tat com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:33)\tat com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:230)\tat com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:58)Caused by: javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target\tat sun.security.ssl.Alerts.getSSLException(Alerts.java:192)\tat sun.security.ssl.SSLSocketImpl.fatal(SSLSocketImpl.java:1949)\tat sun.security.ssl.Handshaker.fatalSE(Handshaker.java:302)\tat sun.security.ssl.Handshaker.fatalSE(Handshaker.java:296)\tat sun.security.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:1509)\tat sun.security.ssl.ClientHandshaker.processMessage(ClientHandshaker.java:216)\tat sun.security.ssl.Handshaker.processLoop(Handshaker.java:979)\tat sun.security.ssl.Handshaker.process_record(Handshaker.java:914)\tat sun.security.ssl.SSLSocketImpl.readRecord(SSLSocketImpl.java:1062)\tat sun.security.ssl.SSLSocketImpl.performInitialHandshake(SSLSocketImpl.java:1375)\tat sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1403)\tat sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1387)\tat com.sun.mail.util.SocketFetcher.configureSSLSocket(SocketFetcher.java:602)\tat com.sun.mail.util.SocketFetcher.createSocket(SocketFetcher.java:376)\tat com.sun.mail.util.SocketFetcher.getSocket(SocketFetcher.java:214)\tat com.sun.mail.smtp.SMTPTransport.openServer(SMTPTransport.java:2160)\t... 38 moreCaused by: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target\tat sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:387)\tat sun.security.validator.PKIXValidator.engineValidate(PKIXValidator.java:292)\tat sun.security.validator.Validator.validate(Validator.java:260)\tat sun.security.ssl.X509TrustManagerImpl.validate(X509TrustManagerImpl.java:324)\tat sun.security.ssl.X509TrustManagerImpl.checkTrusted(X509TrustManagerImpl.java:229)\tat sun.security.ssl.X509TrustManagerImpl.checkServerTrusted(X509TrustManagerImpl.java:124)\tat sun.security.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:1491)\t... 49 moreCaused by: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target\tat sun.security.provider.certpath.SunCertPathBuilder.build(SunCertPathBuilder.java:146)\tat sun.security.provider.certpath.SunCertPathBuilder.engineBuild(SunCertPathBuilder.java:131)\tat java.security.cert.CertPathBuilder.build(CertPathBuilder.java:280)\tat sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:382)\t... 55 more\n\n分析从日志可以定位原因——没有连接到服务器（smtp.sina.com），原因有很多：\n\n账号密码配置错误？\n开启SSL登录，端口是否正确？\n证书问题？\n\n本文遇到的就是第三个问题。\n先放一张图，便于理解\n\n解决方法当然，StackOverflow上也能找到对应解决方法。\n代码在最后，先给出使用方法\nUsage:Need to compile, first:javac InstallCert.javaNote: since java 11, you can run it directly without compiling it first:java --source 11 InstallCert.java &lt;args&gt;# Access server, and retrieve certificate (accept default certificate 1)java InstallCert [--proxy&#x3D;proxyHost:proxyPort] &lt;host&gt;[:port] [passphrase]# Extract certificate from created jssecacerts keystorekeytool -exportcert -alias [host]-1 -keystore jssecacerts -storepass changeit -file [host].cer# Import certificate into system keystorekeytool -importcert -alias [host] -keystore [path to system keystore] -storepass changeit -file [host].cer# Example:java InstallCert woot.com:443    Loading KeyStore &#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-6-sun-1.6.0.26&#x2F;jre&#x2F;lib&#x2F;security&#x2F;cacerts...    Opening connection to woot.com:443...    Starting SSL handshake...    javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target    &lt;...&gt;    Server sent 1 certificate(s):     1 Subject O&#x3D;Woot Inc, C&#x3D;US, ST&#x3D;Texas, L&#x3D;Carrollton, CN&#x3D;*.woot.com       Issuer  CN&#x3D;SecureTrust CA, O&#x3D;SecureTrust Corporation, C&#x3D;US       sha1    4b 46 ca 6b 83 05 b3 51 ff c6 e7 9c fd b3 9b e3 3f 2e c4 53        md5     e8 a5 88 1b d5 67 bb fc 88 cc b1 c5 2b ac c4 7d     Enter certificate to add to trusted keystore or &#39;q&#39; to quit: [1][enter]    [    [      Version: V3      Subject: O&#x3D;Woot Inc, C&#x3D;US, ST&#x3D;Texas, L&#x3D;Carrollton, CN&#x3D;*.woot.com      Signature Algorithm: SHA1withRSA, OID &#x3D; 1.2.840.113549.1.1.5    &lt;...&gt;    Added certificate to keystore &#39;jssecacerts&#39; using alias &#39;woot.com-1&#39;keytool -exportcert -alias woot.com-1 -keystore jssecacerts -storepass changeit -file woot.com.cer    Certificate stored in file &lt;woot.com.cer&gt;  (sudo) keytool -importcert -alias woot.com -keystore &#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-6-sun-1.6.0.26&#x2F;jre&#x2F;lib&#x2F;security&#x2F;cacerts -storepass changeit -file woot.com.cer    Owner: O&#x3D;Woot Inc, C&#x3D;US, ST&#x3D;Texas, L&#x3D;Carrollton, CN&#x3D;*.woot.com    Issuer: CN&#x3D;SecureTrust CA, O&#x3D;SecureTrust Corporation, C&#x3D;US      &lt;...&gt;      Trust this certificate? [no]:  yes    Certificate was added to keystore\n\n//利用java生成证书文件，复制到jre的security文件夹\n&#x2F;* * Copyright 2006 Sun Microsystems, Inc.  All Rights Reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * *   - Redistributions of source code must retain the above copyright *     notice, this list of conditions and the following disclaimer. * *   - Redistributions in binary form must reproduce the above copyright *     notice, this list of conditions and the following disclaimer in the *     documentation and&#x2F;or other materials provided with the distribution. * *   - Neither the name of Sun Microsystems nor the names of its *     contributors may be used to endorse or promote products derived *     from this software without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS * IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. *&#x2F;&#x2F;** * Originally from: * http:&#x2F;&#x2F;blogs.sun.com&#x2F;andreas&#x2F;resource&#x2F;InstallCert.java * Use: * java InstallCert hostname * Example: *% java InstallCert ecc.fedora.redhat.com *&#x2F;import javax.net.ssl.*;import java.io.*;import java.security.KeyStore;import java.security.MessageDigest;import java.security.cert.CertificateException;import java.security.cert.X509Certificate;&#x2F;** * Class used to add the server&#39;s certificate to the KeyStore * with your trusted certificates. *&#x2F;public class InstallCert &#123;    public static void main(String[] args) throws Exception &#123;        String host;        int port;        char[] passphrase;        if ((args.length &#x3D;&#x3D; 1) || (args.length &#x3D;&#x3D; 2)) &#123;            String[] c &#x3D; args[0].split(&quot;:&quot;);            host &#x3D; c[0];            port &#x3D; (c.length &#x3D;&#x3D; 1) ? 443 : Integer.parseInt(c[1]);            String p &#x3D; (args.length &#x3D;&#x3D; 1) ? &quot;changeit&quot; : args[1];            passphrase &#x3D; p.toCharArray();        &#125; else &#123;            System.out.println(&quot;Usage: java InstallCert &lt;host&gt;[:port] [passphrase]&quot;);            return;        &#125;        File file &#x3D; new File(&quot;jssecacerts&quot;);        if (file.isFile() &#x3D;&#x3D; false) &#123;            char SEP &#x3D; File.separatorChar;            File dir &#x3D; new File(System.getProperty(&quot;java.home&quot;) + SEP                    + &quot;lib&quot; + SEP + &quot;security&quot;);            file &#x3D; new File(dir, &quot;jssecacerts&quot;);            if (file.isFile() &#x3D;&#x3D; false) &#123;                file &#x3D; new File(dir, &quot;cacerts&quot;);            &#125;        &#125;        System.out.println(&quot;Loading KeyStore &quot; + file + &quot;...&quot;);        InputStream in &#x3D; new FileInputStream(file);        KeyStore ks &#x3D; KeyStore.getInstance(KeyStore.getDefaultType());        ks.load(in, passphrase);        in.close();        SSLContext context &#x3D; SSLContext.getInstance(&quot;TLS&quot;);        TrustManagerFactory tmf &#x3D;                TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());        tmf.init(ks);        X509TrustManager defaultTrustManager &#x3D; (X509TrustManager) tmf.getTrustManagers()[0];        SavingTrustManager tm &#x3D; new SavingTrustManager(defaultTrustManager);        context.init(null, new TrustManager[]&#123;tm&#125;, null);        SSLSocketFactory factory &#x3D; context.getSocketFactory();        System.out.println(&quot;Opening connection to &quot; + host + &quot;:&quot; + port + &quot;...&quot;);        SSLSocket socket &#x3D; (SSLSocket) factory.createSocket(host, port);        socket.setSoTimeout(10000);        try &#123;            System.out.println(&quot;Starting SSL handshake...&quot;);            socket.startHandshake();            socket.close();            System.out.println();            System.out.println(&quot;No errors, certificate is already trusted&quot;);        &#125; catch (SSLException e) &#123;            System.out.println();            e.printStackTrace(System.out);        &#125;        X509Certificate[] chain &#x3D; tm.chain;        if (chain &#x3D;&#x3D; null) &#123;            System.out.println(&quot;Could not obtain server certificate chain&quot;);            return;        &#125;        BufferedReader reader &#x3D;                new BufferedReader(new InputStreamReader(System.in));        System.out.println();        System.out.println(&quot;Server sent &quot; + chain.length + &quot; certificate(s):&quot;);        System.out.println();        MessageDigest sha1 &#x3D; MessageDigest.getInstance(&quot;SHA1&quot;);        MessageDigest md5 &#x3D; MessageDigest.getInstance(&quot;MD5&quot;);        for (int i &#x3D; 0; i &lt; chain.length; i++) &#123;            X509Certificate cert &#x3D; chain[i];            System.out.println                    (&quot; &quot; + (i + 1) + &quot; Subject &quot; + cert.getSubjectDN());            System.out.println(&quot;   Issuer  &quot; + cert.getIssuerDN());            sha1.update(cert.getEncoded());            System.out.println(&quot;   sha1    &quot; + toHexString(sha1.digest()));            md5.update(cert.getEncoded());            System.out.println(&quot;   md5     &quot; + toHexString(md5.digest()));            System.out.println();        &#125;        System.out.println(&quot;Enter certificate to add to trusted keystore or &#39;q&#39; to quit: [1]&quot;);        String line &#x3D; reader.readLine().trim();        int k;        try &#123;            k &#x3D; (line.length() &#x3D;&#x3D; 0) ? 0 : Integer.parseInt(line) - 1;        &#125; catch (NumberFormatException e) &#123;            System.out.println(&quot;KeyStore not changed&quot;);            return;        &#125;        X509Certificate cert &#x3D; chain[k];        String alias &#x3D; host + &quot;-&quot; + (k + 1);        ks.setCertificateEntry(alias, cert);        OutputStream out &#x3D; new FileOutputStream(&quot;jssecacerts&quot;);        ks.store(out, passphrase);        out.close();        System.out.println();        System.out.println(cert);        System.out.println();        System.out.println                (&quot;Added certificate to keystore &#39;jssecacerts&#39; using alias &#39;&quot;                        + alias + &quot;&#39;&quot;);    &#125;    private static final char[] HEXDIGITS &#x3D; &quot;0123456789abcdef&quot;.toCharArray();    private static String toHexString(byte[] bytes) &#123;        StringBuilder sb &#x3D; new StringBuilder(bytes.length * 3);        for (int b : bytes) &#123;            b &amp;&#x3D; 0xff;            sb.append(HEXDIGITS[b &gt;&gt; 4]);            sb.append(HEXDIGITS[b &amp; 15]);            sb.append(&#39; &#39;);        &#125;        return sb.toString();    &#125;    private static class SavingTrustManager implements X509TrustManager &#123;        private final X509TrustManager tm;        private X509Certificate[] chain;        SavingTrustManager(X509TrustManager tm) &#123;            this.tm &#x3D; tm;        &#125;        public X509Certificate[] getAcceptedIssuers() &#123;\t   \t    &#x2F;** \t     * This change has been done due to the following resolution advised for Java 1.7+\t\thttp:&#x2F;&#x2F;infposs.blogspot.kr&#x2F;2013&#x2F;06&#x2F;installcert-and-java-7.html       \t     **&#x2F; \t    \t    return new X509Certificate[0];\t            &#x2F;&#x2F;throw new UnsupportedOperationException();        &#125;        public void checkClientTrusted(X509Certificate[] chain, String authType)                throws CertificateException &#123;            throw new UnsupportedOperationException();        &#125;        public void checkServerTrusted(X509Certificate[] chain, String authType)                throws CertificateException &#123;            this.chain &#x3D; chain;            tm.checkServerTrusted(chain, authType);        &#125;    &#125;&#125;\n\n","categories":["编程笔记"],"tags":["SpringBoot"]},{"title":"讨论社区07  -  版本控制","url":"/2019/06/26/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA07%20-%20%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/","content":"\n认识Git\nGit简介\nGit的安装与配置\n\n\nGit常用命令\n将代码提交至本地仓库\n将代码上传至远程仓库\n\n\nIDEA集成Git\n在IDEA中配置并使用Git\n\n\n\n# 账号配置git config --listgit config --global user.name &quot;wangxu&quot;git config --global user.email &quot;xxx@gmail.com&quot;# 本地仓库git initgit status -sgit add *git commit -m &#x27;...&#x27;# 生成秘钥ssh-keygen -t rsa -C &quot;xxx@gmail.com&quot;# 推送已有项目git remote add originhttps://github.com/4Details/Test.gitgit push -u origin master# 克隆已有仓库git clone https://github.com/4Details/Test.git\n\n","categories":["讨论社区项目"],"tags":["Spring","Git"]},{"title":"讨论社区06  -  项目调试技巧","url":"/2019/06/23/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA06%20-%20%E9%A1%B9%E7%9B%AE%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/","content":"\n响应状态码的含义\n服务端断点调试技巧\n客户端断点调试技巧\n设置日志级别，并将日志输出到不同的终端\n\n","categories":["讨论社区项目","编程笔记"],"tags":["Bug调试"]},{"title":"讨论社区05  -  讨论社区首页实现","url":"/2019/06/21/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA05%20-%20%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA%E9%A6%96%E9%A1%B5%E5%AE%9E%E7%8E%B0/","content":"\n开发流程\n1次请求的执行过程\n\n\n分步实现\n开发社区首页，显示前10个帖子\n开发分页组件，分页显示所有的帖子\n\n\n","categories":["讨论社区项目"],"tags":["Spring"]},{"title":"讨论社区04  -  Mybatis  入门","url":"/2019/06/18/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA04%20-%20MyBatis-%E5%85%A5%E9%97%A8/","content":"安装数据库\n安装MySQL Server\n安装MySQL Workbench\n\nMyBatis\n核心组件\nSqlSessionFactory：用于创建SqlSession的工厂类。\nSqlSession：MyBatis的核心组件，用于向数据库执行SQL。\n主配置文件：XML配置文件，可以对MyBatis的底层行为做出详细的配置。\nMapper接口：就是DAO接口，在MyBatis中习惯性的称之为Mapper。\nMapper映射器：用于编写SQL，并将SQL和实体类映射的组件，采用XML、注解均可实现。\n\n\n示例\n使用MyBatis对用户表进行CRUD操作。\n\n\n在application.properties中配置数据库、Mybatis相关。\n\n","categories":["讨论社区项目"],"tags":["Spring","Mybatis"]},{"title":"讨论社区03  -  Spring MVC 入门","url":"/2019/06/16/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA03%20-%20Spring-MVC-%E5%85%A5%E9%97%A8/","content":"HTTP\nHyperText Transfer Protocol\n用于传输HTML等内容的应用层协议\n规定了浏览器和服务器之间如何通信，以及通信时的数据格式。\n学习网站：https://developer.mozilla.org/zh-CN\n\n浏览器服务器通信步骤：\n\n打开一个TCP连接\n发生一个HTTP报文 \n读取服务器返回的报文信息\n关闭连接或为后续请求重用连接\n\n\n按下F12进入调试，在Network下看请求响应（Header和Response）\n\nSpring MVC\n三层架构\n表现层(mvc)、业务层、数据访问层\n\n\nMVC(设计模式)\nModel：模型层\nView：视图层\nController：控制层\n核心组件\n前端控制器：DispatcherServlet\n\n\n\n浏览器访问服务器，首先访问的时Controller控制层，Controller调用业务层处理，处理完后将得到的数据封装到Model,传给视图层。\n \nThymeleaf\n模板引擎\n\n生成动态的HTML。\n\n\nThymeleaf\n\n倡导自然模板，即以HTML文件为模板。\n\n\n常用语法\n\n标准表达式、判断与循环、模板的布局。\n\n&lt;!--声明thymeleaf模板--&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot; xmlns:sec=&quot;http://www.thymeleaf.org/extras/spring-security&quot;&gt;    &lt;!--静态资源也需要做路径处理，带url的不需要处理--&gt;&lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;/css/global.css&#125;&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;/css/discuss-detail.css&#125;&quot; /&gt;\n\n&lt;!--标签是否显示demo--&gt;&lt;!--usernameMsg为Controller的model传过来的值--&gt;&lt;div class=&quot;col-sm-10&quot;&gt;\t\t&lt;input type=&quot;text&quot;\t\t\tth:class=&quot;|form-control $&#123;usernameMsg!=null?&#x27;is-invalid&#x27;:&#x27;&#x27;&#125;|&quot;\t\t\tth:value=&quot;$&#123;user!=null?user.username:&#x27;&#x27;&#125;&quot;\t\t\tid=&quot;username&quot; name=&quot;username&quot; placeholder=&quot;请输入您的账号!&quot; required&gt;\t\t\t&lt;div class=&quot;invalid-feedback&quot; th:text=&quot;$&#123;usernameMsg&#125;&quot;&gt;\t\t\t\t该账号已存在!\t\t\t&lt;/div&gt;&lt;/div&gt;\n\n\n\n变量用  $&#123;变量名&#125;， href 中使用 @&#123;url地址&#125;，常量与变量拼接 |常量+&#123;变量名&#125;|\n&lt;span th:utext=&quot;$&#123;post.title&#125;&quot;&gt;test title&lt;/span&gt;&lt;a class=&quot;nav-link&quot; th:href=&quot;@&#123;/index&#125;&quot;&gt;首页&lt;/a&gt;&lt;form method=&quot;post&quot; th:action=&quot;@&#123;|/comment/add/$&#123;post.id&#125;|&#125;&quot;&gt;\n\n\n\n代码部分底层：\n@RequestMapping(&quot;/http&quot;)public void http(HttpServletRequest request, HttpServletResponse response) &#123;    // 获取请求数据    System.out.println(request.getMethod());    System.out.println(request.getServletPath());    Enumeration&lt;String&gt; enumeration = request.getHeaderNames();    while (enumeration.hasMoreElements()) &#123;        String name = enumeration.nextElement();        String value = request.getHeader(name);        System.out.println(name + &quot;: &quot; + value);    &#125;    System.out.println(request.getParameter(&quot;code&quot;));    // 返回响应数据    response.setContentType(&quot;text/html;charset=utf-8&quot;);    try (        PrintWriter writer = response.getWriter();    ) &#123;        writer.write(&quot;&lt;h1&gt;xx网&lt;/h1&gt;&quot;);    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125;&#125;\n\n从路径中得到变量GET（两种方法）：\n@RequestMapping(path = &quot;/students&quot;, method = RequestMethod.GET)@ResponseBodypublic String getStudents(    @RequestParam(name = &quot;current&quot;, required = false, defaultValue = &quot;1&quot;) int current,    @RequestParam(name = &quot;limit&quot;, required = false, defaultValue = &quot;10&quot;) int limit) &#123;    System.out.println(current);    System.out.println(limit);    return &quot;some students&quot;;&#125;@RequestMapping(path = &quot;/student/&#123;id&#125;&quot;, method = RequestMethod.GET)@ResponseBodypublic String getStudent(@PathVariable(&quot;id&quot;) int id) &#123;    System.out.println(id);    return &quot;a student&quot;;&#125;\n\nPOST请求:\n@RequestMapping(path = &quot;/student&quot;, method = RequestMethod.POST)@ResponseBodypublic String saveStudent(String name, int age) &#123;    System.out.println(name);    System.out.println(age);    return &quot;success&quot;;&#125;\n\n响应HTML数据(使用ModelAndView或Model):\n@RequestMapping(path = &quot;/teacher&quot;, method = RequestMethod.GET)public ModelAndView getTeacher() &#123;    ModelAndView mav = new ModelAndView();    mav.addObject(&quot;name&quot;, &quot;张三&quot;);    mav.addObject(&quot;age&quot;, 30);    mav.setViewName(&quot;/demo/view&quot;);    return mav;&#125;@RequestMapping(path = &quot;/school&quot;, method = RequestMethod.GET)public String getSchool(Model model) &#123;    model.addAttribute(&quot;name&quot;, &quot;北京大学&quot;);    model.addAttribute(&quot;age&quot;, 80);    return &quot;/demo/view&quot;;&#125;\n\n 响应JSON数据(异步请求)：Java对象 -&gt; JSON字符串 -&gt; JS对象,使用@ResponseBody 注解\n@RequestMapping(path = &quot;/emp&quot;, method = RequestMethod.GET)@ResponseBodypublic Map&lt;String, Object&gt; getEmp() &#123;    Map&lt;String, Object&gt; emp = new HashMap&lt;&gt;();    emp.put(&quot;name&quot;, &quot;张三&quot;);    emp.put(&quot;age&quot;, 23);    return emp;&#125;//转换为json字符串  &#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:&quot;23&quot;&#125;//也可以返回List&lt;Map&lt;String, Object&gt;&gt;，list集合。\n\n","categories":["讨论社区项目"],"tags":["SpringMVC"]},{"title":"讨论社区02 - Spring 入门","url":"/2019/06/14/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA02%20-%20Spring-%E5%85%A5%E9%97%A8/","content":"Spring全家桶\nSpring Framework \nSpring Boot\nSpring Cloud (微服务,大项目拆分成若干子项目)\nSpring Cloud Data Flow(数据集成)\n官网: https://spring.io\n\nSpring Framework\nSpring Core\nIoC、AOP  (管理对象的思想,spring管理的对象叫做Bean.)\nSpring Data Access\nTransactions(事务)、Spring MyBatis\n\n\nWeb Servlet\nSpring MVC\n\n\nIntegration(集成)\nEmail、Scheduling(定时任务)、AMQP(消息队列)、Security(安全控制)\n\n\n\nSpring IoC\nInversion of Control\n控制反转，是一种面向对象编程的设计思想。\n\n\nDependency Injection\n依赖注入，是IoC思想的实现方式。\nIoC Container\nIoC容器，是实现依赖注入的关键，本质上是一个工厂。\n容器管理Bean的前提:提供Bean的类型,通过配置文件配置Bean之间的关系.\n降低Bean之间的耦合度\n\n代码部分\n主动获取:\n\n@SpringBootApplicationpublic class TalkingApplication &#123;\tpublic static void main(String[] args) &#123;\t\tSpringApplication.run(CommunityApplication.class, args);\t&#125;&#125;配置类,启动时自动扫描,扫描配置类所在的包以及子包下的Bean.@Component @Repository @Service @Controller\n\n测试代码要以其为配置类,需加上注解:\n@ContextConfiguration(classes = TalkingApplication.class)\n\n想要使用spring容器需要实现接口,ApplicationContextAware,实现接口中set方法.传入参数applicationContext(spring容器),他是一个接口,继承自BeanFactory.\n获取Bean:applicationContext.getBean(test.class);\npublic class TalkingApplicationTests implements ApplicationContextAware &#123;\tprivate ApplicationContext applicationContext;\t@Override\tpublic void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;\t\tthis.applicationContext = applicationContext;\t&#125;&#125;\n\n给Bean自定义名字:@Component(“名字”)\n初始化方法@PostConstruct,在构造器之后调用.销毁对象之前调用,@PreDestroy.\n@Scope()指定单例多例\n@Configuration配置类,用以装载使用第三方类.\n\n自动注入:\n@Autowired\n\n\n\n","categories":["讨论社区项目"],"tags":["Spring"]},{"title":"讨论社区01 - 搭建开发环境","url":"/2019/06/12/%E8%AE%A8%E8%AE%BA%E7%A4%BE%E5%8C%BA01%20-%20%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","content":"Apache Maven\n可以帮助我们构建项目、管理项目中的jar包\nMaven仓库：存放构件的位置\n构件:创建项目时依赖的资源jar包.\n本地仓库：默认是 ~/.m2/repository\n远程仓库：中央仓库(官网)、镜像仓库(第三方网站)、私服仓库(公司自己搭建)\n\n\n示例：安装、配置、常用命令\n下载 : http://maven.apache.org\n解压,配置conf文件夹下,settings.xml.修改为阿里云镜像仓库.标签下修改网址.\n\n\n\n&lt;mirror&gt;    &lt;id&gt;alimaven&lt;/id&gt;    &lt;name&gt;aliyun maven&lt;/name&gt;    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;        &lt;/mirror&gt;\n\n\n将bin文件路径配置到环境变量（添加到环境变量之后可以在 cmd 使用 mvn 命令）\n常用命令: 创建,编译(生成target文件夹),清除,测试.\n\nmvn cleanmvn buildmvn install\n\n在实际开发过程中可以将maven配置到其他路径。\n\nIntelliJ IDEA\n目前最流行的Java集成开发工具\n示例：安装、配置、创建项目\n下载: http://www.jetbrains.com/idea\nEclipse创建的项目需要导入(import),IDEA的直接open就可以.\nSettings的Editor下设置maven及其配置文件.\n创建maven模板项目.\n重新编译 Ctrl+F9\n\n\n\nSpring Initialize\n把包进行整合按功能划分归类.\n\n创建 Spring Boot 项目的引导工具\n\nhttps://start.spring.io\n\n\n\n\n\n示例：创建“讨论社区”项目\n\nspringboot内嵌了Tomcat.\n\n\n\nSpring Boot 入门示例\nSpring Boot 核心作用\n起步依赖、自动配置、端点监控\n\n起步依赖 ：创建项目之后直接通过配置pom.xml ，在其中添加 starter 需要的 jar 包则可以启动一个hello demo。\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\txsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\t&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\t&lt;parent&gt;\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\t\t&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\t\t&lt;version&gt;2.2.0.RELEASE&lt;/version&gt;\t\t&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;\t&lt;/parent&gt;\t&lt;groupId&gt;com.wx&lt;/groupId&gt;\t&lt;artifactId&gt;talking&lt;/artifactId&gt;\t&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\t&lt;name&gt;talking&lt;/name&gt;\t&lt;description&gt;a community demo&lt;/description&gt;\t&lt;properties&gt;\t\t&lt;java.version&gt;1.8&lt;/java.version&gt;\t&lt;/properties&gt;\t&lt;dependencies&gt;        &lt;!--springboot Thymeleaf模板支持--&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\t\t&lt;/dependency&gt;        &lt;!--springboot web模块支持--&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\t\t&lt;/dependency&gt;\t\t&lt;!--mysql 数据库连接--&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;mysql&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\t\t\t&lt;version&gt;8.0.18&lt;/version&gt;\t\t&lt;/dependency&gt;\t\t&lt;!--mybatis jar--&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;\t\t\t&lt;version&gt;2.1.0&lt;/version&gt;\t\t&lt;/dependency&gt;\t&lt;/dependencies&gt;\t&lt;build&gt;\t\t&lt;plugins&gt;\t\t\t&lt;plugin&gt;\t\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\t\t\t\t&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\t\t\t&lt;/plugin&gt;\t\t&lt;/plugins&gt;\t&lt;/build&gt;&lt;/project&gt;\n\nspring-boot-starter-web包自动帮我们引入了web模块开发需要的相关jar包，\nmybatis-spring-boot-starter帮我们引入了dao开发相关的jar包。\nspring-boot-starter-xxx是官方提供的starter，xxx-spring-boot-starter是第三方提供的starter。\n自动配置：利用 @Configuration 等注解的方式改造传统的基于 xml 的 bean 的配置\n&lt;!--传统基于 xml 方式配置 bean--&gt;&lt;beans&gt;      &lt;bean id = &quot;car&quot; class=&quot;com.wx.talking.entity.Car&quot;&gt;          &lt;property name=&quot;wheel&quot; ref = &quot;wheel&quot;&gt;&lt;/property&gt;      &lt;/bean&gt;      &lt;bean id = &quot;wheel&quot; class=&quot;com.itpsc.Wheel&quot;&gt;&lt;/bean&gt;  &lt;/beans&gt;\n\n// 使用注解的方式在java中配置@Configuration  public class Conf &#123;      @Bean      public Car car() &#123;          Car car = new Car();          car.setWheel(wheel());          return car;      &#125;      @Bean       public Wheel wheel() &#123;          return new Wheel();      &#125;  &#125;\n\n上面的代码中，MybatisAutoConfiguration这个类，自动帮我们生成了SqlSessionFactory这些Mybatis的重要实例并交给spring容器管理，从而完成bean的自动注册。\n在Spring中还有很多这样的注解：@Component @Service @Controller …\n端点监控：（@待续）\n\n示例:一个简单的处理客户端请求案例\n\napplication.properties文件进行配置\n# ServerPropertiesserver.port&#x3D;8080         服务器端口server.servlet.context-path&#x3D;&#x2F;community  项目访问路径\n\n\n\n\n","categories":["讨论社区项目","编程笔记"],"tags":["Apache Maven","Spring","SpringBoot"]},{"title":"Python 爬虫 01-通用爬虫基本流程","url":"/2018/10/18/Python-%E7%88%AC%E8%99%AB-01-%E9%80%9A%E7%94%A8%E7%88%AC%E8%99%AB%E7%BB%93%E6%9E%84/","content":"爬虫是什么爬虫：一段自动抓取互联网信息的程序，从互联网上抓取对于我们有价值的信息。\n通用爬虫基本流程用一个通用的网络爬虫结构来说明网络爬虫的基本工作流程：\n\n网络爬虫的基本工作流程如下：\n(1).   首先抓取一部分待取的种子URL；\n(2).   将这些URL放入待取的URL队列；\n(3).   从待取的URL队列中读取待抓取网页的URL，解析DNS并且得到主机的IP，将URL对应的网页内容下载下来，存储已下载网页库中，并将这些URL放入已抓取URL队列；\n(4).   分析已抓取URL队列中的URL，从已下载的网页数据分析出其他URL冰河已抓取的URL进行对比去重，最后将去重后的URL放入待抓取队列，从而进入下一个循环。\n","categories":["编程笔记"],"tags":["爬虫"]}]