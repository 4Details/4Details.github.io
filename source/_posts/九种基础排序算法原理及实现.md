---
title: 九种基础排序算法原理及实现
date: 2020-09-01 20:10:36
tags: [排序]
category: [算法笔记]
---

注：本文所述待排序列排序结果均为升序。

#  冒泡排序

冒泡排序是一种简单的排序算法，主要过程是循环遍历待排序列，一次比较两个元素，若是与结果序列顺序相反，则两个元素交换，直至序列中元素无需交换为止。

## 算法描述

1. 比较相邻元素，如果前一个元素比后一个元素大，则交换二者，否则进入2；
2. 对每一对相邻元素做同样的判断和操作，从开始第一对到序列中的最后一对元素，此时序列中最大元素在最后；
3. 针对序列中所有元素重复上述操作，除掉最后一个元素（此时最大值已经在最终位置）；
4. 重复1~3步骤，直至序列为升序序列。

##  代码实现

###  朴素版

```java

```

###  优化版

```java

```

## 算法分析

稳定性：在相邻元素相等时，元素之间不会发生交换，所以冒泡排序是**稳定排序**。

时间复杂度：双重循环，时间复杂度为O(n^2)。在最好情况下（数据已经有序），时间复杂度为O(n)。

##  适用场景

算法的时间复杂度为平方级，所以冒泡排序适合少量数据的排序，一般数量少于1000，一旦数据量过大，排序效率会下降很大，所以在数据量大的时候不适用。

#  选择排序

选择排序是一种简单直观的排序算法，同时也是一种交换类排序算法，与冒泡排序有些类似。

## 算法描述

1. 在待排序列中找出最小（大）元素，放入已排序数组的起始位置；
2. 在剩下的待排序列中继续找出最小（大）元素，放入已排序数组的最后位置；
3. 重复第2步，直至序列有序。

## 代码实现

```java
private static void selectionSort(int[] arr, int n){
    int min = 0;
    for (int i = 0; i < n; i++){
        min = i;
        // 循环查找待排序列中的最小值
        for (int j = i+1; j < n; j++){
            if (arr[min] > arr[j]){
                min = j;
            }
        }
        if (min != i){
            swap(arr, i, min);
        }
    }
}
```

## 算法分析

稳定性：使用数组实现的选择排序算法，在遇到相等元素时，插入到排序序列中，相对位置会发生变化，所以选择排序是不稳定的算法。但是使用链表实现的选择排序算法是稳定的。

时间复杂度：双重循环实现，时间复杂度为O(n^2)，在最好情况下（数据基本或已经有序），仍然需要O(n^2)。

##  适应场景

因为在各种情况下的时间复杂度固定为O(n^2)，所以只适用于小量数据的排序。

选择排序实现比较简单，并且在各种情况下的波动性较小，一般优于冒泡排序，在所有的完全交换类排序中，也是一个比较不多的算法。

#  插入排序

#  快速排序

#  归并排序

#  堆排序

#  希尔排序

#  桶排序

